<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>jax._src.numpy.lax_numpy &mdash; MagPI 0.0.1 documentation</title>
      <link rel="stylesheet" href="../../../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../../../_static/css/theme.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="../../../../_static/jquery.js?v=5d32c60e"></script>
        <script src="../../../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
        <script src="../../../../_static/documentation_options.js?v=d45e8c67"></script>
        <script src="../../../../_static/doctools.js?v=888ff710"></script>
        <script src="../../../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../../../index.html" class="icon icon-home">
            MagPI
          </a>
              <div class="version">
                0.0.1
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../source/modules.html">MagPi</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../../index.html">MagPI</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../../../index.html">Module code</a></li>
      <li class="breadcrumb-item active">jax._src.numpy.lax_numpy</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for jax._src.numpy.lax_numpy</h1><div class="highlight"><pre>
<span></span><span class="c1"># Copyright 2018 The JAX Authors.</span>
<span class="c1">#</span>
<span class="c1"># Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);</span>
<span class="c1"># you may not use this file except in compliance with the License.</span>
<span class="c1"># You may obtain a copy of the License at</span>
<span class="c1">#</span>
<span class="c1">#     https://www.apache.org/licenses/LICENSE-2.0</span>
<span class="c1">#</span>
<span class="c1"># Unless required by applicable law or agreed to in writing, software</span>
<span class="c1"># distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</span>
<span class="c1"># WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span>
<span class="c1"># See the License for the specific language governing permissions and</span>
<span class="c1"># limitations under the License.</span>

<span class="c1"># pytype: skip-file</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Implements the NumPy API, using the primitives in :mod:`jax.lax`.</span>

<span class="sd">NumPy operations are implemented in Python in terms of the primitive operations</span>
<span class="sd">in :mod:`jax.lax`. Since NumPy operations are not primitive and instead are</span>
<span class="sd">implemented in terms of :mod:`jax.lax` operations, we do not need to define</span>
<span class="sd">transformation rules such as gradient or batching rules. Instead,</span>
<span class="sd">transformations for NumPy primitives can be derived from the transformation</span>
<span class="sd">rules for the underlying :code:`lax` primitives.</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">annotations</span>

<span class="kn">import</span> <span class="nn">builtins</span>
<span class="kn">import</span> <span class="nn">collections</span>
<span class="kn">from</span> <span class="nn">collections.abc</span> <span class="kn">import</span> <span class="n">Sequence</span>
<span class="kn">from</span> <span class="nn">functools</span> <span class="kn">import</span> <span class="n">partial</span>
<span class="kn">import</span> <span class="nn">math</span>
<span class="kn">import</span> <span class="nn">operator</span>
<span class="kn">import</span> <span class="nn">types</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="p">(</span><span class="n">overload</span><span class="p">,</span> <span class="n">Any</span><span class="p">,</span> <span class="n">Callable</span><span class="p">,</span> <span class="n">Literal</span><span class="p">,</span> <span class="n">NamedTuple</span><span class="p">,</span> <span class="n">Optional</span><span class="p">,</span>
                    <span class="n">Protocol</span><span class="p">,</span> <span class="n">TypeVar</span><span class="p">,</span> <span class="n">Union</span><span class="p">)</span>
<span class="kn">from</span> <span class="nn">textwrap</span> <span class="kn">import</span> <span class="n">dedent</span> <span class="k">as</span> <span class="n">_dedent</span>
<span class="kn">import</span> <span class="nn">warnings</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">opt_einsum</span>

<span class="kn">import</span> <span class="nn">jax</span>
<span class="kn">from</span> <span class="nn">jax</span> <span class="kn">import</span> <span class="n">jit</span>
<span class="kn">from</span> <span class="nn">jax</span> <span class="kn">import</span> <span class="n">errors</span>
<span class="kn">from</span> <span class="nn">jax</span> <span class="kn">import</span> <span class="n">lax</span>
<span class="kn">from</span> <span class="nn">jax.tree_util</span> <span class="kn">import</span> <span class="n">tree_leaves</span><span class="p">,</span> <span class="n">tree_flatten</span><span class="p">,</span> <span class="n">tree_map</span>

<span class="kn">from</span> <span class="nn">jax._src</span> <span class="kn">import</span> <span class="n">api_util</span>
<span class="kn">from</span> <span class="nn">jax._src</span> <span class="kn">import</span> <span class="n">core</span>
<span class="kn">from</span> <span class="nn">jax._src</span> <span class="kn">import</span> <span class="n">dispatch</span>
<span class="kn">from</span> <span class="nn">jax._src</span> <span class="kn">import</span> <span class="n">dtypes</span>
<span class="kn">from</span> <span class="nn">jax._src.api_util</span> <span class="kn">import</span> <span class="n">_ensure_index_tuple</span>
<span class="kn">from</span> <span class="nn">jax._src.array</span> <span class="kn">import</span> <span class="n">ArrayImpl</span>
<span class="kn">from</span> <span class="nn">jax._src.core</span> <span class="kn">import</span> <span class="n">ShapedArray</span><span class="p">,</span> <span class="n">ConcreteArray</span>
<span class="kn">from</span> <span class="nn">jax._src.lax.lax</span> <span class="kn">import</span> <span class="p">(</span><span class="n">_array_copy</span><span class="p">,</span> <span class="n">_sort_lt_comparator</span><span class="p">,</span>
                              <span class="n">_sort_le_comparator</span><span class="p">,</span> <span class="n">PrecisionLike</span><span class="p">)</span>
<span class="kn">from</span> <span class="nn">jax._src.lax</span> <span class="kn">import</span> <span class="n">lax</span> <span class="k">as</span> <span class="n">lax_internal</span>
<span class="kn">from</span> <span class="nn">jax._src.lib</span> <span class="kn">import</span> <span class="n">xla_client</span>
<span class="kn">from</span> <span class="nn">jax._src.numpy</span> <span class="kn">import</span> <span class="n">reductions</span>
<span class="kn">from</span> <span class="nn">jax._src.numpy</span> <span class="kn">import</span> <span class="n">ufuncs</span>
<span class="kn">from</span> <span class="nn">jax._src.numpy</span> <span class="kn">import</span> <span class="n">util</span>
<span class="kn">from</span> <span class="nn">jax._src.numpy.vectorize</span> <span class="kn">import</span> <span class="n">vectorize</span>
<span class="kn">from</span> <span class="nn">jax._src.typing</span> <span class="kn">import</span> <span class="n">Array</span><span class="p">,</span> <span class="n">ArrayLike</span><span class="p">,</span> <span class="n">DimSize</span><span class="p">,</span> <span class="n">DuckTypedArray</span><span class="p">,</span> <span class="n">DType</span><span class="p">,</span> <span class="n">DTypeLike</span><span class="p">,</span> <span class="n">Shape</span>
<span class="kn">from</span> <span class="nn">jax._src.util</span> <span class="kn">import</span> <span class="p">(</span><span class="n">unzip2</span><span class="p">,</span> <span class="n">subvals</span><span class="p">,</span> <span class="n">safe_zip</span><span class="p">,</span>
                           <span class="n">ceil_of_ratio</span><span class="p">,</span> <span class="n">partition_list</span><span class="p">,</span>
                           <span class="n">canonicalize_axis</span> <span class="k">as</span> <span class="n">_canonicalize_axis</span><span class="p">,</span>
                           <span class="n">NumpyComplexWarning</span><span class="p">)</span>

<span class="n">newaxis</span> <span class="o">=</span> <span class="kc">None</span>
<span class="n">T</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">)</span>


<span class="c1"># Like core.canonicalize_shape, but also accept int-like (non-sequence)</span>
<span class="c1"># arguments for `shape`.</span>
<span class="k">def</span> <span class="nf">canonicalize_shape</span><span class="p">(</span><span class="n">shape</span><span class="p">:</span> <span class="n">Any</span><span class="p">,</span> <span class="n">context</span><span class="p">:</span> <span class="nb">str</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">core</span><span class="o">.</span><span class="n">Shape</span><span class="p">:</span>
  <span class="k">if</span> <span class="p">(</span><span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">shape</span><span class="p">,</span> <span class="p">(</span><span class="nb">tuple</span><span class="p">,</span> <span class="nb">list</span><span class="p">))</span> <span class="ow">and</span>
      <span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="n">shape</span><span class="p">,</span> <span class="s1">&#39;ndim&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">ndim</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)):</span>
    <span class="k">return</span> <span class="n">core</span><span class="o">.</span><span class="n">canonicalize_shape</span><span class="p">((</span><span class="n">shape</span><span class="p">,),</span> <span class="n">context</span><span class="p">)</span>  <span class="c1"># type: ignore</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">core</span><span class="o">.</span><span class="n">canonicalize_shape</span><span class="p">(</span><span class="n">shape</span><span class="p">,</span> <span class="n">context</span><span class="p">)</span>  <span class="c1"># type: ignore</span>

<span class="c1"># Common docstring additions:</span>

<span class="n">_PRECISION_DOC</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span><span class="se">\</span>
<span class="s2">In addition to the original NumPy arguments listed below, also supports</span>
<span class="s2">``precision`` for extra control over matrix-multiplication precision</span>
<span class="s2">on supported devices. ``precision`` may be set to ``None``, which means</span>
<span class="s2">default precision for the backend, a :class:`~jax.lax.Precision` enum value</span>
<span class="s2">(``Precision.DEFAULT``, ``Precision.HIGH`` or ``Precision.HIGHEST``) or a tuple</span>
<span class="s2">of two :class:`~jax.lax.Precision` enums indicating separate precision for each argument.</span>
<span class="s2">&quot;&quot;&quot;</span>

<span class="c1"># Some objects below rewrite their __module__ attribute to this name.</span>
<span class="n">_PUBLIC_MODULE_NAME</span> <span class="o">=</span> <span class="s2">&quot;jax.numpy&quot;</span>

<span class="c1"># NumPy constants</span>

<span class="n">pi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span>
<span class="n">e</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">e</span>
<span class="n">euler_gamma</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">euler_gamma</span>
<span class="n">inf</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span>
<span class="n">nan</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>

<span class="c1"># NumPy utility functions</span>

<span class="n">get_printoptions</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">get_printoptions</span>
<span class="n">printoptions</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">printoptions</span>
<span class="n">set_printoptions</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">set_printoptions</span>

<span class="nd">@util</span><span class="o">.</span><span class="n">_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">iscomplexobj</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">iscomplexobj</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">Any</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
  <span class="k">try</span><span class="p">:</span>
    <span class="n">typ</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">type</span>
  <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
    <span class="n">typ</span> <span class="o">=</span> <span class="n">asarray</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">type</span>
  <span class="k">return</span> <span class="n">issubdtype</span><span class="p">(</span><span class="n">typ</span><span class="p">,</span> <span class="n">complexfloating</span><span class="p">)</span>

<span class="n">shape</span> <span class="o">=</span> <span class="n">_shape</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span>
<span class="n">ndim</span> <span class="o">=</span> <span class="n">_ndim</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ndim</span>
<span class="n">size</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">size</span>

<span class="k">def</span> <span class="nf">_dtype</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">Any</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">DType</span><span class="p">:</span>
  <span class="k">return</span> <span class="n">dtypes</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">canonicalize</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

<span class="c1"># At present JAX doesn&#39;t have a reason to distinguish between scalars and arrays</span>
<span class="c1"># in its object system. Further, we want JAX scalars to have the same type</span>
<span class="c1"># promotion behaviors as JAX arrays. Rather than introducing a new type of JAX</span>
<span class="c1"># scalar object with JAX promotion behaviors, instead we make the JAX scalar</span>
<span class="c1"># types return JAX arrays when instantiated.</span>

<span class="k">class</span> <span class="nc">_ScalarMeta</span><span class="p">(</span><span class="nb">type</span><span class="p">):</span>
  <span class="n">dtype</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">dtype</span>

  <span class="k">def</span> <span class="fm">__hash__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
    <span class="k">return</span> <span class="nb">hash</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">type</span><span class="p">)</span>

  <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="n">Any</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
    <span class="k">return</span> <span class="nb">id</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">==</span> <span class="nb">id</span><span class="p">(</span><span class="n">other</span><span class="p">)</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="n">other</span>

  <span class="k">def</span> <span class="fm">__ne__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="n">Any</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
    <span class="k">return</span> <span class="ow">not</span> <span class="p">(</span><span class="bp">self</span> <span class="o">==</span> <span class="n">other</span><span class="p">)</span>

  <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="n">Any</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Array</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">asarray</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>

  <span class="k">def</span> <span class="fm">__instancecheck__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">instance</span><span class="p">:</span> <span class="n">Any</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
    <span class="k">return</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">instance</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">type</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">_abstractify_scalar_meta</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
  <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;JAX scalar type </span><span class="si">{</span><span class="n">x</span><span class="si">}</span><span class="s2"> cannot be interpreted as a JAX array.&quot;</span><span class="p">)</span>
<span class="n">api_util</span><span class="o">.</span><span class="n">_shaped_abstractify_handlers</span><span class="p">[</span><span class="n">_ScalarMeta</span><span class="p">]</span> <span class="o">=</span> <span class="n">_abstractify_scalar_meta</span>

<span class="k">def</span> <span class="nf">_make_scalar_type</span><span class="p">(</span><span class="n">np_scalar_type</span><span class="p">:</span> <span class="nb">type</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">_ScalarMeta</span><span class="p">:</span>
  <span class="n">meta</span> <span class="o">=</span> <span class="n">_ScalarMeta</span><span class="p">(</span><span class="n">np_scalar_type</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="p">(</span><span class="nb">object</span><span class="p">,),</span>
                     <span class="p">{</span><span class="s2">&quot;dtype&quot;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="n">np_scalar_type</span><span class="p">)})</span>
  <span class="n">meta</span><span class="o">.</span><span class="vm">__module__</span> <span class="o">=</span> <span class="n">_PUBLIC_MODULE_NAME</span>
  <span class="k">return</span> <span class="n">meta</span>

<span class="n">bool_</span> <span class="o">=</span> <span class="n">_make_scalar_type</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">bool_</span><span class="p">)</span>
<span class="n">uint4</span> <span class="o">=</span> <span class="n">_make_scalar_type</span><span class="p">(</span><span class="n">dtypes</span><span class="o">.</span><span class="n">uint4</span><span class="p">)</span>
<span class="n">uint8</span> <span class="o">=</span> <span class="n">_make_scalar_type</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>
<span class="n">uint16</span> <span class="o">=</span> <span class="n">_make_scalar_type</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">uint16</span><span class="p">)</span>
<span class="n">uint32</span> <span class="o">=</span> <span class="n">_make_scalar_type</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">uint32</span><span class="p">)</span>
<span class="n">uint64</span> <span class="o">=</span> <span class="n">_make_scalar_type</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">uint64</span><span class="p">)</span>
<span class="n">int4</span> <span class="o">=</span> <span class="n">_make_scalar_type</span><span class="p">(</span><span class="n">dtypes</span><span class="o">.</span><span class="n">int4</span><span class="p">)</span>
<span class="n">int8</span> <span class="o">=</span> <span class="n">_make_scalar_type</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int8</span><span class="p">)</span>
<span class="n">int16</span> <span class="o">=</span> <span class="n">_make_scalar_type</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int16</span><span class="p">)</span>
<span class="n">int32</span> <span class="o">=</span> <span class="n">_make_scalar_type</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
<span class="n">int64</span> <span class="o">=</span> <span class="n">_make_scalar_type</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">)</span>
<span class="n">float8_e4m3fn</span> <span class="o">=</span> <span class="n">_make_scalar_type</span><span class="p">(</span><span class="n">dtypes</span><span class="o">.</span><span class="n">float8_e4m3fn</span><span class="p">)</span>
<span class="n">float8_e4m3fnuz</span> <span class="o">=</span> <span class="n">_make_scalar_type</span><span class="p">(</span><span class="n">dtypes</span><span class="o">.</span><span class="n">float8_e4m3fnuz</span><span class="p">)</span>
<span class="n">float8_e5m2</span> <span class="o">=</span> <span class="n">_make_scalar_type</span><span class="p">(</span><span class="n">dtypes</span><span class="o">.</span><span class="n">float8_e5m2</span><span class="p">)</span>
<span class="n">float8_e5m2fnuz</span> <span class="o">=</span> <span class="n">_make_scalar_type</span><span class="p">(</span><span class="n">dtypes</span><span class="o">.</span><span class="n">float8_e5m2fnuz</span><span class="p">)</span>
<span class="n">float8_e4m3b11fnuz</span> <span class="o">=</span> <span class="n">_make_scalar_type</span><span class="p">(</span><span class="n">dtypes</span><span class="o">.</span><span class="n">float8_e4m3b11fnuz</span><span class="p">)</span>
<span class="n">bfloat16</span> <span class="o">=</span> <span class="n">_make_scalar_type</span><span class="p">(</span><span class="n">dtypes</span><span class="o">.</span><span class="n">bfloat16</span><span class="p">)</span>
<span class="n">float16</span> <span class="o">=</span> <span class="n">_make_scalar_type</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float16</span><span class="p">)</span>
<span class="n">float32</span> <span class="o">=</span> <span class="n">single</span> <span class="o">=</span> <span class="n">_make_scalar_type</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
<span class="n">float64</span> <span class="o">=</span> <span class="n">double</span> <span class="o">=</span> <span class="n">_make_scalar_type</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
<span class="n">complex64</span> <span class="o">=</span> <span class="n">csingle</span> <span class="o">=</span> <span class="n">_make_scalar_type</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">complex64</span><span class="p">)</span>
<span class="n">complex128</span> <span class="o">=</span> <span class="n">cdouble</span> <span class="o">=</span> <span class="n">_make_scalar_type</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">complex128</span><span class="p">)</span>

<span class="n">int_</span> <span class="o">=</span> <span class="n">int32</span> <span class="k">if</span> <span class="n">dtypes</span><span class="o">.</span><span class="n">int_</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">int32</span> <span class="k">else</span> <span class="n">int64</span>
<span class="n">uint</span> <span class="o">=</span> <span class="n">uint32</span> <span class="k">if</span> <span class="n">dtypes</span><span class="o">.</span><span class="n">uint</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">uint32</span> <span class="k">else</span> <span class="n">uint64</span>
<span class="n">float_</span><span class="p">:</span> <span class="n">Any</span> <span class="o">=</span> <span class="n">float32</span> <span class="k">if</span> <span class="n">dtypes</span><span class="o">.</span><span class="n">float_</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">float32</span> <span class="k">else</span> <span class="n">float64</span>
<span class="n">complex_</span> <span class="o">=</span> <span class="n">complex64</span> <span class="k">if</span> <span class="n">dtypes</span><span class="o">.</span><span class="n">complex_</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">complex64</span> <span class="k">else</span> <span class="n">complex128</span>

<span class="n">generic</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">generic</span>
<span class="n">number</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">number</span>
<span class="n">inexact</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">inexact</span>
<span class="n">complexfloating</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">complexfloating</span>
<span class="n">floating</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">floating</span>
<span class="n">integer</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">integer</span>
<span class="n">signedinteger</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">signedinteger</span>
<span class="n">unsignedinteger</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unsignedinteger</span>

<span class="n">flexible</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">flexible</span>
<span class="n">character</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">character</span>
<span class="n">object_</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">object_</span>

<span class="n">iinfo</span> <span class="o">=</span> <span class="n">dtypes</span><span class="o">.</span><span class="n">iinfo</span>
<span class="n">finfo</span> <span class="o">=</span> <span class="n">dtypes</span><span class="o">.</span><span class="n">finfo</span>

<span class="n">dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dtype</span>
<span class="n">can_cast</span> <span class="o">=</span> <span class="n">dtypes</span><span class="o">.</span><span class="n">can_cast</span>
<span class="n">promote_types</span> <span class="o">=</span> <span class="n">dtypes</span><span class="o">.</span><span class="n">promote_types</span>

<span class="n">ComplexWarning</span> <span class="o">=</span> <span class="n">NumpyComplexWarning</span>

<span class="n">array_str</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array_str</span>
<span class="n">array_repr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array_repr</span>

<span class="n">save</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">save</span>
<span class="n">savez</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">savez</span>

<span class="nd">@util</span><span class="o">.</span><span class="n">_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">_jnp_dtype</span><span class="p">(</span><span class="n">obj</span><span class="p">:</span> <span class="n">DTypeLike</span> <span class="o">|</span> <span class="kc">None</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">align</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
               <span class="n">copy</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">DType</span><span class="p">:</span>
<span class="w">  </span><span class="sd">&quot;&quot;&quot;Similar to np.dtype, but respects JAX dtype defaults.&quot;&quot;&quot;</span>
  <span class="k">if</span> <span class="n">dtypes</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">dtypes</span><span class="o">.</span><span class="n">extended</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">obj</span>  <span class="c1"># type: ignore[return-value]</span>
  <span class="k">if</span> <span class="n">obj</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
    <span class="n">obj</span> <span class="o">=</span> <span class="n">dtypes</span><span class="o">.</span><span class="n">float_</span>
  <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="nb">type</span><span class="p">)</span> <span class="ow">and</span> <span class="n">obj</span> <span class="ow">in</span> <span class="n">dtypes</span><span class="o">.</span><span class="n">python_scalar_dtypes</span><span class="p">:</span>
    <span class="n">obj</span> <span class="o">=</span> <span class="n">_DEFAULT_TYPEMAP</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">align</span><span class="o">=</span><span class="n">align</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="n">copy</span><span class="p">)</span><span class="o">.</span><span class="n">type</span><span class="p">]</span>
  <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">align</span><span class="o">=</span><span class="n">align</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="n">copy</span><span class="p">)</span>

<span class="c1">### utility functions</span>

<span class="n">_DEFAULT_TYPEMAP</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">type</span><span class="p">,</span> <span class="n">_ScalarMeta</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
  <span class="n">np</span><span class="o">.</span><span class="n">bool_</span><span class="p">:</span> <span class="n">bool_</span><span class="p">,</span>
  <span class="n">np</span><span class="o">.</span><span class="n">int_</span><span class="p">:</span> <span class="n">int_</span><span class="p">,</span>
  <span class="n">np</span><span class="o">.</span><span class="n">float_</span><span class="p">:</span> <span class="n">float_</span><span class="p">,</span>
  <span class="n">np</span><span class="o">.</span><span class="n">complex_</span><span class="p">:</span> <span class="n">complex_</span>
<span class="p">}</span>

<span class="n">_lax_const</span> <span class="o">=</span> <span class="n">lax_internal</span><span class="o">.</span><span class="n">_const</span>


<span class="k">def</span> <span class="nf">_convert_and_clip_integer</span><span class="p">(</span><span class="n">val</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">,</span> <span class="n">dtype</span><span class="p">:</span> <span class="n">DType</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Array</span><span class="p">:</span>
<span class="w">  </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">  Convert integer-typed val to specified integer dtype, clipping to dtype</span>
<span class="sd">  range rather than wrapping.</span>

<span class="sd">  Args:</span>
<span class="sd">    val: value to be converted</span>
<span class="sd">    dtype: dtype of output</span>

<span class="sd">  Returns:</span>
<span class="sd">    equivalent of val in new dtype</span>

<span class="sd">  Examples</span>
<span class="sd">  --------</span>
<span class="sd">  Normal integer type conversion will wrap:</span>

<span class="sd">  &gt;&gt;&gt; val = jnp.uint32(0xFFFFFFFF)</span>
<span class="sd">  &gt;&gt;&gt; val.astype(&#39;int32&#39;)</span>
<span class="sd">  Array(-1, dtype=int32)</span>

<span class="sd">  This function clips to the values representable in the new type:</span>

<span class="sd">  &gt;&gt;&gt; _convert_and_clip_integer(val, &#39;int32&#39;)</span>
<span class="sd">  Array(2147483647, dtype=int32)</span>
<span class="sd">  &quot;&quot;&quot;</span>
  <span class="n">val</span> <span class="o">=</span> <span class="n">val</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">Array</span><span class="p">)</span> <span class="k">else</span> <span class="n">asarray</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>
  <span class="n">dtype</span> <span class="o">=</span> <span class="n">dtypes</span><span class="o">.</span><span class="n">canonicalize_dtype</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span>
  <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">issubdtype</span><span class="p">(</span><span class="n">dtype</span><span class="p">,</span> <span class="n">integer</span><span class="p">)</span> <span class="ow">and</span> <span class="n">issubdtype</span><span class="p">(</span><span class="n">val</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">integer</span><span class="p">)):</span>
    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;_convert_and_clip_integer only accepts integer dtypes.&quot;</span><span class="p">)</span>

  <span class="n">val_dtype</span> <span class="o">=</span> <span class="n">dtypes</span><span class="o">.</span><span class="n">canonicalize_dtype</span><span class="p">(</span><span class="n">val</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">val_dtype</span> <span class="o">!=</span> <span class="n">val</span><span class="o">.</span><span class="n">dtype</span><span class="p">:</span>
    <span class="c1"># TODO(jakevdp): this is a weird corner case; need to figure out how to handle it.</span>
    <span class="c1"># This happens in X32 mode and can either come from a jax value created in another</span>
    <span class="c1"># context, or a Python integer converted to int64.</span>
    <span class="k">pass</span>
  <span class="n">min_val</span> <span class="o">=</span> <span class="n">_lax_const</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="nb">max</span><span class="p">(</span><span class="n">iinfo</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span><span class="o">.</span><span class="n">min</span><span class="p">,</span> <span class="n">iinfo</span><span class="p">(</span><span class="n">val_dtype</span><span class="p">)</span><span class="o">.</span><span class="n">min</span><span class="p">))</span>
  <span class="n">max_val</span> <span class="o">=</span> <span class="n">_lax_const</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="nb">min</span><span class="p">(</span><span class="n">iinfo</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span><span class="o">.</span><span class="n">max</span><span class="p">,</span> <span class="n">iinfo</span><span class="p">(</span><span class="n">val_dtype</span><span class="p">)</span><span class="o">.</span><span class="n">max</span><span class="p">))</span>
  <span class="k">return</span> <span class="n">clip</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">min_val</span><span class="p">,</span> <span class="n">max_val</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span>


<span class="nd">@util</span><span class="o">.</span><span class="n">_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">load</span><span class="p">,</span> <span class="n">update_doc</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">load</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">:</span> <span class="n">Any</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">:</span> <span class="n">Any</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Array</span><span class="p">:</span>
  <span class="c1"># The main purpose of this wrapper is to recover bfloat16 data types.</span>
  <span class="c1"># Note: this will only work for files created via np.save(), not np.savez().</span>
  <span class="n">out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
  <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
    <span class="c1"># numpy does not recognize bfloat16, so arrays are serialized as void16</span>
    <span class="k">if</span> <span class="n">out</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="s1">&#39;V2&#39;</span><span class="p">:</span>
      <span class="n">out</span> <span class="o">=</span> <span class="n">out</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">bfloat16</span><span class="p">)</span>
    <span class="k">try</span><span class="p">:</span>
      <span class="n">out</span> <span class="o">=</span> <span class="n">asarray</span><span class="p">(</span><span class="n">out</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>  <span class="c1"># Unsupported dtype</span>
      <span class="k">pass</span>
  <span class="k">return</span> <span class="n">out</span>

<span class="c1">### implementations of numpy functions in terms of lax</span>

<span class="nd">@util</span><span class="o">.</span><span class="n">_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">fmin</span><span class="p">,</span> <span class="n">module</span><span class="o">=</span><span class="s1">&#39;numpy&#39;</span><span class="p">)</span>
<span class="nd">@jit</span>
<span class="k">def</span> <span class="nf">fmin</span><span class="p">(</span><span class="n">x1</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">,</span> <span class="n">x2</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Array</span><span class="p">:</span>
  <span class="k">return</span> <span class="n">where</span><span class="p">(</span><span class="n">ufuncs</span><span class="o">.</span><span class="n">less</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">)</span> <span class="o">|</span> <span class="n">ufuncs</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">x2</span><span class="p">),</span> <span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">)</span>

<span class="nd">@util</span><span class="o">.</span><span class="n">_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">fmax</span><span class="p">,</span> <span class="n">module</span><span class="o">=</span><span class="s1">&#39;numpy&#39;</span><span class="p">)</span>
<span class="nd">@jit</span>
<span class="k">def</span> <span class="nf">fmax</span><span class="p">(</span><span class="n">x1</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">,</span> <span class="n">x2</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Array</span><span class="p">:</span>
  <span class="k">return</span> <span class="n">where</span><span class="p">(</span><span class="n">ufuncs</span><span class="o">.</span><span class="n">greater</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">)</span> <span class="o">|</span> <span class="n">ufuncs</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">x2</span><span class="p">),</span> <span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">)</span>

<span class="nd">@util</span><span class="o">.</span><span class="n">_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">issubdtype</span><span class="p">(</span><span class="n">arg1</span><span class="p">:</span> <span class="n">DTypeLike</span><span class="p">,</span> <span class="n">arg2</span><span class="p">:</span> <span class="n">DTypeLike</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
  <span class="k">return</span> <span class="n">dtypes</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="n">arg1</span><span class="p">,</span> <span class="n">arg2</span><span class="p">)</span>

<span class="nd">@util</span><span class="o">.</span><span class="n">_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isscalar</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">isscalar</span><span class="p">(</span><span class="n">element</span><span class="p">:</span> <span class="n">Any</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
  <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">element</span><span class="p">,</span> <span class="s1">&#39;__jax_array__&#39;</span><span class="p">):</span>
    <span class="n">element</span> <span class="o">=</span> <span class="n">element</span><span class="o">.</span><span class="n">__jax_array__</span><span class="p">()</span>
  <span class="k">return</span> <span class="n">dtypes</span><span class="o">.</span><span class="n">is_python_scalar</span><span class="p">(</span><span class="n">element</span><span class="p">)</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">isscalar</span><span class="p">(</span><span class="n">element</span><span class="p">)</span>

<span class="n">iterable</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">iterable</span>

<span class="nd">@util</span><span class="o">.</span><span class="n">_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">result_type</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">result_type</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">:</span> <span class="n">Any</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">DType</span><span class="p">:</span>
  <span class="k">return</span> <span class="n">dtypes</span><span class="o">.</span><span class="n">result_type</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>


<span class="nd">@util</span><span class="o">.</span><span class="n">_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">trapz</span><span class="p">)</span>
<span class="nd">@partial</span><span class="p">(</span><span class="n">jit</span><span class="p">,</span> <span class="n">static_argnames</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;axis&#39;</span><span class="p">,))</span>
<span class="k">def</span> <span class="nf">trapz</span><span class="p">(</span><span class="n">y</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="n">ArrayLike</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">dx</span><span class="p">:</span> <span class="n">ArrayLike</span> <span class="o">=</span> <span class="mf">1.0</span><span class="p">,</span> <span class="n">axis</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Array</span><span class="p">:</span>
  <span class="k">if</span> <span class="n">x</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
    <span class="n">util</span><span class="o">.</span><span class="n">check_arraylike</span><span class="p">(</span><span class="s1">&#39;trapz&#39;</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
    <span class="n">y_arr</span><span class="p">,</span> <span class="o">=</span> <span class="n">util</span><span class="o">.</span><span class="n">promote_dtypes_inexact</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="n">util</span><span class="o">.</span><span class="n">check_arraylike</span><span class="p">(</span><span class="s1">&#39;trapz&#39;</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
    <span class="n">y_arr</span><span class="p">,</span> <span class="n">x_arr</span> <span class="o">=</span> <span class="n">util</span><span class="o">.</span><span class="n">promote_dtypes_inexact</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">x_arr</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
      <span class="n">dx</span> <span class="o">=</span> <span class="n">diff</span><span class="p">(</span><span class="n">x_arr</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="n">dx</span> <span class="o">=</span> <span class="n">moveaxis</span><span class="p">(</span><span class="n">diff</span><span class="p">(</span><span class="n">x_arr</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">),</span> <span class="n">axis</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
  <span class="n">y_arr</span> <span class="o">=</span> <span class="n">moveaxis</span><span class="p">(</span><span class="n">y_arr</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
  <span class="k">return</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="n">dx</span> <span class="o">*</span> <span class="p">(</span><span class="n">y_arr</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">1</span><span class="p">:]</span> <span class="o">+</span> <span class="n">y_arr</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>


<span class="nd">@util</span><span class="o">.</span><span class="n">_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">trunc</span><span class="p">,</span> <span class="n">module</span><span class="o">=</span><span class="s1">&#39;numpy&#39;</span><span class="p">)</span>
<span class="nd">@jit</span>
<span class="k">def</span> <span class="nf">trunc</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Array</span><span class="p">:</span>
  <span class="n">util</span><span class="o">.</span><span class="n">check_arraylike</span><span class="p">(</span><span class="s1">&#39;trunc&#39;</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">where</span><span class="p">(</span><span class="n">lax</span><span class="o">.</span><span class="n">lt</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">_lax_const</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">0</span><span class="p">)),</span> <span class="n">ufuncs</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">ufuncs</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>


<span class="n">_PREFERRED_ELEMENT_TYPE_DESCRIPTION</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span>
<span class="s2">preferred_element_type : dtype, optional</span>
<span class="s2">    If specified, accumulate results and return a result of the given data type.</span>
<span class="s2">    If not specified, the function instead follows the numpy convention of always</span>
<span class="s2">    accumulating results and returning an inexact dtype.</span>
<span class="s2">&quot;&quot;&quot;</span>

<span class="nd">@partial</span><span class="p">(</span><span class="n">jit</span><span class="p">,</span> <span class="n">static_argnames</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;mode&#39;</span><span class="p">,</span> <span class="s1">&#39;op&#39;</span><span class="p">,</span> <span class="s1">&#39;precision&#39;</span><span class="p">,</span> <span class="s1">&#39;preferred_element_type&#39;</span><span class="p">])</span>
<span class="k">def</span> <span class="nf">_conv</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">Array</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">Array</span><span class="p">,</span> <span class="n">mode</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">op</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">precision</span><span class="p">:</span> <span class="n">PrecisionLike</span><span class="p">,</span>
          <span class="n">preferred_element_type</span><span class="p">:</span> <span class="n">DTypeLike</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Array</span><span class="p">:</span>
  <span class="k">if</span> <span class="n">ndim</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span> <span class="ow">or</span> <span class="n">ndim</span><span class="p">(</span><span class="n">y</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">op</span><span class="si">}</span><span class="s2">() only support 1-dimensional inputs.&quot;</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">preferred_element_type</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
    <span class="c1"># if unspecified, promote to inexact following NumPy&#39;s default for convolutions.</span>
    <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">util</span><span class="o">.</span><span class="n">promote_dtypes_inexact</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="c1"># otherwise cast to same type but otherwise preserve input dtypes</span>
    <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">util</span><span class="o">.</span><span class="n">promote_dtypes</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
  <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">y</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">op</span><span class="si">}</span><span class="s2">: inputs cannot be empty, got shapes </span><span class="si">{</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2"> and </span><span class="si">{</span><span class="n">y</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>

  <span class="n">out_order</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">op</span> <span class="o">==</span> <span class="s1">&#39;correlate&#39;</span><span class="p">:</span>
    <span class="n">y</span> <span class="o">=</span> <span class="n">ufuncs</span><span class="o">.</span><span class="n">conj</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">y</span><span class="p">):</span>
      <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">y</span><span class="p">,</span> <span class="n">x</span>
      <span class="n">out_order</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
  <span class="k">elif</span> <span class="n">op</span> <span class="o">==</span> <span class="s1">&#39;convolve&#39;</span><span class="p">:</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">y</span><span class="p">):</span>
      <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">y</span><span class="p">,</span> <span class="n">x</span>
    <span class="n">y</span> <span class="o">=</span> <span class="n">flip</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>

  <span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="s1">&#39;valid&#39;</span><span class="p">:</span>
    <span class="n">padding</span> <span class="o">=</span> <span class="p">[(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)]</span>
  <span class="k">elif</span> <span class="n">mode</span> <span class="o">==</span> <span class="s1">&#39;same&#39;</span><span class="p">:</span>
    <span class="n">padding</span> <span class="o">=</span> <span class="p">[(</span><span class="n">y</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">//</span> <span class="mi">2</span><span class="p">,</span> <span class="n">y</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">y</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">//</span> <span class="mi">2</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)]</span>
  <span class="k">elif</span> <span class="n">mode</span> <span class="o">==</span> <span class="s1">&#39;full&#39;</span><span class="p">:</span>
    <span class="n">padding</span> <span class="o">=</span> <span class="p">[(</span><span class="n">y</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">y</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)]</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;mode must be one of [&#39;full&#39;, &#39;same&#39;, &#39;valid&#39;]&quot;</span><span class="p">)</span>

  <span class="n">result</span> <span class="o">=</span> <span class="n">lax</span><span class="o">.</span><span class="n">conv_general_dilated</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="p">:],</span> <span class="n">y</span><span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="p">:],</span> <span class="p">(</span><span class="mi">1</span><span class="p">,),</span>
                                    <span class="n">padding</span><span class="p">,</span> <span class="n">precision</span><span class="o">=</span><span class="n">precision</span><span class="p">,</span>
                                    <span class="n">preferred_element_type</span><span class="o">=</span><span class="n">preferred_element_type</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">result</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">out_order</span><span class="p">]</span>


<span class="nd">@util</span><span class="o">.</span><span class="n">_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">convolve</span><span class="p">,</span> <span class="n">lax_description</span><span class="o">=</span><span class="n">_PRECISION_DOC</span><span class="p">,</span>
             <span class="n">extra_params</span><span class="o">=</span><span class="n">_PREFERRED_ELEMENT_TYPE_DESCRIPTION</span><span class="p">)</span>
<span class="nd">@partial</span><span class="p">(</span><span class="n">jit</span><span class="p">,</span> <span class="n">static_argnames</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;mode&#39;</span><span class="p">,</span> <span class="s1">&#39;precision&#39;</span><span class="p">,</span> <span class="s1">&#39;preferred_element_type&#39;</span><span class="p">))</span>
<span class="k">def</span> <span class="nf">convolve</span><span class="p">(</span><span class="n">a</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">,</span> <span class="n">v</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">,</span> <span class="n">mode</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;full&#39;</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span>
             <span class="n">precision</span><span class="p">:</span> <span class="n">PrecisionLike</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
             <span class="n">preferred_element_type</span><span class="p">:</span> <span class="n">dtype</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Array</span><span class="p">:</span>
  <span class="n">util</span><span class="o">.</span><span class="n">check_arraylike</span><span class="p">(</span><span class="s2">&quot;convolve&quot;</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">_conv</span><span class="p">(</span><span class="n">asarray</span><span class="p">(</span><span class="n">a</span><span class="p">),</span> <span class="n">asarray</span><span class="p">(</span><span class="n">v</span><span class="p">),</span> <span class="n">mode</span><span class="o">=</span><span class="n">mode</span><span class="p">,</span> <span class="n">op</span><span class="o">=</span><span class="s1">&#39;convolve&#39;</span><span class="p">,</span>
               <span class="n">precision</span><span class="o">=</span><span class="n">precision</span><span class="p">,</span> <span class="n">preferred_element_type</span><span class="o">=</span><span class="n">preferred_element_type</span><span class="p">)</span>


<span class="nd">@util</span><span class="o">.</span><span class="n">_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">correlate</span><span class="p">,</span> <span class="n">lax_description</span><span class="o">=</span><span class="n">_PRECISION_DOC</span><span class="p">,</span>
             <span class="n">extra_params</span><span class="o">=</span><span class="n">_PREFERRED_ELEMENT_TYPE_DESCRIPTION</span><span class="p">)</span>
<span class="nd">@partial</span><span class="p">(</span><span class="n">jit</span><span class="p">,</span> <span class="n">static_argnames</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;mode&#39;</span><span class="p">,</span> <span class="s1">&#39;precision&#39;</span><span class="p">,</span> <span class="s1">&#39;preferred_element_type&#39;</span><span class="p">))</span>
<span class="k">def</span> <span class="nf">correlate</span><span class="p">(</span><span class="n">a</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">,</span> <span class="n">v</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">,</span> <span class="n">mode</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;valid&#39;</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span>
              <span class="n">precision</span><span class="p">:</span> <span class="n">PrecisionLike</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
              <span class="n">preferred_element_type</span><span class="p">:</span> <span class="n">dtype</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Array</span><span class="p">:</span>
  <span class="n">util</span><span class="o">.</span><span class="n">check_arraylike</span><span class="p">(</span><span class="s2">&quot;correlate&quot;</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">_conv</span><span class="p">(</span><span class="n">asarray</span><span class="p">(</span><span class="n">a</span><span class="p">),</span> <span class="n">asarray</span><span class="p">(</span><span class="n">v</span><span class="p">),</span> <span class="n">mode</span><span class="o">=</span><span class="n">mode</span><span class="p">,</span> <span class="n">op</span><span class="o">=</span><span class="s1">&#39;correlate&#39;</span><span class="p">,</span>
               <span class="n">precision</span><span class="o">=</span><span class="n">precision</span><span class="p">,</span> <span class="n">preferred_element_type</span><span class="o">=</span><span class="n">preferred_element_type</span><span class="p">)</span>


<span class="nd">@util</span><span class="o">.</span><span class="n">_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">histogram_bin_edges</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">histogram_bin_edges</span><span class="p">(</span><span class="n">a</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">,</span> <span class="n">bins</span><span class="p">:</span> <span class="n">ArrayLike</span> <span class="o">=</span> <span class="mi">10</span><span class="p">,</span>
                        <span class="nb">range</span><span class="p">:</span> <span class="kc">None</span> <span class="o">|</span> <span class="n">Array</span> <span class="o">|</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">ArrayLike</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                        <span class="n">weights</span><span class="p">:</span> <span class="n">ArrayLike</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Array</span><span class="p">:</span>
  <span class="k">del</span> <span class="n">weights</span>  <span class="c1"># unused, because string bins is not supported.</span>
  <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">bins</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
    <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;string values for `bins` not implemented.&quot;</span><span class="p">)</span>
  <span class="n">util</span><span class="o">.</span><span class="n">check_arraylike</span><span class="p">(</span><span class="s2">&quot;histogram_bin_edges&quot;</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">bins</span><span class="p">)</span>
  <span class="n">arr</span> <span class="o">=</span> <span class="n">ravel</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
  <span class="n">dtype</span> <span class="o">=</span> <span class="n">dtypes</span><span class="o">.</span><span class="n">to_inexact_dtype</span><span class="p">(</span><span class="n">arr</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">_ndim</span><span class="p">(</span><span class="n">bins</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">asarray</span><span class="p">(</span><span class="n">bins</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>

  <span class="n">bins_int</span> <span class="o">=</span> <span class="n">core</span><span class="o">.</span><span class="n">concrete_or_error</span><span class="p">(</span><span class="n">operator</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">bins</span><span class="p">,</span>
                                    <span class="s2">&quot;bins argument of histogram_bin_edges&quot;</span><span class="p">)</span>
  <span class="k">if</span> <span class="nb">range</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
    <span class="nb">range</span> <span class="o">=</span> <span class="p">[</span><span class="n">arr</span><span class="o">.</span><span class="n">min</span><span class="p">(),</span> <span class="n">arr</span><span class="o">.</span><span class="n">max</span><span class="p">()]</span>
  <span class="nb">range</span> <span class="o">=</span> <span class="n">asarray</span><span class="p">(</span><span class="nb">range</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">shape</span><span class="p">(</span><span class="nb">range</span><span class="p">)</span> <span class="o">!=</span> <span class="p">(</span><span class="mi">2</span><span class="p">,):</span>
    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;`range` must be either None or a sequence of scalars, got </span><span class="si">{</span><span class="nb">range</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
  <span class="nb">range</span> <span class="o">=</span> <span class="p">(</span><span class="n">where</span><span class="p">(</span><span class="n">reductions</span><span class="o">.</span><span class="n">ptp</span><span class="p">(</span><span class="nb">range</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">range</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mf">0.5</span><span class="p">,</span> <span class="nb">range</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span>
           <span class="n">where</span><span class="p">(</span><span class="n">reductions</span><span class="o">.</span><span class="n">ptp</span><span class="p">(</span><span class="nb">range</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">range</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mf">0.5</span><span class="p">,</span> <span class="nb">range</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
  <span class="k">assert</span> <span class="nb">range</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
  <span class="k">return</span> <span class="n">linspace</span><span class="p">(</span><span class="nb">range</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">range</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">bins_int</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>


<span class="nd">@util</span><span class="o">.</span><span class="n">_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">histogram</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">histogram</span><span class="p">(</span><span class="n">a</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">,</span> <span class="n">bins</span><span class="p">:</span> <span class="n">ArrayLike</span> <span class="o">=</span> <span class="mi">10</span><span class="p">,</span>
              <span class="nb">range</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">ArrayLike</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
              <span class="n">weights</span><span class="p">:</span> <span class="n">ArrayLike</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
              <span class="n">density</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">Array</span><span class="p">,</span> <span class="n">Array</span><span class="p">]:</span>
  <span class="k">if</span> <span class="n">weights</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
    <span class="n">util</span><span class="o">.</span><span class="n">check_arraylike</span><span class="p">(</span><span class="s2">&quot;histogram&quot;</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">bins</span><span class="p">)</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">ravel</span><span class="p">(</span><span class="o">*</span><span class="n">util</span><span class="o">.</span><span class="n">promote_dtypes_inexact</span><span class="p">(</span><span class="n">a</span><span class="p">))</span>
    <span class="n">weights</span> <span class="o">=</span> <span class="n">ones_like</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="n">util</span><span class="o">.</span><span class="n">check_arraylike</span><span class="p">(</span><span class="s2">&quot;histogram&quot;</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">bins</span><span class="p">,</span> <span class="n">weights</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">shape</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">!=</span> <span class="n">shape</span><span class="p">(</span><span class="n">weights</span><span class="p">):</span>
      <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;weights should have the same shape as a.&quot;</span><span class="p">)</span>
    <span class="n">a</span><span class="p">,</span> <span class="n">weights</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="n">ravel</span><span class="p">,</span> <span class="n">util</span><span class="o">.</span><span class="n">promote_dtypes_inexact</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">weights</span><span class="p">))</span>

  <span class="n">bin_edges</span> <span class="o">=</span> <span class="n">histogram_bin_edges</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">bins</span><span class="p">,</span> <span class="nb">range</span><span class="p">,</span> <span class="n">weights</span><span class="p">)</span>
  <span class="n">bin_idx</span> <span class="o">=</span> <span class="n">searchsorted</span><span class="p">(</span><span class="n">bin_edges</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">side</span><span class="o">=</span><span class="s1">&#39;right&#39;</span><span class="p">)</span>
  <span class="n">bin_idx</span> <span class="o">=</span> <span class="n">where</span><span class="p">(</span><span class="n">a</span> <span class="o">==</span> <span class="n">bin_edges</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="nb">len</span><span class="p">(</span><span class="n">bin_edges</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">bin_idx</span><span class="p">)</span>
  <span class="n">counts</span> <span class="o">=</span> <span class="n">bincount</span><span class="p">(</span><span class="n">bin_idx</span><span class="p">,</span> <span class="n">weights</span><span class="p">,</span> <span class="n">length</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">bin_edges</span><span class="p">))[</span><span class="mi">1</span><span class="p">:]</span>
  <span class="k">if</span> <span class="n">density</span><span class="p">:</span>
    <span class="n">bin_widths</span> <span class="o">=</span> <span class="n">diff</span><span class="p">(</span><span class="n">bin_edges</span><span class="p">)</span>
    <span class="n">counts</span> <span class="o">=</span> <span class="n">counts</span> <span class="o">/</span> <span class="n">bin_widths</span> <span class="o">/</span> <span class="n">counts</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
  <span class="k">return</span> <span class="n">counts</span><span class="p">,</span> <span class="n">bin_edges</span>

<span class="nd">@util</span><span class="o">.</span><span class="n">_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">histogram2d</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">histogram2d</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">,</span> <span class="n">bins</span><span class="p">:</span> <span class="n">ArrayLike</span> <span class="o">|</span> <span class="nb">list</span><span class="p">[</span><span class="n">ArrayLike</span><span class="p">]</span> <span class="o">=</span> <span class="mi">10</span><span class="p">,</span>
                <span class="nb">range</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="kc">None</span> <span class="o">|</span> <span class="n">Array</span> <span class="o">|</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">ArrayLike</span><span class="p">]]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                <span class="n">weights</span><span class="p">:</span> <span class="n">ArrayLike</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                <span class="n">density</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">Array</span><span class="p">,</span> <span class="n">Array</span><span class="p">,</span> <span class="n">Array</span><span class="p">]:</span>
  <span class="n">util</span><span class="o">.</span><span class="n">check_arraylike</span><span class="p">(</span><span class="s2">&quot;histogram2d&quot;</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
  <span class="k">try</span><span class="p">:</span>
    <span class="n">N</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">bins</span><span class="p">)</span>  <span class="c1"># type: ignore[arg-type]</span>
  <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
    <span class="n">N</span> <span class="o">=</span> <span class="mi">1</span>

  <span class="k">if</span> <span class="n">N</span> <span class="o">!=</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">N</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
    <span class="n">x_edges</span> <span class="o">=</span> <span class="n">y_edges</span> <span class="o">=</span> <span class="n">asarray</span><span class="p">(</span><span class="n">bins</span><span class="p">)</span>
    <span class="n">bins</span> <span class="o">=</span> <span class="p">[</span><span class="n">x_edges</span><span class="p">,</span> <span class="n">y_edges</span><span class="p">]</span>

  <span class="n">sample</span> <span class="o">=</span> <span class="n">transpose</span><span class="p">(</span><span class="n">asarray</span><span class="p">([</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">]))</span>
  <span class="n">hist</span><span class="p">,</span> <span class="n">edges</span> <span class="o">=</span> <span class="n">histogramdd</span><span class="p">(</span><span class="n">sample</span><span class="p">,</span> <span class="n">bins</span><span class="p">,</span> <span class="nb">range</span><span class="p">,</span> <span class="n">weights</span><span class="p">,</span> <span class="n">density</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">hist</span><span class="p">,</span> <span class="n">edges</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">edges</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

<span class="nd">@util</span><span class="o">.</span><span class="n">_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">histogramdd</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">histogramdd</span><span class="p">(</span><span class="n">sample</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">,</span> <span class="n">bins</span><span class="p">:</span> <span class="n">ArrayLike</span> <span class="o">|</span> <span class="nb">list</span><span class="p">[</span><span class="n">ArrayLike</span><span class="p">]</span> <span class="o">=</span> <span class="mi">10</span><span class="p">,</span>
                <span class="nb">range</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="kc">None</span> <span class="o">|</span> <span class="n">Array</span> <span class="o">|</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">ArrayLike</span><span class="p">]]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                <span class="n">weights</span><span class="p">:</span> <span class="n">ArrayLike</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                <span class="n">density</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">Array</span><span class="p">,</span> <span class="nb">list</span><span class="p">[</span><span class="n">Array</span><span class="p">]]:</span>
  <span class="k">if</span> <span class="n">weights</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
    <span class="n">util</span><span class="o">.</span><span class="n">check_arraylike</span><span class="p">(</span><span class="s2">&quot;histogramdd&quot;</span><span class="p">,</span> <span class="n">sample</span><span class="p">)</span>
    <span class="n">sample</span><span class="p">,</span> <span class="o">=</span> <span class="n">util</span><span class="o">.</span><span class="n">promote_dtypes_inexact</span><span class="p">(</span><span class="n">sample</span><span class="p">)</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="n">util</span><span class="o">.</span><span class="n">check_arraylike</span><span class="p">(</span><span class="s2">&quot;histogramdd&quot;</span><span class="p">,</span> <span class="n">sample</span><span class="p">,</span> <span class="n">weights</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">shape</span><span class="p">(</span><span class="n">weights</span><span class="p">)</span> <span class="o">!=</span> <span class="n">shape</span><span class="p">(</span><span class="n">sample</span><span class="p">)[:</span><span class="mi">1</span><span class="p">]:</span>
      <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;should have one weight for each sample.&quot;</span><span class="p">)</span>
    <span class="n">sample</span><span class="p">,</span> <span class="n">weights</span> <span class="o">=</span> <span class="n">util</span><span class="o">.</span><span class="n">promote_dtypes_inexact</span><span class="p">(</span><span class="n">sample</span><span class="p">,</span> <span class="n">weights</span><span class="p">)</span>
  <span class="n">N</span><span class="p">,</span> <span class="n">D</span> <span class="o">=</span> <span class="n">shape</span><span class="p">(</span><span class="n">sample</span><span class="p">)</span>

  <span class="k">if</span> <span class="nb">range</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="p">(</span>
      <span class="nb">len</span><span class="p">(</span><span class="nb">range</span><span class="p">)</span> <span class="o">!=</span> <span class="n">D</span> <span class="ow">or</span> <span class="nb">any</span><span class="p">(</span><span class="n">r</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">shape</span><span class="p">(</span><span class="n">r</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">2</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">)):</span>  <span class="c1"># type: ignore[arg-type]</span>
    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;For sample.shape=</span><span class="si">{</span><span class="p">(</span><span class="n">N</span><span class="p">,</span><span class="w"> </span><span class="n">D</span><span class="p">)</span><span class="si">}</span><span class="s2">, range must be a sequence &quot;</span>
                     <span class="sa">f</span><span class="s2">&quot;of </span><span class="si">{</span><span class="n">D</span><span class="si">}</span><span class="s2"> pairs or Nones; got </span><span class="si">{</span><span class="nb">range</span><span class="si">=}</span><span class="s2">&quot;</span><span class="p">)</span>

  <span class="k">try</span><span class="p">:</span>
    <span class="n">num_bins</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">bins</span><span class="p">)</span>  <span class="c1"># type: ignore[arg-type]</span>
  <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
    <span class="c1"># when bin_size is integer, the same bin is used for each dimension</span>
    <span class="n">bins_per_dimension</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">ArrayLike</span><span class="p">]</span> <span class="o">=</span> <span class="n">D</span> <span class="o">*</span> <span class="p">[</span><span class="n">bins</span><span class="p">]</span>  <span class="c1"># type: ignore[assignment]</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="k">if</span> <span class="n">num_bins</span> <span class="o">!=</span> <span class="n">D</span><span class="p">:</span>
      <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;should be a bin for each dimension.&quot;</span><span class="p">)</span>
    <span class="n">bins_per_dimension</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">bins</span><span class="p">)</span>  <span class="c1"># type: ignore[arg-type]</span>

  <span class="n">bin_idx_by_dim</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
  <span class="n">bin_edges_by_dim</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>

  <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">builtins</span><span class="o">.</span><span class="n">range</span><span class="p">(</span><span class="n">D</span><span class="p">):</span>
    <span class="n">range_i</span> <span class="o">=</span> <span class="kc">None</span> <span class="k">if</span> <span class="nb">range</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="nb">range</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
    <span class="n">bin_edges</span> <span class="o">=</span> <span class="n">histogram_bin_edges</span><span class="p">(</span><span class="n">sample</span><span class="p">[:,</span> <span class="n">i</span><span class="p">],</span> <span class="n">bins_per_dimension</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">range_i</span><span class="p">,</span> <span class="n">weights</span><span class="p">)</span>
    <span class="n">bin_idx</span> <span class="o">=</span> <span class="n">searchsorted</span><span class="p">(</span><span class="n">bin_edges</span><span class="p">,</span> <span class="n">sample</span><span class="p">[:,</span> <span class="n">i</span><span class="p">],</span> <span class="n">side</span><span class="o">=</span><span class="s1">&#39;right&#39;</span><span class="p">)</span>
    <span class="n">bin_idx</span> <span class="o">=</span> <span class="n">where</span><span class="p">(</span><span class="n">sample</span><span class="p">[:,</span> <span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">bin_edges</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">bin_idx</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">bin_idx</span><span class="p">)</span>
    <span class="n">bin_idx_by_dim</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">bin_idx</span><span class="p">)</span>
    <span class="n">bin_edges_by_dim</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">bin_edges</span><span class="p">)</span>

  <span class="n">nbins</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">bin_edges</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span> <span class="k">for</span> <span class="n">bin_edges</span> <span class="ow">in</span> <span class="n">bin_edges_by_dim</span><span class="p">)</span>
  <span class="n">dedges</span> <span class="o">=</span> <span class="p">[</span><span class="n">diff</span><span class="p">(</span><span class="n">bin_edges</span><span class="p">)</span> <span class="k">for</span> <span class="n">bin_edges</span> <span class="ow">in</span> <span class="n">bin_edges_by_dim</span><span class="p">]</span>

  <span class="n">xy</span> <span class="o">=</span> <span class="n">ravel_multi_index</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">bin_idx_by_dim</span><span class="p">),</span> <span class="n">nbins</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;clip&#39;</span><span class="p">)</span>
  <span class="n">hist</span> <span class="o">=</span> <span class="n">bincount</span><span class="p">(</span><span class="n">xy</span><span class="p">,</span> <span class="n">weights</span><span class="p">,</span> <span class="n">length</span><span class="o">=</span><span class="n">math</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">nbins</span><span class="p">))</span>
  <span class="n">hist</span> <span class="o">=</span> <span class="n">reshape</span><span class="p">(</span><span class="n">hist</span><span class="p">,</span> <span class="n">nbins</span><span class="p">)</span>
  <span class="n">core</span> <span class="o">=</span> <span class="n">D</span><span class="o">*</span><span class="p">(</span><span class="nb">slice</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">),)</span>
  <span class="n">hist</span> <span class="o">=</span> <span class="n">hist</span><span class="p">[</span><span class="n">core</span><span class="p">]</span>

  <span class="k">if</span> <span class="n">density</span><span class="p">:</span>
    <span class="n">hist</span> <span class="o">=</span> <span class="n">hist</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">sample</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
    <span class="n">hist</span> <span class="o">/=</span> <span class="n">hist</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">norm</span> <span class="ow">in</span> <span class="n">ix_</span><span class="p">(</span><span class="o">*</span><span class="n">dedges</span><span class="p">):</span>
      <span class="n">hist</span> <span class="o">/=</span> <span class="n">norm</span>

  <span class="k">return</span> <span class="n">hist</span><span class="p">,</span> <span class="n">bin_edges_by_dim</span>


<span class="n">_ARRAY_VIEW_DOC</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span>
<span class="s2">The JAX version of this function may in some cases return a copy rather than a</span>
<span class="s2">view of the input.</span>
<span class="s2">&quot;&quot;&quot;</span>

<span class="nd">@util</span><span class="o">.</span><span class="n">_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">,</span> <span class="n">lax_description</span><span class="o">=</span><span class="n">_ARRAY_VIEW_DOC</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">transpose</span><span class="p">(</span><span class="n">a</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">,</span> <span class="n">axes</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Array</span><span class="p">:</span>
  <span class="n">util</span><span class="o">.</span><span class="n">check_arraylike</span><span class="p">(</span><span class="s2">&quot;transpose&quot;</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
  <span class="n">axes_</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">ndim</span><span class="p">(</span><span class="n">a</span><span class="p">))[::</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="k">if</span> <span class="n">axes</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">axes</span>
  <span class="n">axes_</span> <span class="o">=</span> <span class="p">[</span><span class="n">_canonicalize_axis</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">ndim</span><span class="p">(</span><span class="n">a</span><span class="p">))</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">axes_</span><span class="p">]</span>
  <span class="k">return</span> <span class="n">lax</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axes_</span><span class="p">)</span>


<span class="nd">@util</span><span class="o">.</span><span class="n">_wraps</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="s1">&#39;matrix_transpose&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">))</span>
<span class="k">def</span> <span class="nf">matrix_transpose</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">,</span> <span class="o">/</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Array</span><span class="p">:</span>
<span class="w">  </span><span class="sd">&quot;&quot;&quot;Transposes the last two dimensions of x.</span>

<span class="sd">  Parameters</span>
<span class="sd">  ----------</span>
<span class="sd">  x : array_like</span>
<span class="sd">      Input array. Must have ``x.ndim &gt;= 2``.</span>

<span class="sd">  Returns</span>
<span class="sd">  -------</span>
<span class="sd">  xT : Array</span>
<span class="sd">      Transposed array.</span>
<span class="sd">  &quot;&quot;&quot;</span>
  <span class="n">util</span><span class="o">.</span><span class="n">check_arraylike</span><span class="p">(</span><span class="s2">&quot;matrix_transpose&quot;</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
  <span class="n">ndim</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ndim</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">ndim</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;x must be at least two-dimensional for matrix_transpose; got </span><span class="si">{</span><span class="n">ndim</span><span class="si">=}</span><span class="s2">&quot;</span><span class="p">)</span>
  <span class="n">axes</span> <span class="o">=</span> <span class="p">(</span><span class="o">*</span><span class="nb">range</span><span class="p">(</span><span class="n">ndim</span> <span class="o">-</span> <span class="mi">2</span><span class="p">),</span> <span class="n">ndim</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ndim</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">lax</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">axes</span><span class="p">)</span>


<span class="nd">@util</span><span class="o">.</span><span class="n">_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">rot90</span><span class="p">,</span> <span class="n">lax_description</span><span class="o">=</span><span class="n">_ARRAY_VIEW_DOC</span><span class="p">)</span>
<span class="nd">@partial</span><span class="p">(</span><span class="n">jit</span><span class="p">,</span> <span class="n">static_argnames</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;k&#39;</span><span class="p">,</span> <span class="s1">&#39;axes&#39;</span><span class="p">))</span>
<span class="k">def</span> <span class="nf">rot90</span><span class="p">(</span><span class="n">m</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">,</span> <span class="n">k</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">axes</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span> <span class="o">-&gt;</span> <span class="n">Array</span><span class="p">:</span>
  <span class="n">util</span><span class="o">.</span><span class="n">check_arraylike</span><span class="p">(</span><span class="s2">&quot;rot90&quot;</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span>
  <span class="n">ax1</span><span class="p">,</span> <span class="n">ax2</span> <span class="o">=</span> <span class="n">axes</span>
  <span class="n">ax1</span> <span class="o">=</span> <span class="n">_canonicalize_axis</span><span class="p">(</span><span class="n">ax1</span><span class="p">,</span> <span class="n">ndim</span><span class="p">(</span><span class="n">m</span><span class="p">))</span>
  <span class="n">ax2</span> <span class="o">=</span> <span class="n">_canonicalize_axis</span><span class="p">(</span><span class="n">ax2</span><span class="p">,</span> <span class="n">ndim</span><span class="p">(</span><span class="n">m</span><span class="p">))</span>
  <span class="k">if</span> <span class="n">ax1</span> <span class="o">==</span> <span class="n">ax2</span><span class="p">:</span>
    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Axes must be different&quot;</span><span class="p">)</span>  <span class="c1"># same as numpy error</span>
  <span class="n">k</span> <span class="o">=</span> <span class="n">k</span> <span class="o">%</span> <span class="mi">4</span>
  <span class="k">if</span> <span class="n">k</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">asarray</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
  <span class="k">elif</span> <span class="n">k</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">flip</span><span class="p">(</span><span class="n">flip</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">ax1</span><span class="p">),</span> <span class="n">ax2</span><span class="p">)</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="n">perm</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">ndim</span><span class="p">(</span><span class="n">m</span><span class="p">)))</span>
    <span class="n">perm</span><span class="p">[</span><span class="n">ax1</span><span class="p">],</span> <span class="n">perm</span><span class="p">[</span><span class="n">ax2</span><span class="p">]</span> <span class="o">=</span> <span class="n">perm</span><span class="p">[</span><span class="n">ax2</span><span class="p">],</span> <span class="n">perm</span><span class="p">[</span><span class="n">ax1</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">k</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
      <span class="k">return</span> <span class="n">transpose</span><span class="p">(</span><span class="n">flip</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">ax2</span><span class="p">),</span> <span class="n">perm</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="k">return</span> <span class="n">flip</span><span class="p">(</span><span class="n">transpose</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">perm</span><span class="p">),</span> <span class="n">ax2</span><span class="p">)</span>


<span class="nd">@util</span><span class="o">.</span><span class="n">_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">flip</span><span class="p">,</span> <span class="n">lax_description</span><span class="o">=</span><span class="n">_ARRAY_VIEW_DOC</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">flip</span><span class="p">(</span><span class="n">m</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">,</span> <span class="n">axis</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Array</span><span class="p">:</span>
  <span class="n">util</span><span class="o">.</span><span class="n">check_arraylike</span><span class="p">(</span><span class="s2">&quot;flip&quot;</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">_flip</span><span class="p">(</span><span class="n">asarray</span><span class="p">(</span><span class="n">m</span><span class="p">),</span> <span class="n">reductions</span><span class="o">.</span><span class="n">_ensure_optional_axes</span><span class="p">(</span><span class="n">axis</span><span class="p">))</span>

<span class="nd">@partial</span><span class="p">(</span><span class="n">jit</span><span class="p">,</span> <span class="n">static_argnames</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;axis&#39;</span><span class="p">,))</span>
<span class="k">def</span> <span class="nf">_flip</span><span class="p">(</span><span class="n">m</span><span class="p">:</span> <span class="n">Array</span><span class="p">,</span> <span class="n">axis</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="o">...</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Array</span><span class="p">:</span>
  <span class="k">if</span> <span class="n">axis</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">lax</span><span class="o">.</span><span class="n">rev</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">shape</span><span class="p">(</span><span class="n">m</span><span class="p">)))))</span>
  <span class="n">axis</span> <span class="o">=</span> <span class="n">_ensure_index_tuple</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">lax</span><span class="o">.</span><span class="n">rev</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="p">[</span><span class="n">_canonicalize_axis</span><span class="p">(</span><span class="n">ax</span><span class="p">,</span> <span class="n">ndim</span><span class="p">(</span><span class="n">m</span><span class="p">))</span> <span class="k">for</span> <span class="n">ax</span> <span class="ow">in</span> <span class="n">axis</span><span class="p">])</span>


<span class="nd">@util</span><span class="o">.</span><span class="n">_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">fliplr</span><span class="p">,</span> <span class="n">lax_description</span><span class="o">=</span><span class="n">_ARRAY_VIEW_DOC</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">fliplr</span><span class="p">(</span><span class="n">m</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Array</span><span class="p">:</span>
  <span class="n">util</span><span class="o">.</span><span class="n">check_arraylike</span><span class="p">(</span><span class="s2">&quot;fliplr&quot;</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">_flip</span><span class="p">(</span><span class="n">asarray</span><span class="p">(</span><span class="n">m</span><span class="p">),</span> <span class="mi">1</span><span class="p">)</span>


<span class="nd">@util</span><span class="o">.</span><span class="n">_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">flipud</span><span class="p">,</span> <span class="n">lax_description</span><span class="o">=</span><span class="n">_ARRAY_VIEW_DOC</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">flipud</span><span class="p">(</span><span class="n">m</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Array</span><span class="p">:</span>
  <span class="n">util</span><span class="o">.</span><span class="n">check_arraylike</span><span class="p">(</span><span class="s2">&quot;flipud&quot;</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">_flip</span><span class="p">(</span><span class="n">asarray</span><span class="p">(</span><span class="n">m</span><span class="p">),</span> <span class="mi">0</span><span class="p">)</span>

<span class="nd">@util</span><span class="o">.</span><span class="n">_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">iscomplex</span><span class="p">)</span>
<span class="nd">@jit</span>
<span class="k">def</span> <span class="nf">iscomplex</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Array</span><span class="p">:</span>
  <span class="n">i</span> <span class="o">=</span> <span class="n">ufuncs</span><span class="o">.</span><span class="n">imag</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">lax</span><span class="o">.</span><span class="n">ne</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">_lax_const</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>

<span class="nd">@util</span><span class="o">.</span><span class="n">_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isreal</span><span class="p">)</span>
<span class="nd">@jit</span>
<span class="k">def</span> <span class="nf">isreal</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Array</span><span class="p">:</span>
  <span class="n">i</span> <span class="o">=</span> <span class="n">ufuncs</span><span class="o">.</span><span class="n">imag</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">lax</span><span class="o">.</span><span class="n">eq</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">_lax_const</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>

<span class="nd">@util</span><span class="o">.</span><span class="n">_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">angle</span><span class="p">)</span>
<span class="nd">@partial</span><span class="p">(</span><span class="n">jit</span><span class="p">,</span> <span class="n">static_argnames</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;deg&#39;</span><span class="p">])</span>
<span class="k">def</span> <span class="nf">angle</span><span class="p">(</span><span class="n">z</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">,</span> <span class="n">deg</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Array</span><span class="p">:</span>
  <span class="n">re</span> <span class="o">=</span> <span class="n">ufuncs</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">z</span><span class="p">)</span>
  <span class="n">im</span> <span class="o">=</span> <span class="n">ufuncs</span><span class="o">.</span><span class="n">imag</span><span class="p">(</span><span class="n">z</span><span class="p">)</span>
  <span class="n">dtype</span> <span class="o">=</span> <span class="n">_dtype</span><span class="p">(</span><span class="n">re</span><span class="p">)</span>
  <span class="k">if</span> <span class="ow">not</span> <span class="n">issubdtype</span><span class="p">(</span><span class="n">dtype</span><span class="p">,</span> <span class="n">inexact</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span>
      <span class="n">issubdtype</span><span class="p">(</span><span class="n">_dtype</span><span class="p">(</span><span class="n">z</span><span class="p">),</span> <span class="n">floating</span><span class="p">)</span> <span class="ow">and</span> <span class="n">ndim</span><span class="p">(</span><span class="n">z</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">):</span>
    <span class="n">dtype</span> <span class="o">=</span> <span class="n">dtypes</span><span class="o">.</span><span class="n">canonicalize_dtype</span><span class="p">(</span><span class="n">float_</span><span class="p">)</span>
    <span class="n">re</span> <span class="o">=</span> <span class="n">lax</span><span class="o">.</span><span class="n">convert_element_type</span><span class="p">(</span><span class="n">re</span><span class="p">,</span> <span class="n">dtype</span><span class="p">)</span>
    <span class="n">im</span> <span class="o">=</span> <span class="n">lax</span><span class="o">.</span><span class="n">convert_element_type</span><span class="p">(</span><span class="n">im</span><span class="p">,</span> <span class="n">dtype</span><span class="p">)</span>
  <span class="n">result</span> <span class="o">=</span> <span class="n">lax</span><span class="o">.</span><span class="n">atan2</span><span class="p">(</span><span class="n">im</span><span class="p">,</span> <span class="n">re</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">ufuncs</span><span class="o">.</span><span class="n">degrees</span><span class="p">(</span><span class="n">result</span><span class="p">)</span> <span class="k">if</span> <span class="n">deg</span> <span class="k">else</span> <span class="n">result</span>


<span class="nd">@util</span><span class="o">.</span><span class="n">_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">)</span>
<span class="nd">@partial</span><span class="p">(</span><span class="n">jit</span><span class="p">,</span> <span class="n">static_argnames</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;n&#39;</span><span class="p">,</span> <span class="s1">&#39;axis&#39;</span><span class="p">))</span>
<span class="k">def</span> <span class="nf">diff</span><span class="p">(</span><span class="n">a</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">,</span> <span class="n">n</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">axis</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>
         <span class="n">prepend</span><span class="p">:</span> <span class="n">ArrayLike</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
         <span class="n">append</span><span class="p">:</span> <span class="n">ArrayLike</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Array</span><span class="p">:</span>
  <span class="n">util</span><span class="o">.</span><span class="n">check_arraylike</span><span class="p">(</span><span class="s2">&quot;diff&quot;</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
  <span class="n">arr</span> <span class="o">=</span> <span class="n">asarray</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
  <span class="n">n</span> <span class="o">=</span> <span class="n">core</span><span class="o">.</span><span class="n">concrete_or_error</span><span class="p">(</span><span class="n">operator</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="s2">&quot;&#39;n&#39; argument of jnp.diff&quot;</span><span class="p">)</span>
  <span class="n">axis</span> <span class="o">=</span> <span class="n">core</span><span class="o">.</span><span class="n">concrete_or_error</span><span class="p">(</span><span class="n">operator</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="s2">&quot;&#39;axis&#39; argument of jnp.diff&quot;</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">arr</span>
  <span class="k">if</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;order must be non-negative but got </span><span class="si">{</span><span class="n">n</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">arr</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;diff requires input that is at least one dimensional; got </span><span class="si">{</span><span class="n">a</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

  <span class="n">nd</span> <span class="o">=</span> <span class="n">arr</span><span class="o">.</span><span class="n">ndim</span>
  <span class="n">axis</span> <span class="o">=</span> <span class="n">_canonicalize_axis</span><span class="p">(</span><span class="n">axis</span><span class="p">,</span> <span class="n">nd</span><span class="p">)</span>

  <span class="n">combined</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
  <span class="k">if</span> <span class="n">prepend</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
    <span class="n">util</span><span class="o">.</span><span class="n">check_arraylike</span><span class="p">(</span><span class="s2">&quot;diff&quot;</span><span class="p">,</span> <span class="n">prepend</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">isscalar</span><span class="p">(</span><span class="n">prepend</span><span class="p">):</span>
      <span class="n">shape</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">arr</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
      <span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
      <span class="n">prepend</span> <span class="o">=</span> <span class="n">broadcast_to</span><span class="p">(</span><span class="n">prepend</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">shape</span><span class="p">))</span>
    <span class="n">combined</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">asarray</span><span class="p">(</span><span class="n">prepend</span><span class="p">))</span>

  <span class="n">combined</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span>

  <span class="k">if</span> <span class="n">append</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
    <span class="n">util</span><span class="o">.</span><span class="n">check_arraylike</span><span class="p">(</span><span class="s2">&quot;diff&quot;</span><span class="p">,</span> <span class="n">append</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">isscalar</span><span class="p">(</span><span class="n">append</span><span class="p">):</span>
      <span class="n">shape</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">arr</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
      <span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
      <span class="n">append</span> <span class="o">=</span> <span class="n">broadcast_to</span><span class="p">(</span><span class="n">append</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">shape</span><span class="p">))</span>
    <span class="n">combined</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">asarray</span><span class="p">(</span><span class="n">append</span><span class="p">))</span>

  <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">combined</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
    <span class="n">arr</span> <span class="o">=</span> <span class="n">concatenate</span><span class="p">(</span><span class="n">combined</span><span class="p">,</span> <span class="n">axis</span><span class="p">)</span>

  <span class="n">slice1</span> <span class="o">=</span> <span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">)]</span> <span class="o">*</span> <span class="n">nd</span>
  <span class="n">slice2</span> <span class="o">=</span> <span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">)]</span> <span class="o">*</span> <span class="n">nd</span>
  <span class="n">slice1</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
  <span class="n">slice2</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
  <span class="n">slice1_tuple</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">slice1</span><span class="p">)</span>
  <span class="n">slice2_tuple</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">slice2</span><span class="p">)</span>

  <span class="n">op</span> <span class="o">=</span> <span class="n">ufuncs</span><span class="o">.</span><span class="n">not_equal</span> <span class="k">if</span> <span class="n">arr</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">bool_</span> <span class="k">else</span> <span class="n">ufuncs</span><span class="o">.</span><span class="n">subtract</span>
  <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
    <span class="n">arr</span> <span class="o">=</span> <span class="n">op</span><span class="p">(</span><span class="n">arr</span><span class="p">[</span><span class="n">slice1_tuple</span><span class="p">],</span> <span class="n">arr</span><span class="p">[</span><span class="n">slice2_tuple</span><span class="p">])</span>

  <span class="k">return</span> <span class="n">arr</span>

<span class="n">_EDIFF1D_DOC</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span><span class="se">\</span>
<span class="s2">Unlike NumPy&#39;s implementation of ediff1d, :py:func:`jax.numpy.ediff1d` will not</span>
<span class="s2">issue an error if casting ``to_end`` or ``to_begin`` to the type of ``ary``</span>
<span class="s2">loses precision.</span>
<span class="s2">&quot;&quot;&quot;</span>

<span class="nd">@util</span><span class="o">.</span><span class="n">_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ediff1d</span><span class="p">,</span> <span class="n">lax_description</span><span class="o">=</span><span class="n">_EDIFF1D_DOC</span><span class="p">)</span>
<span class="nd">@jit</span>
<span class="k">def</span> <span class="nf">ediff1d</span><span class="p">(</span><span class="n">ary</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">,</span> <span class="n">to_end</span><span class="p">:</span> <span class="n">ArrayLike</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
            <span class="n">to_begin</span><span class="p">:</span> <span class="n">ArrayLike</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Array</span><span class="p">:</span>
  <span class="n">util</span><span class="o">.</span><span class="n">check_arraylike</span><span class="p">(</span><span class="s2">&quot;ediff1d&quot;</span><span class="p">,</span> <span class="n">ary</span><span class="p">)</span>
  <span class="n">arr</span> <span class="o">=</span> <span class="n">ravel</span><span class="p">(</span><span class="n">ary</span><span class="p">)</span>
  <span class="n">result</span> <span class="o">=</span> <span class="n">lax</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="n">arr</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span> <span class="n">arr</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
  <span class="k">if</span> <span class="n">to_begin</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
    <span class="n">util</span><span class="o">.</span><span class="n">check_arraylike</span><span class="p">(</span><span class="s2">&quot;ediff1d&quot;</span><span class="p">,</span> <span class="n">to_begin</span><span class="p">)</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">concatenate</span><span class="p">((</span><span class="n">ravel</span><span class="p">(</span><span class="n">asarray</span><span class="p">(</span><span class="n">to_begin</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">arr</span><span class="o">.</span><span class="n">dtype</span><span class="p">)),</span> <span class="n">result</span><span class="p">))</span>
  <span class="k">if</span> <span class="n">to_end</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
    <span class="n">util</span><span class="o">.</span><span class="n">check_arraylike</span><span class="p">(</span><span class="s2">&quot;ediff1d&quot;</span><span class="p">,</span> <span class="n">to_end</span><span class="p">)</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">concatenate</span><span class="p">((</span><span class="n">result</span><span class="p">,</span> <span class="n">ravel</span><span class="p">(</span><span class="n">asarray</span><span class="p">(</span><span class="n">to_end</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">arr</span><span class="o">.</span><span class="n">dtype</span><span class="p">))))</span>
  <span class="k">return</span> <span class="n">result</span>


<span class="nd">@util</span><span class="o">.</span><span class="n">_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">gradient</span><span class="p">,</span> <span class="n">skip_params</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;edge_order&#39;</span><span class="p">])</span>
<span class="nd">@partial</span><span class="p">(</span><span class="n">jit</span><span class="p">,</span> <span class="n">static_argnames</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;axis&#39;</span><span class="p">,</span> <span class="s1">&#39;edge_order&#39;</span><span class="p">))</span>
<span class="k">def</span> <span class="nf">gradient</span><span class="p">(</span><span class="n">f</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">,</span> <span class="o">*</span><span class="n">varargs</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">,</span>
             <span class="n">axis</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="o">...</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
             <span class="n">edge_order</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Array</span> <span class="o">|</span> <span class="nb">list</span><span class="p">[</span><span class="n">Array</span><span class="p">]:</span>
  <span class="k">if</span> <span class="n">edge_order</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
    <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;The &#39;edge_order&#39; argument to jnp.gradient is not supported.&quot;</span><span class="p">)</span>
  <span class="n">a</span><span class="p">,</span> <span class="o">*</span><span class="n">spacing</span> <span class="o">=</span> <span class="n">util</span><span class="o">.</span><span class="n">promote_args_inexact</span><span class="p">(</span><span class="s2">&quot;gradient&quot;</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">varargs</span><span class="p">)</span>

  <span class="k">def</span> <span class="nf">gradient_along_axis</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="n">axis</span><span class="p">):</span>
    <span class="n">sliced</span> <span class="o">=</span> <span class="n">partial</span><span class="p">(</span><span class="n">lax</span><span class="o">.</span><span class="n">slice_in_dim</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>
    <span class="n">a_grad</span> <span class="o">=</span> <span class="n">concatenate</span><span class="p">((</span>
      <span class="p">(</span><span class="n">sliced</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="o">-</span> <span class="n">sliced</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)),</span>  <span class="c1"># upper edge</span>
      <span class="p">(</span><span class="n">sliced</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-</span> <span class="n">sliced</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">))</span> <span class="o">*</span> <span class="mf">0.5</span><span class="p">,</span>  <span class="c1"># inner</span>
      <span class="p">(</span><span class="n">sliced</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-</span> <span class="n">sliced</span><span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)),</span>  <span class="c1"># lower edge</span>
    <span class="p">),</span> <span class="n">axis</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">a_grad</span> <span class="o">/</span> <span class="n">h</span>

  <span class="k">if</span> <span class="n">axis</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
    <span class="n">axis_tuple</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">ndim</span><span class="p">))</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">axis</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
      <span class="n">axis</span> <span class="o">=</span> <span class="p">(</span><span class="n">axis</span><span class="p">,)</span>
    <span class="k">elif</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">axis</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">axis</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
      <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Give `axis` either as int or iterable&quot;</span><span class="p">)</span>
    <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
      <span class="k">return</span> <span class="p">[]</span>
    <span class="n">axis_tuple</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">_canonicalize_axis</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">a</span><span class="o">.</span><span class="n">ndim</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">axis</span><span class="p">)</span>

  <span class="k">if</span> <span class="nb">min</span><span class="p">([</span><span class="n">s</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="k">if</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">axis_tuple</span><span class="p">])</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Shape of array too small to calculate &quot;</span>
                     <span class="s2">&quot;a numerical gradient, &quot;</span>
                     <span class="s2">&quot;at least 2 elements are required.&quot;</span><span class="p">)</span>
  <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">spacing</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
    <span class="n">dx</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">ArrayLike</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mf">1.0</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">axis_tuple</span><span class="p">)</span>
  <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">spacing</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
    <span class="n">dx</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">spacing</span><span class="p">)</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">axis_tuple</span><span class="p">)</span>
  <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">spacing</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">axis_tuple</span><span class="p">):</span>
    <span class="n">dx</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">spacing</span><span class="p">)</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Invalid number of spacing arguments </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">spacing</span><span class="p">)</span><span class="si">}</span><span class="s2"> for </span><span class="si">{</span><span class="n">axis</span><span class="si">=}</span><span class="s2">&quot;</span><span class="p">)</span>

  <span class="k">if</span> <span class="n">ndim</span><span class="p">(</span><span class="n">dx</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
    <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;Non-constant spacing not implemented&quot;</span><span class="p">)</span>

  <span class="n">a_grad</span> <span class="o">=</span> <span class="p">[</span><span class="n">gradient_along_axis</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="n">ax</span><span class="p">)</span> <span class="k">for</span> <span class="n">ax</span><span class="p">,</span> <span class="n">h</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">axis_tuple</span><span class="p">,</span> <span class="n">dx</span><span class="p">)]</span>
  <span class="k">return</span> <span class="n">a_grad</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">axis_tuple</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">else</span> <span class="n">a_grad</span>


<span class="nd">@util</span><span class="o">.</span><span class="n">_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isrealobj</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">isrealobj</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">Any</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
  <span class="k">return</span> <span class="ow">not</span> <span class="n">iscomplexobj</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>


<span class="nd">@util</span><span class="o">.</span><span class="n">_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">,</span> <span class="n">lax_description</span><span class="o">=</span><span class="n">_ARRAY_VIEW_DOC</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">reshape</span><span class="p">(</span><span class="n">a</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">,</span> <span class="n">newshape</span><span class="p">:</span> <span class="n">DimSize</span> <span class="o">|</span> <span class="n">Shape</span><span class="p">,</span> <span class="n">order</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;C&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Array</span><span class="p">:</span>
  <span class="n">util</span><span class="o">.</span><span class="n">check_arraylike</span><span class="p">(</span><span class="s2">&quot;reshape&quot;</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
  <span class="k">try</span><span class="p">:</span>
    <span class="c1"># forward to method for ndarrays</span>
    <span class="k">return</span> <span class="n">a</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">newshape</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="n">order</span><span class="p">)</span>  <span class="c1"># type: ignore[call-overload,union-attr]</span>
  <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">asarray</span><span class="p">(</span><span class="n">a</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">newshape</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="n">order</span><span class="p">)</span>


<span class="nd">@util</span><span class="o">.</span><span class="n">_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ravel</span><span class="p">,</span> <span class="n">lax_description</span><span class="o">=</span><span class="n">_ARRAY_VIEW_DOC</span><span class="p">)</span>
<span class="nd">@partial</span><span class="p">(</span><span class="n">jit</span><span class="p">,</span> <span class="n">static_argnames</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;order&#39;</span><span class="p">,),</span> <span class="n">inline</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">ravel</span><span class="p">(</span><span class="n">a</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">,</span> <span class="n">order</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;C&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Array</span><span class="p">:</span>
  <span class="n">util</span><span class="o">.</span><span class="n">check_arraylike</span><span class="p">(</span><span class="s2">&quot;ravel&quot;</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">order</span> <span class="o">==</span> <span class="s2">&quot;K&quot;</span><span class="p">:</span>
    <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;Ravel not implemented for order=&#39;K&#39;.&quot;</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">reshape</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="p">(</span><span class="n">size</span><span class="p">(</span><span class="n">a</span><span class="p">),),</span> <span class="n">order</span><span class="p">)</span>


<span class="nd">@util</span><span class="o">.</span><span class="n">_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ravel_multi_index</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">ravel_multi_index</span><span class="p">(</span><span class="n">multi_index</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">ArrayLike</span><span class="p">,</span> <span class="o">...</span><span class="p">],</span> <span class="n">dims</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="o">...</span><span class="p">],</span>
                      <span class="n">mode</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;raise&#39;</span><span class="p">,</span> <span class="n">order</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;C&#39;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Array</span><span class="p">:</span>
  <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">multi_index</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">dims</span><span class="p">),</span> <span class="sa">f</span><span class="s2">&quot;len(multi_index)=</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">multi_index</span><span class="p">)</span><span class="si">}</span><span class="s2"> != len(dims)=</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">dims</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
  <span class="n">dims</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">core</span><span class="o">.</span><span class="n">concrete_or_error</span><span class="p">(</span><span class="n">operator</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="s2">&quot;in `dims` argument of ravel_multi_index().&quot;</span><span class="p">)</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">dims</span><span class="p">)</span>
  <span class="n">util</span><span class="o">.</span><span class="n">check_arraylike</span><span class="p">(</span><span class="s2">&quot;ravel_multi_index&quot;</span><span class="p">,</span> <span class="o">*</span><span class="n">multi_index</span><span class="p">)</span>
  <span class="n">multi_index_arr</span> <span class="o">=</span> <span class="p">[</span><span class="n">asarray</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">multi_index</span><span class="p">]</span>
  <span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="n">multi_index_arr</span><span class="p">:</span>
    <span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="s1">&#39;raise&#39;</span><span class="p">:</span>
      <span class="n">core</span><span class="o">.</span><span class="n">concrete_or_error</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span>
        <span class="s2">&quot;The error occurred because ravel_multi_index was jit-compiled&quot;</span>
        <span class="s2">&quot; with mode=&#39;raise&#39;. Use mode=&#39;wrap&#39; or mode=&#39;clip&#39; instead.&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">issubdtype</span><span class="p">(</span><span class="n">_dtype</span><span class="p">(</span><span class="n">index</span><span class="p">),</span> <span class="n">integer</span><span class="p">):</span>
      <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;only int indices permitted&quot;</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="s2">&quot;raise&quot;</span><span class="p">:</span>
    <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">reductions</span><span class="o">.</span><span class="n">any</span><span class="p">((</span><span class="n">i</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">i</span> <span class="o">&gt;=</span> <span class="n">d</span><span class="p">))</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">d</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">multi_index_arr</span><span class="p">,</span> <span class="n">dims</span><span class="p">)):</span>
      <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;invalid entry in coordinates array&quot;</span><span class="p">)</span>
  <span class="k">elif</span> <span class="n">mode</span> <span class="o">==</span> <span class="s2">&quot;clip&quot;</span><span class="p">:</span>
    <span class="n">multi_index_arr</span> <span class="o">=</span> <span class="p">[</span><span class="n">clip</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">d</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">d</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">multi_index_arr</span><span class="p">,</span> <span class="n">dims</span><span class="p">)]</span>
  <span class="k">elif</span> <span class="n">mode</span> <span class="o">==</span> <span class="s2">&quot;wrap&quot;</span><span class="p">:</span>
    <span class="n">multi_index_arr</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="o">%</span> <span class="n">d</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">d</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">multi_index_arr</span><span class="p">,</span> <span class="n">dims</span><span class="p">)]</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;invalid mode=</span><span class="si">{</span><span class="n">mode</span><span class="si">!r}</span><span class="s2">. Expected &#39;raise&#39;, &#39;wrap&#39;, or &#39;clip&#39;&quot;</span><span class="p">)</span>

  <span class="k">if</span> <span class="n">order</span> <span class="o">==</span> <span class="s2">&quot;F&quot;</span><span class="p">:</span>
    <span class="n">strides</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cumprod</span><span class="p">((</span><span class="mi">1</span><span class="p">,)</span> <span class="o">+</span> <span class="n">dims</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
  <span class="k">elif</span> <span class="n">order</span> <span class="o">==</span> <span class="s2">&quot;C&quot;</span><span class="p">:</span>
    <span class="n">strides</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cumprod</span><span class="p">((</span><span class="mi">1</span><span class="p">,)</span> <span class="o">+</span> <span class="n">dims</span><span class="p">[</span><span class="mi">1</span><span class="p">:][::</span><span class="o">-</span><span class="mi">1</span><span class="p">])[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;invalid order=</span><span class="si">{</span><span class="n">order</span><span class="si">!r}</span><span class="s2">. Expected &#39;C&#39; or &#39;F&#39;&quot;</span><span class="p">)</span>

  <span class="n">result</span> <span class="o">=</span> <span class="n">array</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="p">(</span><span class="n">multi_index_arr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">dtype</span> <span class="k">if</span> <span class="n">multi_index_arr</span>
                           <span class="k">else</span> <span class="n">dtypes</span><span class="o">.</span><span class="n">canonicalize_dtype</span><span class="p">(</span><span class="n">int_</span><span class="p">)))</span>
  <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">multi_index_arr</span><span class="p">,</span> <span class="n">strides</span><span class="p">):</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">result</span> <span class="o">+</span> <span class="n">i</span> <span class="o">*</span> <span class="nb">int</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">result</span>


<span class="n">_UNRAVEL_INDEX_DOC</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span><span class="se">\</span>
<span class="s2">Unlike numpy&#39;s implementation of unravel_index, negative indices are accepted</span>
<span class="s2">and out-of-bounds indices are clipped into the valid range.</span>
<span class="s2">&quot;&quot;&quot;</span>

<span class="nd">@util</span><span class="o">.</span><span class="n">_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">unravel_index</span><span class="p">,</span> <span class="n">lax_description</span><span class="o">=</span><span class="n">_UNRAVEL_INDEX_DOC</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">unravel_index</span><span class="p">(</span><span class="n">indices</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">,</span> <span class="n">shape</span><span class="p">:</span> <span class="n">Shape</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">Array</span><span class="p">,</span> <span class="o">...</span><span class="p">]:</span>
  <span class="n">util</span><span class="o">.</span><span class="n">check_arraylike</span><span class="p">(</span><span class="s2">&quot;unravel_index&quot;</span><span class="p">,</span> <span class="n">indices</span><span class="p">)</span>
  <span class="n">indices_arr</span> <span class="o">=</span> <span class="n">asarray</span><span class="p">(</span><span class="n">indices</span><span class="p">)</span>
  <span class="c1"># Note: we do not convert shape to an array, because it may be passed as a</span>
  <span class="c1"># tuple of weakly-typed values, and asarray() would strip these weak types.</span>
  <span class="k">try</span><span class="p">:</span>
    <span class="n">shape</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span>
  <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
    <span class="n">shape</span> <span class="o">=</span> <span class="p">[</span><span class="n">shape</span><span class="p">]</span>
  <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">ndim</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">shape</span><span class="p">):</span>
    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;unravel_index: shape should be a scalar or 1D sequence.&quot;</span><span class="p">)</span>
  <span class="n">out_indices</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span>
  <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">reversed</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">enumerate</span><span class="p">(</span><span class="n">shape</span><span class="p">))):</span>
    <span class="n">indices_arr</span><span class="p">,</span> <span class="n">out_indices</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">ufuncs</span><span class="o">.</span><span class="n">divmod</span><span class="p">(</span><span class="n">indices_arr</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span>
  <span class="n">oob_pos</span> <span class="o">=</span> <span class="n">indices_arr</span> <span class="o">&gt;</span> <span class="mi">0</span>
  <span class="n">oob_neg</span> <span class="o">=</span> <span class="n">indices_arr</span> <span class="o">&lt;</span> <span class="o">-</span><span class="mi">1</span>
  <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">where</span><span class="p">(</span><span class="n">oob_pos</span><span class="p">,</span> <span class="n">s</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">where</span><span class="p">(</span><span class="n">oob_neg</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">i</span><span class="p">))</span>
               <span class="k">for</span> <span class="n">s</span><span class="p">,</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">safe_zip</span><span class="p">(</span><span class="n">shape</span><span class="p">,</span> <span class="n">out_indices</span><span class="p">))</span>

<span class="nd">@util</span><span class="o">.</span><span class="n">_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">resize</span><span class="p">)</span>
<span class="nd">@partial</span><span class="p">(</span><span class="n">jit</span><span class="p">,</span> <span class="n">static_argnames</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;new_shape&#39;</span><span class="p">,))</span>
<span class="k">def</span> <span class="nf">resize</span><span class="p">(</span><span class="n">a</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">,</span> <span class="n">new_shape</span><span class="p">:</span> <span class="n">Shape</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Array</span><span class="p">:</span>
  <span class="n">util</span><span class="o">.</span><span class="n">check_arraylike</span><span class="p">(</span><span class="s2">&quot;resize&quot;</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
  <span class="n">new_shape</span> <span class="o">=</span> <span class="n">_ensure_index_tuple</span><span class="p">(</span><span class="n">new_shape</span><span class="p">)</span>

  <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">dim_length</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="k">for</span> <span class="n">dim_length</span> <span class="ow">in</span> <span class="n">new_shape</span><span class="p">):</span>
    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;all elements of `new_shape` must be non-negative&quot;</span><span class="p">)</span>

  <span class="n">arr</span> <span class="o">=</span> <span class="n">ravel</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>

  <span class="n">new_size</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">new_shape</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">arr</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">new_size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">zeros_like</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="n">new_shape</span><span class="p">)</span>

  <span class="n">repeats</span> <span class="o">=</span> <span class="n">ceil_of_ratio</span><span class="p">(</span><span class="n">new_size</span><span class="p">,</span> <span class="n">arr</span><span class="o">.</span><span class="n">size</span><span class="p">)</span>
  <span class="n">arr</span> <span class="o">=</span> <span class="n">tile</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">repeats</span><span class="p">)[:</span><span class="n">new_size</span><span class="p">]</span>

  <span class="k">return</span> <span class="n">reshape</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">new_shape</span><span class="p">)</span>

<span class="nd">@util</span><span class="o">.</span><span class="n">_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">,</span> <span class="n">lax_description</span><span class="o">=</span><span class="n">_ARRAY_VIEW_DOC</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">squeeze</span><span class="p">(</span><span class="n">a</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">,</span> <span class="n">axis</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="o">...</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Array</span><span class="p">:</span>
  <span class="n">util</span><span class="o">.</span><span class="n">check_arraylike</span><span class="p">(</span><span class="s2">&quot;squeeze&quot;</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">_squeeze</span><span class="p">(</span><span class="n">asarray</span><span class="p">(</span><span class="n">a</span><span class="p">),</span> <span class="n">_ensure_index_tuple</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span> <span class="k">if</span> <span class="n">axis</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="kc">None</span><span class="p">)</span>

<span class="nd">@partial</span><span class="p">(</span><span class="n">jit</span><span class="p">,</span> <span class="n">static_argnames</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;axis&#39;</span><span class="p">,),</span> <span class="n">inline</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">_squeeze</span><span class="p">(</span><span class="n">a</span><span class="p">:</span> <span class="n">Array</span><span class="p">,</span> <span class="n">axis</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Array</span><span class="p">:</span>
  <span class="k">if</span> <span class="n">axis</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
    <span class="n">a_shape</span> <span class="o">=</span> <span class="n">shape</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">core</span><span class="o">.</span><span class="n">is_constant_shape</span><span class="p">(</span><span class="n">a_shape</span><span class="p">):</span>
      <span class="c1"># We do not even know the rank of the output if the input shape is not known</span>
      <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;jnp.squeeze with axis=None is not supported with shape polymorphism&quot;</span><span class="p">)</span>
    <span class="n">axis</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">d</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">a_shape</span><span class="p">)</span> <span class="k">if</span> <span class="n">d</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">lax</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="p">)</span>


<span class="nd">@util</span><span class="o">.</span><span class="n">_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">expand_dims</span><span class="p">(</span><span class="n">a</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">,</span> <span class="n">axis</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Array</span><span class="p">:</span>
  <span class="n">util</span><span class="o">.</span><span class="n">check_arraylike</span><span class="p">(</span><span class="s2">&quot;expand_dims&quot;</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
  <span class="n">axis</span> <span class="o">=</span> <span class="n">_ensure_index_tuple</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">lax</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="p">)</span>


<span class="nd">@util</span><span class="o">.</span><span class="n">_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">swapaxes</span><span class="p">,</span> <span class="n">lax_description</span><span class="o">=</span><span class="n">_ARRAY_VIEW_DOC</span><span class="p">)</span>
<span class="nd">@partial</span><span class="p">(</span><span class="n">jit</span><span class="p">,</span> <span class="n">static_argnames</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;axis1&#39;</span><span class="p">,</span> <span class="s1">&#39;axis2&#39;</span><span class="p">),</span> <span class="n">inline</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">swapaxes</span><span class="p">(</span><span class="n">a</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">,</span> <span class="n">axis1</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">axis2</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Array</span><span class="p">:</span>
  <span class="n">util</span><span class="o">.</span><span class="n">check_arraylike</span><span class="p">(</span><span class="s2">&quot;swapaxes&quot;</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
  <span class="n">perm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">ndim</span><span class="p">(</span><span class="n">a</span><span class="p">))</span>
  <span class="n">perm</span><span class="p">[</span><span class="n">axis1</span><span class="p">],</span> <span class="n">perm</span><span class="p">[</span><span class="n">axis2</span><span class="p">]</span> <span class="o">=</span> <span class="n">perm</span><span class="p">[</span><span class="n">axis2</span><span class="p">],</span> <span class="n">perm</span><span class="p">[</span><span class="n">axis1</span><span class="p">]</span>
  <span class="k">return</span> <span class="n">lax</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="nb">list</span><span class="p">(</span><span class="n">perm</span><span class="p">))</span>


<span class="nd">@util</span><span class="o">.</span><span class="n">_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">moveaxis</span><span class="p">,</span> <span class="n">lax_description</span><span class="o">=</span><span class="n">_ARRAY_VIEW_DOC</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">moveaxis</span><span class="p">(</span><span class="n">a</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">,</span> <span class="n">source</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span>
             <span class="n">destination</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Array</span><span class="p">:</span>
  <span class="n">util</span><span class="o">.</span><span class="n">check_arraylike</span><span class="p">(</span><span class="s2">&quot;moveaxis&quot;</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">_moveaxis</span><span class="p">(</span><span class="n">asarray</span><span class="p">(</span><span class="n">a</span><span class="p">),</span> <span class="n">_ensure_index_tuple</span><span class="p">(</span><span class="n">source</span><span class="p">),</span>
                   <span class="n">_ensure_index_tuple</span><span class="p">(</span><span class="n">destination</span><span class="p">))</span>

<span class="nd">@partial</span><span class="p">(</span><span class="n">jit</span><span class="p">,</span> <span class="n">static_argnames</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;source&#39;</span><span class="p">,</span> <span class="s1">&#39;destination&#39;</span><span class="p">),</span> <span class="n">inline</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">_moveaxis</span><span class="p">(</span><span class="n">a</span><span class="p">:</span> <span class="n">Array</span><span class="p">,</span> <span class="n">source</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="o">...</span><span class="p">],</span> <span class="n">destination</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="o">...</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Array</span><span class="p">:</span>
  <span class="n">source</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">_canonicalize_axis</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">ndim</span><span class="p">(</span><span class="n">a</span><span class="p">))</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">source</span><span class="p">)</span>
  <span class="n">destination</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">_canonicalize_axis</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">ndim</span><span class="p">(</span><span class="n">a</span><span class="p">))</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">destination</span><span class="p">)</span>
  <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">source</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">destination</span><span class="p">):</span>
    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Inconsistent number of elements: </span><span class="si">{}</span><span class="s2"> vs </span><span class="si">{}</span><span class="s2">&quot;</span>
                     <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">source</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">destination</span><span class="p">)))</span>
  <span class="n">perm</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">ndim</span><span class="p">(</span><span class="n">a</span><span class="p">))</span> <span class="k">if</span> <span class="n">i</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">source</span><span class="p">]</span>
  <span class="k">for</span> <span class="n">dest</span><span class="p">,</span> <span class="n">src</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">destination</span><span class="p">,</span> <span class="n">source</span><span class="p">)):</span>
    <span class="n">perm</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">dest</span><span class="p">,</span> <span class="n">src</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">lax</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">perm</span><span class="p">)</span>


<span class="nd">@util</span><span class="o">.</span><span class="n">_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isclose</span><span class="p">)</span>
<span class="nd">@partial</span><span class="p">(</span><span class="n">jit</span><span class="p">,</span> <span class="n">static_argnames</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;equal_nan&#39;</span><span class="p">,))</span>
<span class="k">def</span> <span class="nf">isclose</span><span class="p">(</span><span class="n">a</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">,</span> <span class="n">rtol</span><span class="p">:</span> <span class="n">ArrayLike</span> <span class="o">=</span> <span class="mf">1e-05</span><span class="p">,</span> <span class="n">atol</span><span class="p">:</span> <span class="n">ArrayLike</span> <span class="o">=</span> <span class="mf">1e-08</span><span class="p">,</span>
            <span class="n">equal_nan</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Array</span><span class="p">:</span>
  <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">util</span><span class="o">.</span><span class="n">promote_args</span><span class="p">(</span><span class="s2">&quot;isclose&quot;</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
  <span class="n">dtype</span> <span class="o">=</span> <span class="n">_dtype</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">issubdtype</span><span class="p">(</span><span class="n">dtype</span><span class="p">,</span> <span class="n">inexact</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">issubdtype</span><span class="p">(</span><span class="n">dtype</span><span class="p">,</span> <span class="n">complexfloating</span><span class="p">):</span>
      <span class="n">dtype</span> <span class="o">=</span> <span class="n">util</span><span class="o">.</span><span class="n">_complex_elem_type</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span>
    <span class="n">rtol</span> <span class="o">=</span> <span class="n">lax</span><span class="o">.</span><span class="n">convert_element_type</span><span class="p">(</span><span class="n">rtol</span><span class="p">,</span> <span class="n">dtype</span><span class="p">)</span>
    <span class="n">atol</span> <span class="o">=</span> <span class="n">lax</span><span class="o">.</span><span class="n">convert_element_type</span><span class="p">(</span><span class="n">atol</span><span class="p">,</span> <span class="n">dtype</span><span class="p">)</span>
    <span class="n">out</span> <span class="o">=</span> <span class="n">lax</span><span class="o">.</span><span class="n">le</span><span class="p">(</span>
      <span class="n">lax</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">lax</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)),</span>
      <span class="n">lax</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">atol</span><span class="p">,</span> <span class="n">lax</span><span class="o">.</span><span class="n">mul</span><span class="p">(</span><span class="n">rtol</span><span class="p">,</span> <span class="n">lax</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">b</span><span class="p">))))</span>
    <span class="c1"># This corrects the comparisons for infinite and nan values</span>
    <span class="n">a_inf</span> <span class="o">=</span> <span class="n">ufuncs</span><span class="o">.</span><span class="n">isinf</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="n">b_inf</span> <span class="o">=</span> <span class="n">ufuncs</span><span class="o">.</span><span class="n">isinf</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
    <span class="n">any_inf</span> <span class="o">=</span> <span class="n">ufuncs</span><span class="o">.</span><span class="n">logical_or</span><span class="p">(</span><span class="n">a_inf</span><span class="p">,</span> <span class="n">b_inf</span><span class="p">)</span>
    <span class="n">both_inf</span> <span class="o">=</span> <span class="n">ufuncs</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">a_inf</span><span class="p">,</span> <span class="n">b_inf</span><span class="p">)</span>
    <span class="c1"># Make all elements where either a or b are infinite to False</span>
    <span class="n">out</span> <span class="o">=</span> <span class="n">ufuncs</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="n">ufuncs</span><span class="o">.</span><span class="n">logical_not</span><span class="p">(</span><span class="n">any_inf</span><span class="p">))</span>
    <span class="c1"># Make all elements where both a or b are the same inf to True</span>
    <span class="n">same_value</span> <span class="o">=</span> <span class="n">lax</span><span class="o">.</span><span class="n">eq</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
    <span class="n">same_inf</span> <span class="o">=</span> <span class="n">ufuncs</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">both_inf</span><span class="p">,</span> <span class="n">same_value</span><span class="p">)</span>
    <span class="n">out</span> <span class="o">=</span> <span class="n">ufuncs</span><span class="o">.</span><span class="n">logical_or</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="n">same_inf</span><span class="p">)</span>

    <span class="c1"># Make all elements where either a or b is NaN to False</span>
    <span class="n">a_nan</span> <span class="o">=</span> <span class="n">ufuncs</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="n">b_nan</span> <span class="o">=</span> <span class="n">ufuncs</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
    <span class="n">any_nan</span> <span class="o">=</span> <span class="n">ufuncs</span><span class="o">.</span><span class="n">logical_or</span><span class="p">(</span><span class="n">a_nan</span><span class="p">,</span> <span class="n">b_nan</span><span class="p">)</span>
    <span class="n">out</span> <span class="o">=</span> <span class="n">ufuncs</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="n">ufuncs</span><span class="o">.</span><span class="n">logical_not</span><span class="p">(</span><span class="n">any_nan</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">equal_nan</span><span class="p">:</span>
      <span class="c1"># Make all elements where both a and b is NaN to True</span>
      <span class="n">both_nan</span> <span class="o">=</span> <span class="n">ufuncs</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">a_nan</span><span class="p">,</span> <span class="n">b_nan</span><span class="p">)</span>
      <span class="n">out</span> <span class="o">=</span> <span class="n">ufuncs</span><span class="o">.</span><span class="n">logical_or</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="n">both_nan</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">out</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">lax</span><span class="o">.</span><span class="n">eq</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_interp</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">,</span> <span class="n">xp</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">,</span> <span class="n">fp</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">,</span>
           <span class="n">left</span><span class="p">:</span> <span class="n">ArrayLike</span> <span class="o">|</span> <span class="nb">str</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
           <span class="n">right</span><span class="p">:</span> <span class="n">ArrayLike</span> <span class="o">|</span> <span class="nb">str</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
           <span class="n">period</span><span class="p">:</span> <span class="n">ArrayLike</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Array</span><span class="p">:</span>
  <span class="n">util</span><span class="o">.</span><span class="n">check_arraylike</span><span class="p">(</span><span class="s2">&quot;interp&quot;</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">xp</span><span class="p">,</span> <span class="n">fp</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">shape</span><span class="p">(</span><span class="n">xp</span><span class="p">)</span> <span class="o">!=</span> <span class="n">shape</span><span class="p">(</span><span class="n">fp</span><span class="p">)</span> <span class="ow">or</span> <span class="n">ndim</span><span class="p">(</span><span class="n">xp</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;xp and fp must be one-dimensional arrays of equal size&quot;</span><span class="p">)</span>
  <span class="n">x_arr</span><span class="p">,</span> <span class="n">xp_arr</span> <span class="o">=</span> <span class="n">util</span><span class="o">.</span><span class="n">promote_dtypes_inexact</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">xp</span><span class="p">)</span>
  <span class="n">fp_arr</span><span class="p">,</span> <span class="o">=</span> <span class="n">util</span><span class="o">.</span><span class="n">promote_dtypes_inexact</span><span class="p">(</span><span class="n">fp</span><span class="p">)</span>
  <span class="k">del</span> <span class="n">x</span><span class="p">,</span> <span class="n">xp</span><span class="p">,</span> <span class="n">fp</span>

  <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">left</span> <span class="o">!=</span> <span class="s1">&#39;extrapolate&#39;</span><span class="p">:</span>
      <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;the only valid string value of `left` is &quot;</span>
                       <span class="sa">f</span><span class="s2">&quot;&#39;extrapolate&#39;, but got: </span><span class="si">{</span><span class="n">left</span><span class="si">!r}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="n">extrapolate_left</span> <span class="o">=</span> <span class="kc">True</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="n">extrapolate_left</span> <span class="o">=</span> <span class="kc">False</span>
  <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">right</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">right</span> <span class="o">!=</span> <span class="s1">&#39;extrapolate&#39;</span><span class="p">:</span>
      <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;the only valid string value of `right` is &quot;</span>
                       <span class="sa">f</span><span class="s2">&quot;&#39;extrapolate&#39;, but got: </span><span class="si">{</span><span class="n">right</span><span class="si">!r}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="n">extrapolate_right</span> <span class="o">=</span> <span class="kc">True</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="n">extrapolate_right</span> <span class="o">=</span> <span class="kc">False</span>

  <span class="k">if</span> <span class="n">dtypes</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="n">x_arr</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">complexfloating</span><span class="p">):</span>
    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;jnp.interp: complex x values not supported.&quot;</span><span class="p">)</span>

  <span class="k">if</span> <span class="n">period</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
    <span class="k">if</span> <span class="n">ndim</span><span class="p">(</span><span class="n">period</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
      <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;period must be a scalar; got </span><span class="si">{</span><span class="n">period</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="n">period</span> <span class="o">=</span> <span class="n">ufuncs</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">period</span><span class="p">)</span>
    <span class="n">x_arr</span> <span class="o">=</span> <span class="n">x_arr</span> <span class="o">%</span> <span class="n">period</span>
    <span class="n">xp_arr</span> <span class="o">=</span> <span class="n">xp_arr</span> <span class="o">%</span> <span class="n">period</span>
    <span class="n">xp_arr</span><span class="p">,</span> <span class="n">fp_arr</span> <span class="o">=</span> <span class="n">lax</span><span class="o">.</span><span class="n">sort_key_val</span><span class="p">(</span><span class="n">xp_arr</span><span class="p">,</span> <span class="n">fp_arr</span><span class="p">)</span>
    <span class="n">xp_arr</span> <span class="o">=</span> <span class="n">concatenate</span><span class="p">([</span><span class="n">xp_arr</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">:]</span> <span class="o">-</span> <span class="n">period</span><span class="p">,</span> <span class="n">xp_arr</span><span class="p">,</span> <span class="n">xp_arr</span><span class="p">[:</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">period</span><span class="p">])</span>
    <span class="n">fp_arr</span> <span class="o">=</span> <span class="n">concatenate</span><span class="p">([</span><span class="n">fp_arr</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">:],</span> <span class="n">fp_arr</span><span class="p">,</span> <span class="n">fp_arr</span><span class="p">[:</span><span class="mi">1</span><span class="p">]])</span>

  <span class="n">i</span> <span class="o">=</span> <span class="n">clip</span><span class="p">(</span><span class="n">searchsorted</span><span class="p">(</span><span class="n">xp_arr</span><span class="p">,</span> <span class="n">x_arr</span><span class="p">,</span> <span class="n">side</span><span class="o">=</span><span class="s1">&#39;right&#39;</span><span class="p">),</span> <span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">xp_arr</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
  <span class="n">df</span> <span class="o">=</span> <span class="n">fp_arr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">fp_arr</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
  <span class="n">dx</span> <span class="o">=</span> <span class="n">xp_arr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">xp_arr</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
  <span class="n">delta</span> <span class="o">=</span> <span class="n">x_arr</span> <span class="o">-</span> <span class="n">xp_arr</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>

  <span class="n">epsilon</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">spacing</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">finfo</span><span class="p">(</span><span class="n">xp_arr</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span><span class="o">.</span><span class="n">eps</span><span class="p">)</span>
  <span class="n">dx0</span> <span class="o">=</span> <span class="n">lax</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">dx</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">epsilon</span>  <span class="c1"># Prevent NaN gradients when `dx` is small.</span>
  <span class="n">f</span> <span class="o">=</span> <span class="n">where</span><span class="p">(</span><span class="n">dx0</span><span class="p">,</span> <span class="n">fp_arr</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">],</span> <span class="n">fp_arr</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="n">delta</span> <span class="o">/</span> <span class="n">where</span><span class="p">(</span><span class="n">dx0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">dx</span><span class="p">))</span> <span class="o">*</span> <span class="n">df</span><span class="p">)</span>

  <span class="k">if</span> <span class="ow">not</span> <span class="n">extrapolate_left</span><span class="p">:</span>
    <span class="k">assert</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span>
    <span class="n">left_arr</span><span class="p">:</span> <span class="n">ArrayLike</span> <span class="o">=</span> <span class="n">fp_arr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">if</span> <span class="n">left</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">left</span>
    <span class="k">if</span> <span class="n">period</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
      <span class="n">f</span> <span class="o">=</span> <span class="n">where</span><span class="p">(</span><span class="n">x_arr</span> <span class="o">&lt;</span> <span class="n">xp_arr</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">left_arr</span><span class="p">,</span> <span class="n">f</span><span class="p">)</span>
  <span class="k">if</span> <span class="ow">not</span> <span class="n">extrapolate_right</span><span class="p">:</span>
    <span class="k">assert</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">right</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span>
    <span class="n">right_arr</span><span class="p">:</span> <span class="n">ArrayLike</span> <span class="o">=</span> <span class="n">fp_arr</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="k">if</span> <span class="n">right</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">right</span>
    <span class="k">if</span> <span class="n">period</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
      <span class="n">f</span> <span class="o">=</span> <span class="n">where</span><span class="p">(</span><span class="n">x_arr</span> <span class="o">&gt;</span> <span class="n">xp_arr</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">right_arr</span><span class="p">,</span> <span class="n">f</span><span class="p">)</span>

  <span class="k">return</span> <span class="n">f</span>


<span class="nd">@util</span><span class="o">.</span><span class="n">_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">interp</span><span class="p">,</span>
  <span class="n">lax_description</span><span class="o">=</span><span class="n">_dedent</span><span class="p">(</span><span class="s2">&quot;&quot;&quot;</span>
<span class="s2">    In addition to constant interpolation supported by NumPy, jnp.interp also</span>
<span class="s2">    supports left=&#39;extrapolate&#39; and right=&#39;extrapolate&#39; to indicate linear</span>
<span class="s2">    extrapolation instead.&quot;&quot;&quot;</span><span class="p">))</span>
<span class="k">def</span> <span class="nf">interp</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">,</span> <span class="n">xp</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">,</span> <span class="n">fp</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">,</span>
           <span class="n">left</span><span class="p">:</span> <span class="n">ArrayLike</span> <span class="o">|</span> <span class="nb">str</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
           <span class="n">right</span><span class="p">:</span> <span class="n">ArrayLike</span> <span class="o">|</span> <span class="nb">str</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
           <span class="n">period</span><span class="p">:</span> <span class="n">ArrayLike</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Array</span><span class="p">:</span>
  <span class="n">static_argnames</span> <span class="o">=</span> <span class="p">[]</span>
  <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="ow">or</span> <span class="n">left</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
    <span class="n">static_argnames</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;left&#39;</span><span class="p">)</span>
  <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">right</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="ow">or</span> <span class="n">right</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
    <span class="n">static_argnames</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;right&#39;</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">period</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
    <span class="n">static_argnames</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;period&#39;</span><span class="p">)</span>
  <span class="n">jitted_interp</span> <span class="o">=</span> <span class="n">jit</span><span class="p">(</span><span class="n">_interp</span><span class="p">,</span> <span class="n">static_argnames</span><span class="o">=</span><span class="n">static_argnames</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">jitted_interp</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">xp</span><span class="p">,</span> <span class="n">fp</span><span class="p">,</span> <span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">,</span> <span class="n">period</span><span class="p">)</span>


<span class="nd">@overload</span>
<span class="k">def</span> <span class="nf">where</span><span class="p">(</span><span class="n">condition</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span>
          <span class="n">size</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
          <span class="n">fill_value</span><span class="p">:</span> <span class="kc">None</span> <span class="o">|</span> <span class="n">ArrayLike</span> <span class="o">|</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">ArrayLike</span><span class="p">,</span> <span class="o">...</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
          <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">Array</span><span class="p">,</span> <span class="o">...</span><span class="p">]:</span> <span class="o">...</span>

<span class="nd">@overload</span>
<span class="k">def</span> <span class="nf">where</span><span class="p">(</span><span class="n">condition</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span>
          <span class="n">size</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
          <span class="n">fill_value</span><span class="p">:</span> <span class="kc">None</span> <span class="o">|</span> <span class="n">ArrayLike</span> <span class="o">|</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">ArrayLike</span><span class="p">,</span> <span class="o">...</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
          <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Array</span><span class="p">:</span> <span class="o">...</span>

<span class="nd">@overload</span>
<span class="k">def</span> <span class="nf">where</span><span class="p">(</span><span class="n">condition</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="n">ArrayLike</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
          <span class="n">y</span><span class="p">:</span> <span class="n">ArrayLike</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">size</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
          <span class="n">fill_value</span><span class="p">:</span> <span class="kc">None</span> <span class="o">|</span> <span class="n">ArrayLike</span> <span class="o">|</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">ArrayLike</span><span class="p">,</span> <span class="o">...</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
          <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Array</span> <span class="o">|</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">Array</span><span class="p">,</span> <span class="o">...</span><span class="p">]:</span> <span class="o">...</span>

<span class="nd">@util</span><span class="o">.</span><span class="n">_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">,</span>
  <span class="n">lax_description</span><span class="o">=</span><span class="n">_dedent</span><span class="p">(</span><span class="s2">&quot;&quot;&quot;</span>
<span class="s2">    At present, JAX does not support JIT-compilation of the single-argument form</span>
<span class="s2">    of :py:func:`jax.numpy.where` because its output shape is data-dependent. The</span>
<span class="s2">    three-argument form does not have a data-dependent shape and can be JIT-compiled</span>
<span class="s2">    successfully. Alternatively, you can use the optional ``size`` keyword to</span>
<span class="s2">    statically specify the expected size of the output.</span><span class="se">\n\n</span>

<span class="s2">    Special care is needed when the ``x`` or ``y`` input to</span>
<span class="s2">    :py:func:`jax.numpy.where` could have a value of NaN.</span>
<span class="s2">    Specifically, when a gradient is taken</span>
<span class="s2">    with :py:func:`jax.grad` (reverse-mode differentiation), a NaN in either</span>
<span class="s2">    ``x`` or ``y`` will propagate into the gradient, regardless of the value</span>
<span class="s2">    of ``condition``.  More information on this behavior and workarounds</span>
<span class="s2">    is available in the JAX FAQ:</span>
<span class="s2">    https://jax.readthedocs.io/en/latest/faq.html#gradients-contain-nan-where-using-where&quot;&quot;&quot;</span><span class="p">),</span>
  <span class="n">extra_params</span><span class="o">=</span><span class="n">_dedent</span><span class="p">(</span><span class="s2">&quot;&quot;&quot;</span>
<span class="s2">    size : int, optional</span>
<span class="s2">        Only referenced when ``x`` and ``y`` are ``None``. If specified, the indices of the first</span>
<span class="s2">        ``size`` elements of the result will be returned. If there are fewer elements than ``size``</span>
<span class="s2">        indicates, the return value will be padded with ``fill_value``.</span>
<span class="s2">    fill_value : array_like, optional</span>
<span class="s2">        When ``size`` is specified and there are fewer than the indicated number of elements, the</span>
<span class="s2">        remaining elements will be filled with ``fill_value``, which defaults to zero.&quot;&quot;&quot;</span><span class="p">))</span>
<span class="k">def</span> <span class="nf">where</span><span class="p">(</span><span class="n">condition</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="n">ArrayLike</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
          <span class="n">y</span><span class="p">:</span> <span class="n">ArrayLike</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">size</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
          <span class="n">fill_value</span><span class="p">:</span> <span class="kc">None</span> <span class="o">|</span> <span class="n">ArrayLike</span> <span class="o">|</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">ArrayLike</span><span class="p">,</span> <span class="o">...</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Array</span> <span class="o">|</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">Array</span><span class="p">,</span> <span class="o">...</span><span class="p">]:</span>
  <span class="k">if</span> <span class="n">x</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">y</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
    <span class="n">util</span><span class="o">.</span><span class="n">check_arraylike</span><span class="p">(</span><span class="s2">&quot;where&quot;</span><span class="p">,</span> <span class="n">condition</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">nonzero</span><span class="p">(</span><span class="n">condition</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="n">size</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="n">fill_value</span><span class="p">)</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="n">util</span><span class="o">.</span><span class="n">check_arraylike</span><span class="p">(</span><span class="s2">&quot;where&quot;</span><span class="p">,</span> <span class="n">condition</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">size</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">fill_value</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
      <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;size and fill_value arguments cannot be used in three-term where function.&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">util</span><span class="o">.</span><span class="n">_where</span><span class="p">(</span><span class="n">condition</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>


<span class="nd">@util</span><span class="o">.</span><span class="n">_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">select</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">select</span><span class="p">(</span>
    <span class="n">condlist</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">ArrayLike</span><span class="p">],</span>
    <span class="n">choicelist</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">ArrayLike</span><span class="p">],</span>
    <span class="n">default</span><span class="p">:</span> <span class="n">ArrayLike</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Array</span><span class="p">:</span>
  <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">condlist</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">choicelist</span><span class="p">):</span>
    <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;condlist must have length equal to choicelist (</span><span class="si">{}</span><span class="s2"> vs </span><span class="si">{}</span><span class="s2">)&quot;</span>
    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">condlist</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">choicelist</span><span class="p">)))</span>
  <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">condlist</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;condlist must be non-empty&quot;</span><span class="p">)</span>
  <span class="n">choices</span> <span class="o">=</span> <span class="n">util</span><span class="o">.</span><span class="n">promote_dtypes</span><span class="p">(</span><span class="n">default</span><span class="p">,</span> <span class="o">*</span><span class="n">choicelist</span><span class="p">)</span>
  <span class="n">choicelist</span> <span class="o">=</span> <span class="n">choices</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
  <span class="n">output</span> <span class="o">=</span> <span class="n">choices</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
  <span class="k">for</span> <span class="n">cond</span><span class="p">,</span> <span class="n">choice</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">condlist</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">choicelist</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]):</span>
    <span class="n">output</span> <span class="o">=</span> <span class="n">where</span><span class="p">(</span><span class="n">cond</span><span class="p">,</span> <span class="n">choice</span><span class="p">,</span> <span class="n">output</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">output</span>


<span class="nd">@util</span><span class="o">.</span><span class="n">_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">bincount</span><span class="p">,</span> <span class="n">lax_description</span><span class="o">=</span><span class="s2">&quot;&quot;&quot;</span><span class="se">\</span>
<span class="s2">Jax adds the optional `length` parameter which specifies the output length, and</span>
<span class="s2">defaults to ``x.max() + 1``. It must be specified for bincount to be compiled</span>
<span class="s2">with non-static operands. Values larger than the specified length will be discarded.</span>
<span class="s2">If `length` is specified, `minlength` will be ignored.</span>

<span class="s2">Additionally, while ``np.bincount`` raises an error if the input array contains</span>
<span class="s2">negative values, ``jax.numpy.bincount`` clips negative values to zero.</span>
<span class="s2">&quot;&quot;&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">bincount</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">,</span> <span class="n">weights</span><span class="p">:</span> <span class="n">ArrayLike</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
             <span class="n">minlength</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">length</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Array</span><span class="p">:</span>
  <span class="n">util</span><span class="o">.</span><span class="n">check_arraylike</span><span class="p">(</span><span class="s2">&quot;bincount&quot;</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
  <span class="k">if</span> <span class="ow">not</span> <span class="n">issubdtype</span><span class="p">(</span><span class="n">_dtype</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">integer</span><span class="p">):</span>
    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;x argument to bincount must have an integer type; got </span><span class="si">{</span><span class="n">_dtype</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">ndim</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;only 1-dimensional input supported.&quot;</span><span class="p">)</span>
  <span class="n">minlength</span> <span class="o">=</span> <span class="n">core</span><span class="o">.</span><span class="n">concrete_or_error</span><span class="p">(</span><span class="n">operator</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">minlength</span><span class="p">,</span>
      <span class="s2">&quot;The error occurred because of argument &#39;minlength&#39; of jnp.bincount.&quot;</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">length</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
    <span class="n">x_arr</span> <span class="o">=</span> <span class="n">core</span><span class="o">.</span><span class="n">concrete_or_error</span><span class="p">(</span><span class="n">asarray</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span>
      <span class="s2">&quot;The error occurred because of argument &#39;x&#39; of jnp.bincount. &quot;</span>
      <span class="s2">&quot;To avoid this error, pass a static `length` argument.&quot;</span><span class="p">)</span>
    <span class="n">length</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">minlength</span><span class="p">,</span> <span class="n">x_arr</span><span class="o">.</span><span class="n">size</span> <span class="ow">and</span> <span class="nb">int</span><span class="p">(</span><span class="n">x_arr</span><span class="o">.</span><span class="n">max</span><span class="p">())</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="n">length</span> <span class="o">=</span> <span class="n">core</span><span class="o">.</span><span class="n">concrete_dim_or_error</span><span class="p">(</span><span class="n">length</span><span class="p">,</span>
        <span class="s2">&quot;The error occurred because of argument &#39;length&#39; of jnp.bincount.&quot;</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">weights</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
    <span class="n">weights</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">int_</span><span class="p">)</span>
  <span class="k">elif</span> <span class="n">shape</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">!=</span> <span class="n">shape</span><span class="p">(</span><span class="n">weights</span><span class="p">):</span>
    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;shape of weights must match shape of x.&quot;</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">zeros</span><span class="p">(</span><span class="n">length</span><span class="p">,</span> <span class="n">_dtype</span><span class="p">(</span><span class="n">weights</span><span class="p">))</span><span class="o">.</span><span class="n">at</span><span class="p">[</span><span class="n">clip</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">0</span><span class="p">)]</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">weights</span><span class="p">)</span>

<span class="nd">@overload</span>
<span class="k">def</span> <span class="nf">broadcast_shapes</span><span class="p">(</span><span class="o">*</span><span class="n">shapes</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="o">...</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="o">...</span><span class="p">]:</span> <span class="o">...</span>

<span class="nd">@overload</span>
<span class="k">def</span> <span class="nf">broadcast_shapes</span><span class="p">(</span><span class="o">*</span><span class="n">shapes</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span> <span class="o">|</span> <span class="n">core</span><span class="o">.</span><span class="n">Tracer</span><span class="p">,</span> <span class="o">...</span><span class="p">]</span>
                     <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span> <span class="o">|</span> <span class="n">core</span><span class="o">.</span><span class="n">Tracer</span><span class="p">,</span> <span class="o">...</span><span class="p">]:</span> <span class="o">...</span>

<span class="nd">@util</span><span class="o">.</span><span class="n">_wraps</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="s2">&quot;broadcast_shapes&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">))</span>
<span class="k">def</span> <span class="nf">broadcast_shapes</span><span class="p">(</span><span class="o">*</span><span class="n">shapes</span><span class="p">):</span>
  <span class="k">if</span> <span class="ow">not</span> <span class="n">shapes</span><span class="p">:</span>
    <span class="k">return</span> <span class="p">()</span>
  <span class="n">shapes</span> <span class="o">=</span> <span class="p">[(</span><span class="n">shape</span><span class="p">,)</span> <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">ndim</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="k">else</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span> <span class="k">for</span> <span class="n">shape</span> <span class="ow">in</span> <span class="n">shapes</span><span class="p">]</span>
  <span class="k">return</span> <span class="n">lax</span><span class="o">.</span><span class="n">broadcast_shapes</span><span class="p">(</span><span class="o">*</span><span class="n">shapes</span><span class="p">)</span>


<span class="nd">@util</span><span class="o">.</span><span class="n">_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">broadcast_arrays</span><span class="p">,</span> <span class="n">lax_description</span><span class="o">=</span><span class="s2">&quot;&quot;&quot;</span><span class="se">\</span>
<span class="s2">The JAX version does not necessarily return a view of the input.</span>
<span class="s2">&quot;&quot;&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">broadcast_arrays</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="n">Array</span><span class="p">]:</span>
  <span class="k">return</span> <span class="n">util</span><span class="o">.</span><span class="n">_broadcast_arrays</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>


<span class="nd">@util</span><span class="o">.</span><span class="n">_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">broadcast_to</span><span class="p">,</span> <span class="n">lax_description</span><span class="o">=</span><span class="s2">&quot;&quot;&quot;</span><span class="se">\</span>
<span class="s2">The JAX version does not necessarily return a view of the input.</span>
<span class="s2">&quot;&quot;&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">broadcast_to</span><span class="p">(</span><span class="n">array</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">,</span> <span class="n">shape</span><span class="p">:</span> <span class="n">Shape</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Array</span><span class="p">:</span>
  <span class="k">return</span> <span class="n">util</span><span class="o">.</span><span class="n">_broadcast_to</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">shape</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_split</span><span class="p">(</span><span class="n">op</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">ary</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">,</span>
           <span class="n">indices_or_sections</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">|</span> <span class="n">ArrayLike</span><span class="p">,</span>
           <span class="n">axis</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="n">Array</span><span class="p">]:</span>
  <span class="n">util</span><span class="o">.</span><span class="n">check_arraylike</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="n">ary</span><span class="p">)</span>
  <span class="n">ary</span> <span class="o">=</span> <span class="n">asarray</span><span class="p">(</span><span class="n">ary</span><span class="p">)</span>
  <span class="n">axis</span> <span class="o">=</span> <span class="n">core</span><span class="o">.</span><span class="n">concrete_or_error</span><span class="p">(</span><span class="n">operator</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;in jax.numpy.</span><span class="si">{</span><span class="n">op</span><span class="si">}</span><span class="s2"> argument `axis`&quot;</span><span class="p">)</span>
  <span class="n">size</span> <span class="o">=</span> <span class="n">ary</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span>
  <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">indices_or_sections</span><span class="p">,</span> <span class="p">(</span><span class="nb">tuple</span><span class="p">,</span> <span class="nb">list</span><span class="p">)):</span>
    <span class="n">indices_or_sections</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
        <span class="p">[</span><span class="n">core</span><span class="o">.</span><span class="n">concrete_or_error</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">,</span> <span class="n">i_s</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;in jax.numpy.</span><span class="si">{</span><span class="n">op</span><span class="si">}</span><span class="s2"> argument 1&quot;</span><span class="p">)</span>
         <span class="k">for</span> <span class="n">i_s</span> <span class="ow">in</span> <span class="n">indices_or_sections</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">)</span>
    <span class="n">split_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([[</span><span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">(</span><span class="mi">0</span><span class="p">)],</span> <span class="n">indices_or_sections</span><span class="p">,</span>
                                    <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">(</span><span class="n">size</span><span class="p">)]])</span>
  <span class="k">elif</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">indices_or_sections</span><span class="p">,</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">Array</span><span class="p">))</span> <span class="ow">and</span>
        <span class="n">indices_or_sections</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">):</span>
    <span class="n">indices_or_sections</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
        <span class="p">[</span><span class="n">core</span><span class="o">.</span><span class="n">concrete_or_error</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">,</span> <span class="n">i_s</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;in jax.numpy.</span><span class="si">{</span><span class="n">op</span><span class="si">}</span><span class="s2"> argument 1&quot;</span><span class="p">)</span>
         <span class="k">for</span> <span class="n">i_s</span> <span class="ow">in</span> <span class="n">indices_or_sections</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">)</span>
    <span class="n">split_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([[</span><span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">(</span><span class="mi">0</span><span class="p">)],</span> <span class="n">indices_or_sections</span><span class="p">,</span>
                                    <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">(</span><span class="n">size</span><span class="p">)]])</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="n">num_sections</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="n">core</span><span class="o">.</span><span class="n">concrete_or_error</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="n">indices_or_sections</span><span class="p">,</span>
                                               <span class="sa">f</span><span class="s2">&quot;in jax.numpy.</span><span class="si">{</span><span class="n">op</span><span class="si">}</span><span class="s2"> argument 1&quot;</span><span class="p">)</span>
    <span class="n">part_size</span><span class="p">,</span> <span class="n">r</span> <span class="o">=</span> <span class="nb">divmod</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">num_sections</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">r</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
      <span class="n">split_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">*</span> <span class="n">part_size</span>
                                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_sections</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)])</span>
    <span class="k">elif</span> <span class="n">op</span> <span class="o">==</span> <span class="s2">&quot;array_split&quot;</span><span class="p">:</span>
      <span class="n">split_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
        <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">part_size</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">r</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)]</span> <span class="o">+</span>
        <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">*</span> <span class="n">part_size</span> <span class="o">+</span> <span class="p">((</span><span class="n">r</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">part_size</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
         <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_sections</span> <span class="o">-</span> <span class="n">r</span><span class="p">)])</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;array split does not result in an equal division&quot;</span><span class="p">)</span>
  <span class="n">starts</span><span class="p">,</span> <span class="n">ends</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">ndim</span><span class="p">(</span><span class="n">ary</span><span class="p">),</span> <span class="n">shape</span><span class="p">(</span><span class="n">ary</span><span class="p">)</span>
  <span class="n">_subval</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">v</span><span class="p">:</span> <span class="n">subvals</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="p">[(</span><span class="n">i</span><span class="p">,</span> <span class="n">v</span><span class="p">)])</span>
  <span class="k">return</span> <span class="p">[</span><span class="n">lax</span><span class="o">.</span><span class="n">slice</span><span class="p">(</span><span class="n">ary</span><span class="p">,</span> <span class="n">_subval</span><span class="p">(</span><span class="n">starts</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="n">start</span><span class="p">),</span> <span class="n">_subval</span><span class="p">(</span><span class="n">ends</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="n">end</span><span class="p">))</span>
          <span class="k">for</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">split_indices</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">split_indices</span><span class="p">[</span><span class="mi">1</span><span class="p">:])]</span>

<span class="nd">@util</span><span class="o">.</span><span class="n">_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">split</span><span class="p">,</span> <span class="n">lax_description</span><span class="o">=</span><span class="n">_ARRAY_VIEW_DOC</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">split</span><span class="p">(</span><span class="n">ary</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">,</span> <span class="n">indices_or_sections</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">|</span> <span class="n">ArrayLike</span><span class="p">,</span>
          <span class="n">axis</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="n">Array</span><span class="p">]:</span>
  <span class="k">return</span> <span class="n">_split</span><span class="p">(</span><span class="s2">&quot;split&quot;</span><span class="p">,</span> <span class="n">ary</span><span class="p">,</span> <span class="n">indices_or_sections</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">_split_on_axis</span><span class="p">(</span><span class="n">op</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">axis</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">ArrayLike</span><span class="p">,</span> <span class="nb">int</span> <span class="o">|</span> <span class="n">ArrayLike</span><span class="p">],</span> <span class="nb">list</span><span class="p">[</span><span class="n">Array</span><span class="p">]]:</span>
  <span class="nd">@util</span><span class="o">.</span><span class="n">_wraps</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">op</span><span class="p">),</span> <span class="n">update_doc</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
  <span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">ary</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">,</span> <span class="n">indices_or_sections</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">|</span> <span class="n">ArrayLike</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="n">Array</span><span class="p">]:</span>
    <span class="c1"># for 1-D array, hsplit becomes vsplit</span>
    <span class="k">nonlocal</span> <span class="n">axis</span>
    <span class="n">util</span><span class="o">.</span><span class="n">check_arraylike</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="n">ary</span><span class="p">)</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">asarray</span><span class="p">(</span><span class="n">ary</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">axis</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
      <span class="n">axis</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">return</span> <span class="n">_split</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="n">ary</span><span class="p">,</span> <span class="n">indices_or_sections</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">f</span>

<span class="n">vsplit</span> <span class="o">=</span> <span class="n">_split_on_axis</span><span class="p">(</span><span class="s2">&quot;vsplit&quot;</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="n">hsplit</span> <span class="o">=</span> <span class="n">_split_on_axis</span><span class="p">(</span><span class="s2">&quot;hsplit&quot;</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="n">dsplit</span> <span class="o">=</span> <span class="n">_split_on_axis</span><span class="p">(</span><span class="s2">&quot;dsplit&quot;</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>

<span class="nd">@util</span><span class="o">.</span><span class="n">_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array_split</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">array_split</span><span class="p">(</span><span class="n">ary</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">,</span> <span class="n">indices_or_sections</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">|</span> <span class="n">ArrayLike</span><span class="p">,</span>
                <span class="n">axis</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="n">Array</span><span class="p">]:</span>
  <span class="k">return</span> <span class="n">_split</span><span class="p">(</span><span class="s2">&quot;array_split&quot;</span><span class="p">,</span> <span class="n">ary</span><span class="p">,</span> <span class="n">indices_or_sections</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>

<span class="nd">@util</span><span class="o">.</span><span class="n">_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">,</span> <span class="n">skip_params</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;out&#39;</span><span class="p">])</span>
<span class="nd">@jit</span>
<span class="k">def</span> <span class="nf">clip</span><span class="p">(</span><span class="n">a</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">,</span> <span class="n">a_min</span><span class="p">:</span> <span class="n">ArrayLike</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
         <span class="n">a_max</span><span class="p">:</span> <span class="n">ArrayLike</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">out</span><span class="p">:</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Array</span><span class="p">:</span>
  <span class="n">util</span><span class="o">.</span><span class="n">check_arraylike</span><span class="p">(</span><span class="s2">&quot;clip&quot;</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">out</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
    <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;The &#39;out&#39; argument to jnp.clip is not supported.&quot;</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">a_min</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">a_max</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;At most one of a_min and a_max may be None&quot;</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">a_min</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">ufuncs</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">a_min</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">a_max</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">ufuncs</span><span class="o">.</span><span class="n">minimum</span><span class="p">(</span><span class="n">a_max</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">asarray</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>

<span class="nd">@util</span><span class="o">.</span><span class="n">_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">around</span><span class="p">,</span> <span class="n">skip_params</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;out&#39;</span><span class="p">])</span>
<span class="nd">@partial</span><span class="p">(</span><span class="n">jit</span><span class="p">,</span> <span class="n">static_argnames</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;decimals&#39;</span><span class="p">,))</span>
<span class="k">def</span> <span class="nf">round</span><span class="p">(</span><span class="n">a</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">,</span> <span class="n">decimals</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">out</span><span class="p">:</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Array</span><span class="p">:</span>
  <span class="n">util</span><span class="o">.</span><span class="n">check_arraylike</span><span class="p">(</span><span class="s2">&quot;round&quot;</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
  <span class="n">decimals</span> <span class="o">=</span> <span class="n">core</span><span class="o">.</span><span class="n">concrete_or_error</span><span class="p">(</span><span class="n">operator</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">decimals</span><span class="p">,</span> <span class="s2">&quot;&#39;decimals&#39; argument of jnp.round&quot;</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">out</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
    <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;The &#39;out&#39; argument to jnp.round is not supported.&quot;</span><span class="p">)</span>
  <span class="n">dtype</span> <span class="o">=</span> <span class="n">_dtype</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">issubdtype</span><span class="p">(</span><span class="n">dtype</span><span class="p">,</span> <span class="n">integer</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">decimals</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
      <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
        <span class="s2">&quot;integer np.round not implemented for decimals &lt; 0&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">asarray</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>  <span class="c1"># no-op on integer types</span>

  <span class="k">def</span> <span class="nf">_round_float</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Array</span><span class="p">:</span>
    <span class="k">if</span> <span class="n">decimals</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
      <span class="k">return</span> <span class="n">lax</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">lax</span><span class="o">.</span><span class="n">RoundingMethod</span><span class="o">.</span><span class="n">TO_NEAREST_EVEN</span><span class="p">)</span>

    <span class="c1"># TODO(phawkins): the strategy of rescaling the value isn&#39;t necessarily a</span>
    <span class="c1"># good one since we may be left with an incorrectly rounded value at the</span>
    <span class="c1"># end due to precision problems. As a workaround for float16, convert to</span>
    <span class="c1"># float32,</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">lax</span><span class="o">.</span><span class="n">convert_element_type</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span> <span class="k">if</span> <span class="n">dtype</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">float16</span> <span class="k">else</span> <span class="n">x</span>
    <span class="n">factor</span> <span class="o">=</span> <span class="n">_lax_const</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">10</span> <span class="o">**</span> <span class="n">decimals</span><span class="p">)</span>
    <span class="n">out</span> <span class="o">=</span> <span class="n">lax</span><span class="o">.</span><span class="n">div</span><span class="p">(</span><span class="n">lax</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">lax</span><span class="o">.</span><span class="n">mul</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">factor</span><span class="p">),</span>
                            <span class="n">lax</span><span class="o">.</span><span class="n">RoundingMethod</span><span class="o">.</span><span class="n">TO_NEAREST_EVEN</span><span class="p">),</span> <span class="n">factor</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">lax</span><span class="o">.</span><span class="n">convert_element_type</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="n">dtype</span><span class="p">)</span> <span class="k">if</span> <span class="n">dtype</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">float16</span> <span class="k">else</span> <span class="n">out</span>

  <span class="k">if</span> <span class="n">issubdtype</span><span class="p">(</span><span class="n">dtype</span><span class="p">,</span> <span class="n">complexfloating</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">lax</span><span class="o">.</span><span class="n">complex</span><span class="p">(</span><span class="n">_round_float</span><span class="p">(</span><span class="n">lax</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">a</span><span class="p">)),</span> <span class="n">_round_float</span><span class="p">(</span><span class="n">lax</span><span class="o">.</span><span class="n">imag</span><span class="p">(</span><span class="n">a</span><span class="p">)))</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">_round_float</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="n">around</span> <span class="o">=</span> <span class="nb">round</span>
<span class="n">round_</span> <span class="o">=</span> <span class="nb">round</span>


<span class="nd">@util</span><span class="o">.</span><span class="n">_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">fix</span><span class="p">,</span> <span class="n">skip_params</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;out&#39;</span><span class="p">])</span>
<span class="nd">@jit</span>
<span class="k">def</span> <span class="nf">fix</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">,</span> <span class="n">out</span><span class="p">:</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Array</span><span class="p">:</span>
  <span class="n">util</span><span class="o">.</span><span class="n">check_arraylike</span><span class="p">(</span><span class="s2">&quot;fix&quot;</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">out</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
    <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;The &#39;out&#39; argument to jnp.fix is not supported.&quot;</span><span class="p">)</span>
  <span class="n">zero</span> <span class="o">=</span> <span class="n">_lax_const</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">where</span><span class="p">(</span><span class="n">lax</span><span class="o">.</span><span class="n">ge</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">zero</span><span class="p">),</span> <span class="n">ufuncs</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">ufuncs</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>


<span class="nd">@util</span><span class="o">.</span><span class="n">_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nan_to_num</span><span class="p">)</span>
<span class="nd">@jit</span>
<span class="k">def</span> <span class="nf">nan_to_num</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">,</span> <span class="n">copy</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">nan</span><span class="p">:</span> <span class="n">ArrayLike</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">,</span>
               <span class="n">posinf</span><span class="p">:</span> <span class="n">ArrayLike</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
               <span class="n">neginf</span><span class="p">:</span> <span class="n">ArrayLike</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Array</span><span class="p">:</span>
  <span class="k">del</span> <span class="n">copy</span>
  <span class="n">util</span><span class="o">.</span><span class="n">check_arraylike</span><span class="p">(</span><span class="s2">&quot;nan_to_num&quot;</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
  <span class="n">dtype</span> <span class="o">=</span> <span class="n">_dtype</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
  <span class="k">if</span> <span class="ow">not</span> <span class="n">issubdtype</span><span class="p">(</span><span class="n">dtype</span><span class="p">,</span> <span class="n">inexact</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">asarray</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">issubdtype</span><span class="p">(</span><span class="n">dtype</span><span class="p">,</span> <span class="n">complexfloating</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">lax</span><span class="o">.</span><span class="n">complex</span><span class="p">(</span>
      <span class="n">nan_to_num</span><span class="p">(</span><span class="n">lax</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">nan</span><span class="o">=</span><span class="n">nan</span><span class="p">,</span> <span class="n">posinf</span><span class="o">=</span><span class="n">posinf</span><span class="p">,</span> <span class="n">neginf</span><span class="o">=</span><span class="n">neginf</span><span class="p">),</span>
      <span class="n">nan_to_num</span><span class="p">(</span><span class="n">lax</span><span class="o">.</span><span class="n">imag</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">nan</span><span class="o">=</span><span class="n">nan</span><span class="p">,</span> <span class="n">posinf</span><span class="o">=</span><span class="n">posinf</span><span class="p">,</span> <span class="n">neginf</span><span class="o">=</span><span class="n">neginf</span><span class="p">))</span>
  <span class="n">info</span> <span class="o">=</span> <span class="n">finfo</span><span class="p">(</span><span class="n">dtypes</span><span class="o">.</span><span class="n">canonicalize_dtype</span><span class="p">(</span><span class="n">dtype</span><span class="p">))</span>
  <span class="n">posinf</span> <span class="o">=</span> <span class="n">info</span><span class="o">.</span><span class="n">max</span> <span class="k">if</span> <span class="n">posinf</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">posinf</span>
  <span class="n">neginf</span> <span class="o">=</span> <span class="n">info</span><span class="o">.</span><span class="n">min</span> <span class="k">if</span> <span class="n">neginf</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">neginf</span>
  <span class="n">out</span> <span class="o">=</span> <span class="n">where</span><span class="p">(</span><span class="n">ufuncs</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">asarray</span><span class="p">(</span><span class="n">nan</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">),</span> <span class="n">x</span><span class="p">)</span>
  <span class="n">out</span> <span class="o">=</span> <span class="n">where</span><span class="p">(</span><span class="n">ufuncs</span><span class="o">.</span><span class="n">isposinf</span><span class="p">(</span><span class="n">out</span><span class="p">),</span> <span class="n">asarray</span><span class="p">(</span><span class="n">posinf</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">),</span> <span class="n">out</span><span class="p">)</span>
  <span class="n">out</span> <span class="o">=</span> <span class="n">where</span><span class="p">(</span><span class="n">ufuncs</span><span class="o">.</span><span class="n">isneginf</span><span class="p">(</span><span class="n">out</span><span class="p">),</span> <span class="n">asarray</span><span class="p">(</span><span class="n">neginf</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">),</span> <span class="n">out</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">out</span>


<span class="nd">@util</span><span class="o">.</span><span class="n">_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">)</span>
<span class="nd">@partial</span><span class="p">(</span><span class="n">jit</span><span class="p">,</span> <span class="n">static_argnames</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;equal_nan&#39;</span><span class="p">,))</span>
<span class="k">def</span> <span class="nf">allclose</span><span class="p">(</span><span class="n">a</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">,</span> <span class="n">rtol</span><span class="p">:</span> <span class="n">ArrayLike</span> <span class="o">=</span> <span class="mf">1e-05</span><span class="p">,</span>
             <span class="n">atol</span><span class="p">:</span> <span class="n">ArrayLike</span> <span class="o">=</span> <span class="mf">1e-08</span><span class="p">,</span> <span class="n">equal_nan</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Array</span><span class="p">:</span>
  <span class="n">util</span><span class="o">.</span><span class="n">check_arraylike</span><span class="p">(</span><span class="s2">&quot;allclose&quot;</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">reductions</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">isclose</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">rtol</span><span class="p">,</span> <span class="n">atol</span><span class="p">,</span> <span class="n">equal_nan</span><span class="p">))</span>


<span class="n">_NONZERO_DOC</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span><span class="se">\</span>
<span class="s2">Because the size of the output of ``nonzero`` is data-dependent, the function is not</span>
<span class="s2">typically compatible with JIT. The JAX version adds the optional ``size`` argument which</span>
<span class="s2">must be specified statically for ``jnp.nonzero`` to be used within some of JAX&#39;s</span>
<span class="s2">transformations.</span>
<span class="s2">&quot;&quot;&quot;</span>
<span class="n">_NONZERO_EXTRA_PARAMS</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span>
<span class="s2">size : int, optional</span>
<span class="s2">    If specified, the indices of the first ``size`` True elements will be returned. If there are</span>
<span class="s2">    fewer unique elements than ``size`` indicates, the return value will be padded with ``fill_value``.</span>
<span class="s2">fill_value : array_like, optional</span>
<span class="s2">    When ``size`` is specified and there are fewer than the indicated number of elements, the</span>
<span class="s2">    remaining elements will be filled with ``fill_value``, which defaults to zero.</span>
<span class="s2">&quot;&quot;&quot;</span>

<span class="nd">@util</span><span class="o">.</span><span class="n">_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">,</span> <span class="n">lax_description</span><span class="o">=</span><span class="n">_NONZERO_DOC</span><span class="p">,</span> <span class="n">extra_params</span><span class="o">=</span><span class="n">_NONZERO_EXTRA_PARAMS</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">nonzero</span><span class="p">(</span><span class="n">a</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">size</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
            <span class="n">fill_value</span><span class="p">:</span> <span class="kc">None</span> <span class="o">|</span> <span class="n">ArrayLike</span> <span class="o">|</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">ArrayLike</span><span class="p">,</span> <span class="o">...</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">Array</span><span class="p">,</span> <span class="o">...</span><span class="p">]:</span>
  <span class="n">util</span><span class="o">.</span><span class="n">check_arraylike</span><span class="p">(</span><span class="s2">&quot;nonzero&quot;</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
  <span class="n">arr</span> <span class="o">=</span> <span class="n">atleast_1d</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
  <span class="k">del</span> <span class="n">a</span>
  <span class="n">mask</span> <span class="o">=</span> <span class="n">arr</span> <span class="k">if</span> <span class="n">arr</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="nb">bool</span> <span class="k">else</span> <span class="p">(</span><span class="n">arr</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">size</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
    <span class="n">size</span> <span class="o">=</span> <span class="n">mask</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
  <span class="n">size</span> <span class="o">=</span> <span class="n">core</span><span class="o">.</span><span class="n">concrete_dim_or_error</span><span class="p">(</span><span class="n">size</span><span class="p">,</span>
    <span class="s2">&quot;The size argument of jnp.nonzero must be statically specified &quot;</span>
    <span class="s2">&quot;to use jnp.nonzero within JAX transformations.&quot;</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">arr</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
    <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">zeros</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span> <span class="k">for</span> <span class="n">dim</span> <span class="ow">in</span> <span class="n">arr</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
  <span class="n">flat_indices</span> <span class="o">=</span> <span class="n">reductions</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">bincount</span><span class="p">(</span><span class="n">reductions</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">mask</span><span class="p">),</span> <span class="n">length</span><span class="o">=</span><span class="n">size</span><span class="p">))</span>
  <span class="n">strides</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">cumprod</span><span class="p">(</span><span class="n">arr</span><span class="o">.</span><span class="n">shape</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">])[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">//</span> <span class="n">arr</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">int_</span><span class="p">)</span>
  <span class="n">out</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">((</span><span class="n">flat_indices</span> <span class="o">//</span> <span class="n">stride</span><span class="p">)</span> <span class="o">%</span> <span class="n">size</span> <span class="k">for</span> <span class="n">stride</span><span class="p">,</span> <span class="n">size</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">strides</span><span class="p">,</span> <span class="n">arr</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>
  <span class="k">if</span> <span class="n">size</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">fill_value</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
    <span class="n">fill_value_tup</span> <span class="o">=</span> <span class="n">fill_value</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">fill_value</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)</span> <span class="k">else</span> <span class="n">arr</span><span class="o">.</span><span class="n">ndim</span> <span class="o">*</span> <span class="p">(</span><span class="n">fill_value</span><span class="p">,)</span>
    <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">_shape</span><span class="p">(</span><span class="n">val</span><span class="p">)</span> <span class="o">!=</span> <span class="p">()</span> <span class="k">for</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">fill_value_tup</span><span class="p">):</span>
      <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;fill_value must be a scalar or a tuple of length </span><span class="si">{</span><span class="n">arr</span><span class="o">.</span><span class="n">ndim</span><span class="si">}</span><span class="s2">; got </span><span class="si">{</span><span class="n">fill_value</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="n">fill_mask</span> <span class="o">=</span> <span class="n">arange</span><span class="p">(</span><span class="n">size</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">mask</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
    <span class="n">out</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">where</span><span class="p">(</span><span class="n">fill_mask</span><span class="p">,</span> <span class="n">fval</span><span class="p">,</span> <span class="n">entry</span><span class="p">)</span> <span class="k">for</span> <span class="n">fval</span><span class="p">,</span> <span class="n">entry</span> <span class="ow">in</span> <span class="n">safe_zip</span><span class="p">(</span><span class="n">fill_value_tup</span><span class="p">,</span> <span class="n">out</span><span class="p">))</span>
  <span class="k">return</span> <span class="n">out</span>

<span class="nd">@util</span><span class="o">.</span><span class="n">_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">flatnonzero</span><span class="p">,</span> <span class="n">lax_description</span><span class="o">=</span><span class="n">_NONZERO_DOC</span><span class="p">,</span> <span class="n">extra_params</span><span class="o">=</span><span class="n">_NONZERO_EXTRA_PARAMS</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">flatnonzero</span><span class="p">(</span><span class="n">a</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">size</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                <span class="n">fill_value</span><span class="p">:</span> <span class="kc">None</span> <span class="o">|</span> <span class="n">ArrayLike</span> <span class="o">|</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">ArrayLike</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Array</span><span class="p">:</span>
  <span class="k">return</span> <span class="n">nonzero</span><span class="p">(</span><span class="n">ravel</span><span class="p">(</span><span class="n">a</span><span class="p">),</span> <span class="n">size</span><span class="o">=</span><span class="n">size</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="n">fill_value</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>


<span class="nd">@util</span><span class="o">.</span><span class="n">_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">unwrap</span><span class="p">)</span>
<span class="nd">@partial</span><span class="p">(</span><span class="n">jit</span><span class="p">,</span> <span class="n">static_argnames</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;axis&#39;</span><span class="p">,))</span>
<span class="k">def</span> <span class="nf">unwrap</span><span class="p">(</span><span class="n">p</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">,</span> <span class="n">discont</span><span class="p">:</span> <span class="n">ArrayLike</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
           <span class="n">axis</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">period</span><span class="p">:</span> <span class="n">ArrayLike</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">pi</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Array</span><span class="p">:</span>
  <span class="n">util</span><span class="o">.</span><span class="n">check_arraylike</span><span class="p">(</span><span class="s2">&quot;unwrap&quot;</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span>
  <span class="n">p</span> <span class="o">=</span> <span class="n">asarray</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">issubdtype</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">complexfloating</span><span class="p">):</span>
    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;jnp.unwrap does not support complex inputs.&quot;</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">p</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">util</span><span class="o">.</span><span class="n">promote_dtypes_inexact</span><span class="p">(</span><span class="n">p</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
  <span class="k">if</span> <span class="n">discont</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
    <span class="n">discont</span> <span class="o">=</span> <span class="n">period</span> <span class="o">/</span> <span class="mi">2</span>
  <span class="n">interval</span> <span class="o">=</span> <span class="n">period</span> <span class="o">/</span> <span class="mi">2</span>
  <span class="n">dd</span> <span class="o">=</span> <span class="n">diff</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>
  <span class="n">ddmod</span> <span class="o">=</span> <span class="n">ufuncs</span><span class="o">.</span><span class="n">mod</span><span class="p">(</span><span class="n">dd</span> <span class="o">+</span> <span class="n">interval</span><span class="p">,</span> <span class="n">period</span><span class="p">)</span> <span class="o">-</span> <span class="n">interval</span>
  <span class="n">ddmod</span> <span class="o">=</span> <span class="n">where</span><span class="p">((</span><span class="n">ddmod</span> <span class="o">==</span> <span class="o">-</span><span class="n">interval</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">dd</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">),</span> <span class="n">interval</span><span class="p">,</span> <span class="n">ddmod</span><span class="p">)</span>

  <span class="n">ph_correct</span> <span class="o">=</span> <span class="n">where</span><span class="p">(</span><span class="n">ufuncs</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">dd</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">discont</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">ddmod</span> <span class="o">-</span> <span class="n">dd</span><span class="p">)</span>

  <span class="n">up</span> <span class="o">=</span> <span class="n">concatenate</span><span class="p">((</span>
    <span class="n">lax</span><span class="o">.</span><span class="n">slice_in_dim</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">),</span>
    <span class="n">lax</span><span class="o">.</span><span class="n">slice_in_dim</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span> <span class="o">+</span> <span class="n">reductions</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">ph_correct</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>
  <span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>

  <span class="k">return</span> <span class="n">up</span>


<span class="c1">### Padding</span>

<span class="n">PadValueLike</span> <span class="o">=</span> <span class="n">Union</span><span class="p">[</span><span class="n">T</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">T</span><span class="p">],</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="n">T</span><span class="p">]]]</span>
<span class="n">PadValue</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="n">T</span><span class="p">,</span> <span class="n">T</span><span class="p">],</span> <span class="o">...</span><span class="p">]</span>

<span class="k">class</span> <span class="nc">PadStatFunc</span><span class="p">(</span><span class="n">Protocol</span><span class="p">):</span>
  <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">array</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">,</span> <span class="o">/</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span>
               <span class="n">axis</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
               <span class="n">keepdims</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Array</span><span class="p">:</span> <span class="o">...</span>


<span class="k">def</span> <span class="nf">_broadcast_to_pairs</span><span class="p">(</span><span class="n">nvals</span><span class="p">:</span> <span class="n">PadValueLike</span><span class="p">,</span> <span class="n">nd</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">PadValue</span><span class="p">:</span>
  <span class="k">try</span><span class="p">:</span>
    <span class="n">nvals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">tree_map</span><span class="p">(</span>
      <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">core</span><span class="o">.</span><span class="n">concrete_or_error</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">context</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2"> argument of jnp.pad&quot;</span><span class="p">),</span>
      <span class="n">nvals</span><span class="p">))</span>
  <span class="k">except</span> <span class="ne">ValueError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
    <span class="c1"># In numpy 1.24</span>
    <span class="k">if</span> <span class="s2">&quot;array has an inhomogeneous shape&quot;</span> <span class="ow">in</span> <span class="nb">str</span><span class="p">(</span><span class="n">e</span><span class="p">):</span>
      <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;`</span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s1">` entries must be the same shape: </span><span class="si">{</span><span class="n">nvals</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span> <span class="kn">from</span> <span class="nn">e</span>
    <span class="k">raise</span>

  <span class="k">def</span> <span class="nf">as_scalar_dim</span><span class="p">(</span><span class="n">v</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">core</span><span class="o">.</span><span class="n">is_dim</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">v</span><span class="p">):</span>
      <span class="k">return</span> <span class="n">v</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;`</span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s1">` entries must be the same shape: </span><span class="si">{</span><span class="n">nvals</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>

  <span class="k">if</span> <span class="n">nvals</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">(</span><span class="n">nd</span><span class="p">,</span> <span class="mi">2</span><span class="p">):</span>
    <span class="c1"># ((before_1, after_1), ..., (before_N, after_N))</span>
    <span class="k">return</span> <span class="nb">tuple</span><span class="p">((</span><span class="n">as_scalar_dim</span><span class="p">(</span><span class="n">nval</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">as_scalar_dim</span><span class="p">(</span><span class="n">nval</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span> <span class="k">for</span> <span class="n">nval</span> <span class="ow">in</span> <span class="n">nvals</span><span class="p">)</span>
  <span class="k">elif</span> <span class="n">nvals</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">):</span>
    <span class="c1"># ((before, after),)</span>
    <span class="n">v1_2</span> <span class="o">=</span> <span class="n">as_scalar_dim</span><span class="p">(</span><span class="n">nvals</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]),</span> <span class="n">as_scalar_dim</span><span class="p">(</span><span class="n">nvals</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
    <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">v1_2</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nd</span><span class="p">))</span>
  <span class="k">elif</span> <span class="n">nvals</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">(</span><span class="mi">2</span><span class="p">,):</span>
    <span class="c1"># (before, after)  (not in the numpy docstring but works anyway)</span>
    <span class="n">v1_2</span> <span class="o">=</span> <span class="n">as_scalar_dim</span><span class="p">(</span><span class="n">nvals</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">as_scalar_dim</span><span class="p">(</span><span class="n">nvals</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
    <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">v1_2</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nd</span><span class="p">))</span>
  <span class="k">elif</span> <span class="n">nvals</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">(</span><span class="mi">1</span><span class="p">,):</span>
    <span class="c1"># (pad,)</span>
    <span class="n">v</span> <span class="o">=</span> <span class="n">as_scalar_dim</span><span class="p">(</span><span class="n">nvals</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="k">return</span> <span class="nb">tuple</span><span class="p">((</span><span class="n">v</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nd</span><span class="p">))</span>
  <span class="k">elif</span> <span class="n">nvals</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">():</span>
    <span class="c1"># pad</span>
    <span class="n">v</span> <span class="o">=</span> <span class="n">as_scalar_dim</span><span class="p">(</span><span class="n">nvals</span><span class="o">.</span><span class="n">flat</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="k">return</span> <span class="nb">tuple</span><span class="p">((</span><span class="n">v</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nd</span><span class="p">))</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;jnp.pad: </span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2"> with </span><span class="si">{</span><span class="n">nd</span><span class="si">=}</span><span class="s2"> has unsupported shape </span><span class="si">{</span><span class="n">nvals</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2">. &quot;</span>
                     <span class="sa">f</span><span class="s2">&quot;Valid shapes are (</span><span class="si">{</span><span class="n">nd</span><span class="si">}</span><span class="s2">, 2), (1, 2), (2,), (1,), or ().&quot;</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_check_no_padding</span><span class="p">(</span><span class="n">axis_padding</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">Any</span><span class="p">,</span> <span class="n">Any</span><span class="p">],</span> <span class="n">mode</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">axis_padding</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">axis_padding</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">):</span>
    <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;Cannot apply &#39;</span><span class="si">{}</span><span class="s2">&#39; padding to empty axis&quot;</span>
    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">mode</span><span class="p">))</span>


<span class="k">def</span> <span class="nf">_pad_constant</span><span class="p">(</span><span class="n">array</span><span class="p">:</span> <span class="n">Array</span><span class="p">,</span> <span class="n">pad_width</span><span class="p">:</span> <span class="n">PadValue</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">constant_values</span><span class="p">:</span> <span class="n">Array</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Array</span><span class="p">:</span>
  <span class="n">nd</span> <span class="o">=</span> <span class="n">ndim</span><span class="p">(</span><span class="n">array</span><span class="p">)</span>
  <span class="n">constant_values</span> <span class="o">=</span> <span class="n">broadcast_to</span><span class="p">(</span><span class="n">constant_values</span><span class="p">,</span> <span class="p">(</span><span class="n">nd</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
  <span class="n">constant_values</span> <span class="o">=</span> <span class="n">lax_internal</span><span class="o">.</span><span class="n">_convert_element_type</span><span class="p">(</span>
      <span class="n">constant_values</span><span class="p">,</span> <span class="n">array</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">dtypes</span><span class="o">.</span><span class="n">is_weakly_typed</span><span class="p">(</span><span class="n">array</span><span class="p">))</span>
  <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nd</span><span class="p">):</span>
    <span class="n">widths</span> <span class="o">=</span> <span class="p">[(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)]</span> <span class="o">*</span> <span class="n">nd</span>
    <span class="n">widths</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">pad_width</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">array</span> <span class="o">=</span> <span class="n">lax</span><span class="o">.</span><span class="n">pad</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">constant_values</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">widths</span><span class="p">)</span>
    <span class="n">widths</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">pad_width</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">array</span> <span class="o">=</span> <span class="n">lax</span><span class="o">.</span><span class="n">pad</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">constant_values</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">widths</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">array</span>


<span class="k">def</span> <span class="nf">_pad_wrap</span><span class="p">(</span><span class="n">array</span><span class="p">:</span> <span class="n">Array</span><span class="p">,</span> <span class="n">pad_width</span><span class="p">:</span> <span class="n">PadValue</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Array</span><span class="p">:</span>
  <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">ndim</span><span class="p">(</span><span class="n">array</span><span class="p">)):</span>
    <span class="k">if</span> <span class="n">array</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
      <span class="n">_check_no_padding</span><span class="p">(</span><span class="n">pad_width</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="s2">&quot;wrap&quot;</span><span class="p">)</span>
      <span class="k">continue</span>
    <span class="n">size</span> <span class="o">=</span> <span class="n">array</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
    <span class="n">repeats</span><span class="p">,</span> <span class="p">(</span><span class="n">left_remainder</span><span class="p">,</span> <span class="n">right_remainder</span><span class="p">)</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">divmod</span><span class="p">(</span><span class="n">pad_width</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">size</span><span class="p">)</span>
    <span class="n">total_repeats</span> <span class="o">=</span> <span class="n">repeats</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="n">parts</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">if</span> <span class="n">left_remainder</span><span class="p">:</span>
      <span class="n">parts</span> <span class="o">+=</span> <span class="p">[</span><span class="n">lax</span><span class="o">.</span><span class="n">slice_in_dim</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">size</span> <span class="o">-</span> <span class="n">left_remainder</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">i</span><span class="p">)]</span>
    <span class="n">parts</span> <span class="o">+=</span> <span class="n">total_repeats</span> <span class="o">*</span> <span class="p">[</span><span class="n">array</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">right_remainder</span><span class="p">:</span>
      <span class="n">parts</span> <span class="o">+=</span> <span class="p">[</span><span class="n">lax</span><span class="o">.</span><span class="n">slice_in_dim</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">right_remainder</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">i</span><span class="p">)]</span>
    <span class="n">array</span> <span class="o">=</span> <span class="n">lax</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">parts</span><span class="p">,</span> <span class="n">dimension</span><span class="o">=</span><span class="n">i</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">array</span>


<span class="k">def</span> <span class="nf">_pad_symmetric_or_reflect</span><span class="p">(</span><span class="n">array</span><span class="p">:</span> <span class="n">Array</span><span class="p">,</span> <span class="n">pad_width</span><span class="p">:</span> <span class="n">PadValue</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span>
                              <span class="n">mode</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">reflect_type</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Array</span><span class="p">:</span>
  <span class="k">assert</span> <span class="n">mode</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;symmetric&quot;</span><span class="p">,</span> <span class="s2">&quot;reflect&quot;</span><span class="p">)</span>
  <span class="k">assert</span> <span class="n">reflect_type</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;even&quot;</span><span class="p">,</span> <span class="s2">&quot;odd&quot;</span><span class="p">)</span>

  <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">ndim</span><span class="p">(</span><span class="n">array</span><span class="p">)):</span>
    <span class="k">if</span> <span class="n">array</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
      <span class="n">_check_no_padding</span><span class="p">(</span><span class="n">pad_width</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">mode</span><span class="p">)</span>
      <span class="k">continue</span>

    <span class="n">n</span> <span class="o">=</span> <span class="n">array</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
    <span class="n">offset</span> <span class="o">=</span> <span class="mi">1</span> <span class="k">if</span> <span class="p">(</span><span class="n">mode</span> <span class="o">==</span> <span class="s2">&quot;reflect&quot;</span> <span class="ow">and</span> <span class="n">n</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="k">else</span> <span class="mi">0</span>

    <span class="k">def</span> <span class="nf">build_padding</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">padding</span><span class="p">,</span> <span class="n">before</span><span class="p">):</span>
      <span class="k">if</span> <span class="n">before</span><span class="p">:</span>
        <span class="n">edge</span> <span class="o">=</span> <span class="n">lax</span><span class="o">.</span><span class="n">slice_in_dim</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">i</span><span class="p">)</span>
      <span class="k">else</span><span class="p">:</span>
        <span class="n">edge</span> <span class="o">=</span> <span class="n">lax</span><span class="o">.</span><span class="n">slice_in_dim</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">i</span><span class="p">)</span>

      <span class="k">while</span> <span class="n">padding</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">curr_pad</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">padding</span><span class="p">,</span> <span class="n">n</span> <span class="o">-</span> <span class="n">offset</span><span class="p">)</span>
        <span class="n">padding</span> <span class="o">-=</span> <span class="n">curr_pad</span>

        <span class="k">if</span> <span class="n">before</span><span class="p">:</span>
          <span class="n">start</span> <span class="o">=</span> <span class="n">offset</span>
          <span class="n">stop</span> <span class="o">=</span> <span class="n">offset</span> <span class="o">+</span> <span class="n">curr_pad</span>
        <span class="k">else</span><span class="p">:</span>
          <span class="n">start</span> <span class="o">=</span> <span class="o">-</span><span class="p">(</span><span class="n">curr_pad</span> <span class="o">+</span> <span class="n">offset</span><span class="p">)</span>
          <span class="n">stop</span> <span class="o">=</span> <span class="kc">None</span> <span class="k">if</span> <span class="p">(</span><span class="n">mode</span> <span class="o">==</span> <span class="s2">&quot;symmetric&quot;</span> <span class="ow">or</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="k">else</span> <span class="o">-</span><span class="mi">1</span>

        <span class="n">x</span> <span class="o">=</span> <span class="n">lax</span><span class="o">.</span><span class="n">slice_in_dim</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">i</span><span class="p">)</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">flip</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">i</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">reflect_type</span> <span class="o">==</span> <span class="s1">&#39;odd&#39;</span><span class="p">:</span>
          <span class="n">x</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">edge</span> <span class="o">-</span> <span class="n">x</span>
          <span class="k">if</span> <span class="n">n</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">before</span><span class="p">:</span>
              <span class="n">edge</span> <span class="o">=</span> <span class="n">lax</span><span class="o">.</span><span class="n">slice_in_dim</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">i</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
              <span class="n">edge</span> <span class="o">=</span> <span class="n">lax</span><span class="o">.</span><span class="n">slice_in_dim</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">i</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">before</span><span class="p">:</span>
          <span class="n">array</span> <span class="o">=</span> <span class="n">lax</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">x</span><span class="p">,</span> <span class="n">array</span><span class="p">],</span> <span class="n">dimension</span><span class="o">=</span><span class="n">i</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
          <span class="n">array</span> <span class="o">=</span> <span class="n">lax</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">array</span><span class="p">,</span> <span class="n">x</span><span class="p">],</span> <span class="n">dimension</span><span class="o">=</span><span class="n">i</span><span class="p">)</span>
      <span class="k">return</span> <span class="n">array</span>

    <span class="n">array</span> <span class="o">=</span> <span class="n">build_padding</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">pad_width</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">before</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">array</span> <span class="o">=</span> <span class="n">build_padding</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">pad_width</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span> <span class="n">before</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">array</span>


<span class="k">def</span> <span class="nf">_pad_edge</span><span class="p">(</span><span class="n">array</span><span class="p">:</span> <span class="n">Array</span><span class="p">,</span> <span class="n">pad_width</span><span class="p">:</span> <span class="n">PadValue</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Array</span><span class="p">:</span>
  <span class="n">nd</span> <span class="o">=</span> <span class="n">ndim</span><span class="p">(</span><span class="n">array</span><span class="p">)</span>
  <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nd</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">array</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
      <span class="n">_check_no_padding</span><span class="p">(</span><span class="n">pad_width</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="s2">&quot;edge&quot;</span><span class="p">)</span>
      <span class="k">continue</span>

    <span class="n">n</span> <span class="o">=</span> <span class="n">array</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
    <span class="n">npad_before</span><span class="p">,</span> <span class="n">npad_after</span> <span class="o">=</span> <span class="n">pad_width</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

    <span class="n">edge_before</span> <span class="o">=</span> <span class="n">lax</span><span class="o">.</span><span class="n">slice_in_dim</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">i</span><span class="p">)</span>
    <span class="n">pad_before</span> <span class="o">=</span> <span class="n">repeat</span><span class="p">(</span><span class="n">edge_before</span><span class="p">,</span> <span class="n">npad_before</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">i</span><span class="p">)</span>

    <span class="n">edge_after</span> <span class="o">=</span> <span class="n">lax</span><span class="o">.</span><span class="n">slice_in_dim</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">i</span><span class="p">)</span>
    <span class="n">pad_after</span> <span class="o">=</span> <span class="n">repeat</span><span class="p">(</span><span class="n">edge_after</span><span class="p">,</span> <span class="n">npad_after</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">i</span><span class="p">)</span>

    <span class="n">array</span> <span class="o">=</span> <span class="n">lax</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">pad_before</span><span class="p">,</span> <span class="n">array</span><span class="p">,</span> <span class="n">pad_after</span><span class="p">],</span> <span class="n">dimension</span><span class="o">=</span><span class="n">i</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">array</span>


<span class="k">def</span> <span class="nf">_pad_linear_ramp</span><span class="p">(</span><span class="n">array</span><span class="p">:</span> <span class="n">Array</span><span class="p">,</span> <span class="n">pad_width</span><span class="p">:</span> <span class="n">PadValue</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span>
                     <span class="n">end_values</span><span class="p">:</span> <span class="n">PadValue</span><span class="p">[</span><span class="n">ArrayLike</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Array</span><span class="p">:</span>
  <span class="k">for</span> <span class="n">axis</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">ndim</span><span class="p">(</span><span class="n">array</span><span class="p">)):</span>
    <span class="n">edge_before</span> <span class="o">=</span> <span class="n">lax</span><span class="o">.</span><span class="n">slice_in_dim</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>
    <span class="n">edge_after</span> <span class="o">=</span> <span class="n">lax</span><span class="o">.</span><span class="n">slice_in_dim</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>
    <span class="n">ramp_before</span> <span class="o">=</span> <span class="n">linspace</span><span class="p">(</span>
        <span class="n">start</span><span class="o">=</span><span class="n">end_values</span><span class="p">[</span><span class="n">axis</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span>
        <span class="n">stop</span><span class="o">=</span><span class="n">edge_before</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">axis</span><span class="p">),</span> <span class="c1"># Dimension is replaced by linspace</span>
        <span class="n">num</span><span class="o">=</span><span class="n">pad_width</span><span class="p">[</span><span class="n">axis</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span>
        <span class="n">endpoint</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">dtype</span><span class="o">=</span><span class="n">array</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span>
        <span class="n">axis</span><span class="o">=</span><span class="n">axis</span>
    <span class="p">)</span>
    <span class="n">ramp_before</span> <span class="o">=</span> <span class="n">lax_internal</span><span class="o">.</span><span class="n">_convert_element_type</span><span class="p">(</span>
        <span class="n">ramp_before</span><span class="p">,</span> <span class="n">weak_type</span><span class="o">=</span><span class="n">dtypes</span><span class="o">.</span><span class="n">is_weakly_typed</span><span class="p">(</span><span class="n">array</span><span class="p">))</span>
    <span class="n">ramp_after</span> <span class="o">=</span> <span class="n">linspace</span><span class="p">(</span>
        <span class="n">start</span><span class="o">=</span><span class="n">end_values</span><span class="p">[</span><span class="n">axis</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span>
        <span class="n">stop</span><span class="o">=</span><span class="n">edge_after</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">axis</span><span class="p">),</span> <span class="c1"># Dimension is replaced by linspace</span>
        <span class="n">num</span><span class="o">=</span><span class="n">pad_width</span><span class="p">[</span><span class="n">axis</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span>
        <span class="n">endpoint</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">dtype</span><span class="o">=</span><span class="n">array</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span>
        <span class="n">axis</span><span class="o">=</span><span class="n">axis</span>
    <span class="p">)</span>
    <span class="n">ramp_after</span> <span class="o">=</span> <span class="n">lax_internal</span><span class="o">.</span><span class="n">_convert_element_type</span><span class="p">(</span>
        <span class="n">ramp_after</span><span class="p">,</span> <span class="n">weak_type</span><span class="o">=</span><span class="n">dtypes</span><span class="o">.</span><span class="n">is_weakly_typed</span><span class="p">(</span><span class="n">array</span><span class="p">))</span>

    <span class="c1"># Reverse linear space in appropriate dimension</span>
    <span class="n">ramp_after</span> <span class="o">=</span> <span class="n">flip</span><span class="p">(</span><span class="n">ramp_after</span><span class="p">,</span> <span class="n">axis</span><span class="p">)</span>

    <span class="n">array</span> <span class="o">=</span> <span class="n">lax</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">ramp_before</span><span class="p">,</span> <span class="n">array</span><span class="p">,</span> <span class="n">ramp_after</span><span class="p">],</span> <span class="n">dimension</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">array</span>


<span class="k">def</span> <span class="nf">_pad_stats</span><span class="p">(</span><span class="n">array</span><span class="p">:</span> <span class="n">Array</span><span class="p">,</span> <span class="n">pad_width</span><span class="p">:</span> <span class="n">PadValue</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span>
               <span class="n">stat_length</span><span class="p">:</span> <span class="n">PadValue</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span><span class="p">,</span>
               <span class="n">stat_func</span><span class="p">:</span> <span class="n">PadStatFunc</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Array</span><span class="p">:</span>
  <span class="n">nd</span> <span class="o">=</span> <span class="n">ndim</span><span class="p">(</span><span class="n">array</span><span class="p">)</span>
  <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nd</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">stat_length</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
      <span class="n">stat_before</span> <span class="o">=</span> <span class="n">stat_func</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">i</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
      <span class="n">stat_after</span> <span class="o">=</span> <span class="n">stat_before</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="n">array_length</span> <span class="o">=</span> <span class="n">array</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
      <span class="n">length_before</span><span class="p">,</span> <span class="n">length_after</span> <span class="o">=</span> <span class="n">stat_length</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
      <span class="k">if</span> <span class="n">length_before</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">length_after</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;stat_length of 0 yields no value for padding&quot;</span><span class="p">)</span>

      <span class="c1"># Limit stat_length to length of array.</span>
      <span class="n">length_before</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">length_before</span><span class="p">,</span> <span class="n">array_length</span><span class="p">)</span>
      <span class="n">length_after</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">length_after</span><span class="p">,</span> <span class="n">array_length</span><span class="p">)</span>

      <span class="n">slice_before</span> <span class="o">=</span> <span class="n">lax</span><span class="o">.</span><span class="n">slice_in_dim</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">length_before</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">i</span><span class="p">)</span>
      <span class="n">slice_after</span> <span class="o">=</span> <span class="n">lax</span><span class="o">.</span><span class="n">slice_in_dim</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="o">-</span><span class="n">length_after</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">i</span><span class="p">)</span>
      <span class="n">stat_before</span> <span class="o">=</span> <span class="n">stat_func</span><span class="p">(</span><span class="n">slice_before</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">i</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
      <span class="n">stat_after</span> <span class="o">=</span> <span class="n">stat_func</span><span class="p">(</span><span class="n">slice_after</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">i</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="n">array</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">integer</span><span class="p">):</span>
      <span class="n">stat_before</span> <span class="o">=</span> <span class="nb">round</span><span class="p">(</span><span class="n">stat_before</span><span class="p">)</span>
      <span class="n">stat_after</span> <span class="o">=</span> <span class="nb">round</span><span class="p">(</span><span class="n">stat_after</span><span class="p">)</span>

    <span class="n">stat_before</span> <span class="o">=</span> <span class="n">lax_internal</span><span class="o">.</span><span class="n">_convert_element_type</span><span class="p">(</span>
        <span class="n">stat_before</span><span class="p">,</span> <span class="n">array</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">dtypes</span><span class="o">.</span><span class="n">is_weakly_typed</span><span class="p">(</span><span class="n">array</span><span class="p">))</span>
    <span class="n">stat_after</span> <span class="o">=</span> <span class="n">lax_internal</span><span class="o">.</span><span class="n">_convert_element_type</span><span class="p">(</span>
        <span class="n">stat_after</span><span class="p">,</span> <span class="n">array</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">dtypes</span><span class="o">.</span><span class="n">is_weakly_typed</span><span class="p">(</span><span class="n">array</span><span class="p">))</span>

    <span class="n">npad_before</span><span class="p">,</span> <span class="n">npad_after</span> <span class="o">=</span> <span class="n">pad_width</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
    <span class="n">pad_before</span> <span class="o">=</span> <span class="n">repeat</span><span class="p">(</span><span class="n">stat_before</span><span class="p">,</span> <span class="n">npad_before</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">i</span><span class="p">)</span>
    <span class="n">pad_after</span> <span class="o">=</span> <span class="n">repeat</span><span class="p">(</span><span class="n">stat_after</span><span class="p">,</span> <span class="n">npad_after</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">i</span><span class="p">)</span>

    <span class="n">array</span> <span class="o">=</span> <span class="n">lax</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">pad_before</span><span class="p">,</span> <span class="n">array</span><span class="p">,</span> <span class="n">pad_after</span><span class="p">],</span> <span class="n">dimension</span><span class="o">=</span><span class="n">i</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">array</span>


<span class="k">def</span> <span class="nf">_pad_empty</span><span class="p">(</span><span class="n">array</span><span class="p">:</span> <span class="n">Array</span><span class="p">,</span> <span class="n">pad_width</span><span class="p">:</span> <span class="n">PadValue</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Array</span><span class="p">:</span>
  <span class="c1"># Note: jax.numpy.empty = jax.numpy.zeros</span>
  <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">ndim</span><span class="p">(</span><span class="n">array</span><span class="p">)):</span>
    <span class="n">shape_before</span> <span class="o">=</span> <span class="n">array</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="n">pad_width</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">],)</span> <span class="o">+</span> <span class="n">array</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:]</span>
    <span class="n">pad_before</span> <span class="o">=</span> <span class="n">empty_like</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="n">shape_before</span><span class="p">)</span>

    <span class="n">shape_after</span> <span class="o">=</span> <span class="n">array</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="n">pad_width</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">],)</span> <span class="o">+</span> <span class="n">array</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:]</span>
    <span class="n">pad_after</span> <span class="o">=</span> <span class="n">empty_like</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="n">shape_after</span><span class="p">)</span>
    <span class="n">array</span> <span class="o">=</span> <span class="n">lax</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">pad_before</span><span class="p">,</span> <span class="n">array</span><span class="p">,</span> <span class="n">pad_after</span><span class="p">],</span> <span class="n">dimension</span><span class="o">=</span><span class="n">i</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">array</span>


<span class="k">def</span> <span class="nf">_pad_func</span><span class="p">(</span><span class="n">array</span><span class="p">:</span> <span class="n">Array</span><span class="p">,</span> <span class="n">pad_width</span><span class="p">:</span> <span class="n">PadValue</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">func</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">Any</span><span class="p">],</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Array</span><span class="p">:</span>
  <span class="n">pad_width</span> <span class="o">=</span> <span class="n">_broadcast_to_pairs</span><span class="p">(</span><span class="n">pad_width</span><span class="p">,</span> <span class="n">ndim</span><span class="p">(</span><span class="n">array</span><span class="p">),</span> <span class="s2">&quot;pad_width&quot;</span><span class="p">)</span>
  <span class="n">padded</span> <span class="o">=</span> <span class="n">_pad_constant</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">pad_width</span><span class="p">,</span> <span class="n">asarray</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>
  <span class="k">for</span> <span class="n">axis</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">ndim</span><span class="p">(</span><span class="n">padded</span><span class="p">)):</span>
    <span class="n">padded</span> <span class="o">=</span> <span class="n">apply_along_axis</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="n">padded</span><span class="p">,</span> <span class="n">pad_width</span><span class="p">[</span><span class="n">axis</span><span class="p">],</span> <span class="n">axis</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">padded</span>


<span class="nd">@partial</span><span class="p">(</span><span class="n">jit</span><span class="p">,</span> <span class="n">static_argnums</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">))</span>
<span class="k">def</span> <span class="nf">_pad</span><span class="p">(</span><span class="n">array</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">,</span> <span class="n">pad_width</span><span class="p">:</span> <span class="n">PadValueLike</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">mode</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
         <span class="n">constant_values</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">,</span> <span class="n">stat_length</span><span class="p">:</span> <span class="n">PadValueLike</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span>
         <span class="n">end_values</span><span class="p">:</span> <span class="n">PadValueLike</span><span class="p">[</span><span class="n">ArrayLike</span><span class="p">],</span> <span class="n">reflect_type</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
  <span class="n">array</span> <span class="o">=</span> <span class="n">asarray</span><span class="p">(</span><span class="n">array</span><span class="p">)</span>
  <span class="n">nd</span> <span class="o">=</span> <span class="n">ndim</span><span class="p">(</span><span class="n">array</span><span class="p">)</span>

  <span class="k">if</span> <span class="n">nd</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">array</span>

  <span class="n">stat_funcs</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">PadStatFunc</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
      <span class="s2">&quot;maximum&quot;</span><span class="p">:</span> <span class="n">reductions</span><span class="o">.</span><span class="n">amax</span><span class="p">,</span>
      <span class="s2">&quot;minimum&quot;</span><span class="p">:</span> <span class="n">reductions</span><span class="o">.</span><span class="n">amin</span><span class="p">,</span>
      <span class="s2">&quot;mean&quot;</span><span class="p">:</span> <span class="n">reductions</span><span class="o">.</span><span class="n">mean</span><span class="p">,</span>
      <span class="s2">&quot;median&quot;</span><span class="p">:</span> <span class="n">reductions</span><span class="o">.</span><span class="n">median</span>
  <span class="p">}</span>

  <span class="n">pad_width</span> <span class="o">=</span> <span class="n">_broadcast_to_pairs</span><span class="p">(</span><span class="n">pad_width</span><span class="p">,</span> <span class="n">nd</span><span class="p">,</span> <span class="s2">&quot;pad_width&quot;</span><span class="p">)</span>
  <span class="n">pad_width_arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">pad_width</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">pad_width_arr</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="p">(</span><span class="n">nd</span><span class="p">,</span> <span class="mi">2</span><span class="p">):</span>
    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Expected pad_width to have shape </span><span class="si">{</span><span class="p">(</span><span class="n">nd</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="si">}</span><span class="s2">; got </span><span class="si">{</span><span class="n">pad_width_arr</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>

  <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">pad_width_arr</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">):</span>
    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;index can&#39;t contain negative values&quot;</span><span class="p">)</span>

  <span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="s2">&quot;constant&quot;</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">_pad_constant</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">pad_width</span><span class="p">,</span> <span class="n">asarray</span><span class="p">(</span><span class="n">constant_values</span><span class="p">))</span>

  <span class="k">elif</span> <span class="n">mode</span> <span class="o">==</span> <span class="s2">&quot;wrap&quot;</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">_pad_wrap</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">pad_width</span><span class="p">)</span>

  <span class="k">elif</span> <span class="n">mode</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;symmetric&quot;</span><span class="p">,</span> <span class="s2">&quot;reflect&quot;</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">_pad_symmetric_or_reflect</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">pad_width</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">mode</span><span class="p">),</span> <span class="n">reflect_type</span><span class="p">)</span>

  <span class="k">elif</span> <span class="n">mode</span> <span class="o">==</span> <span class="s2">&quot;edge&quot;</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">_pad_edge</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">pad_width</span><span class="p">)</span>

  <span class="k">elif</span> <span class="n">mode</span> <span class="o">==</span> <span class="s2">&quot;linear_ramp&quot;</span><span class="p">:</span>
    <span class="n">end_values</span> <span class="o">=</span> <span class="n">_broadcast_to_pairs</span><span class="p">(</span><span class="n">end_values</span><span class="p">,</span> <span class="n">nd</span><span class="p">,</span> <span class="s2">&quot;end_values&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">_pad_linear_ramp</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">pad_width</span><span class="p">,</span> <span class="n">end_values</span><span class="p">)</span>

  <span class="k">elif</span> <span class="n">mode</span> <span class="ow">in</span> <span class="n">stat_funcs</span><span class="p">:</span>
    <span class="k">if</span> <span class="n">stat_length</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
      <span class="n">stat_length</span> <span class="o">=</span> <span class="n">_broadcast_to_pairs</span><span class="p">(</span><span class="n">stat_length</span><span class="p">,</span> <span class="n">nd</span><span class="p">,</span> <span class="s2">&quot;stat_length&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">_pad_stats</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">pad_width</span><span class="p">,</span> <span class="n">stat_length</span><span class="p">,</span> <span class="n">stat_funcs</span><span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">mode</span><span class="p">)])</span>

  <span class="k">elif</span> <span class="n">mode</span> <span class="o">==</span> <span class="s2">&quot;empty&quot;</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">_pad_empty</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">pad_width</span><span class="p">)</span>

  <span class="k">else</span><span class="p">:</span>
    <span class="k">assert</span> <span class="kc">False</span><span class="p">,</span> <span class="p">(</span><span class="s2">&quot;Should not be reached since pad already handled unsupported and&quot;</span>
                   <span class="s2">&quot;not implemented modes&quot;</span><span class="p">)</span>


<span class="nd">@util</span><span class="o">.</span><span class="n">_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pad</span><span class="p">,</span> <span class="n">lax_description</span><span class="o">=</span><span class="s2">&quot;&quot;&quot;</span><span class="se">\</span>
<span class="s2">Unlike numpy, JAX &quot;function&quot; mode&#39;s argument (which is another function) should return</span>
<span class="s2">the modified array. This is because Jax arrays are immutable.</span>
<span class="s2">(In numpy, &quot;function&quot; mode&#39;s argument should modify a rank 1 array in-place.)</span>
<span class="s2">&quot;&quot;&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">pad</span><span class="p">(</span><span class="n">array</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">,</span> <span class="n">pad_width</span><span class="p">:</span> <span class="n">PadValueLike</span><span class="p">[</span><span class="nb">int</span> <span class="o">|</span> <span class="n">Array</span> <span class="o">|</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">],</span>
        <span class="n">mode</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="n">Callable</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">Any</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;constant&quot;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Array</span><span class="p">:</span>
  <span class="n">util</span><span class="o">.</span><span class="n">check_arraylike</span><span class="p">(</span><span class="s2">&quot;pad&quot;</span><span class="p">,</span> <span class="n">array</span><span class="p">)</span>
  <span class="n">pad_width</span> <span class="o">=</span> <span class="n">_broadcast_to_pairs</span><span class="p">(</span><span class="n">pad_width</span><span class="p">,</span> <span class="n">ndim</span><span class="p">(</span><span class="n">array</span><span class="p">),</span> <span class="s2">&quot;pad_width&quot;</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">pad_width</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">(</span><span class="n">core</span><span class="o">.</span><span class="n">is_dim</span><span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="ow">and</span> <span class="n">core</span><span class="o">.</span><span class="n">is_dim</span><span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                           <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">pad_width</span><span class="p">):</span>
    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;`pad_width` must be of integral type.&#39;</span><span class="p">)</span>

  <span class="k">if</span> <span class="nb">callable</span><span class="p">(</span><span class="n">mode</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">_pad_func</span><span class="p">(</span><span class="n">asarray</span><span class="p">(</span><span class="n">array</span><span class="p">),</span> <span class="n">pad_width</span><span class="p">,</span> <span class="n">mode</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

  <span class="n">allowed_kwargs</span> <span class="o">=</span> <span class="p">{</span>
      <span class="s1">&#39;empty&#39;</span><span class="p">:</span> <span class="p">[],</span> <span class="s1">&#39;edge&#39;</span><span class="p">:</span> <span class="p">[],</span> <span class="s1">&#39;wrap&#39;</span><span class="p">:</span> <span class="p">[],</span>
      <span class="s1">&#39;constant&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;constant_values&#39;</span><span class="p">],</span>
      <span class="s1">&#39;linear_ramp&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;end_values&#39;</span><span class="p">],</span>
      <span class="s1">&#39;maximum&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;stat_length&#39;</span><span class="p">],</span>
      <span class="s1">&#39;mean&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;stat_length&#39;</span><span class="p">],</span>
      <span class="s1">&#39;median&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;stat_length&#39;</span><span class="p">],</span>
      <span class="s1">&#39;minimum&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;stat_length&#39;</span><span class="p">],</span>
      <span class="s1">&#39;reflect&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;reflect_type&#39;</span><span class="p">],</span>
      <span class="s1">&#39;symmetric&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;reflect_type&#39;</span><span class="p">],</span>
  <span class="p">}</span>
  <span class="k">try</span><span class="p">:</span>
    <span class="n">unsupported_kwargs</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-</span> <span class="nb">set</span><span class="p">(</span><span class="n">allowed_kwargs</span><span class="p">[</span><span class="n">mode</span><span class="p">])</span>  <span class="c1"># type: ignore[call-overload]</span>
  <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
    <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;Unimplemented padding mode &#39;</span><span class="si">{}</span><span class="s2">&#39; for np.pad.&quot;</span>
    <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="n">msg</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">mode</span><span class="p">))</span>
  <span class="k">if</span> <span class="n">unsupported_kwargs</span><span class="p">:</span>
    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;unsupported keyword arguments for mode &#39;</span><span class="si">{}</span><span class="s2">&#39;: </span><span class="si">{}</span><span class="s2">&quot;</span>
                     <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">mode</span><span class="p">,</span> <span class="n">unsupported_kwargs</span><span class="p">))</span>
  <span class="c1"># Set default value if not given.</span>
  <span class="n">constant_values</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;constant_values&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
  <span class="n">stat_length</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;stat_length&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
  <span class="n">end_values</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;end_values&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
  <span class="n">reflect_type</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;reflect_type&#39;</span><span class="p">,</span> <span class="s2">&quot;even&quot;</span><span class="p">)</span>

  <span class="k">return</span> <span class="n">_pad</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">pad_width</span><span class="p">,</span> <span class="n">mode</span><span class="p">,</span> <span class="n">constant_values</span><span class="p">,</span> <span class="n">stat_length</span><span class="p">,</span> <span class="n">end_values</span><span class="p">,</span> <span class="n">reflect_type</span><span class="p">)</span>

<span class="c1">### Array-creation functions</span>


<span class="nd">@util</span><span class="o">.</span><span class="n">_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">stack</span><span class="p">,</span> <span class="n">skip_params</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;out&#39;</span><span class="p">])</span>
<span class="k">def</span> <span class="nf">stack</span><span class="p">(</span><span class="n">arrays</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">|</span> <span class="n">Array</span> <span class="o">|</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">ArrayLike</span><span class="p">],</span>
          <span class="n">axis</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">out</span><span class="p">:</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">dtype</span><span class="p">:</span> <span class="n">DTypeLike</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Array</span><span class="p">:</span>
  <span class="k">if</span> <span class="ow">not</span> <span class="nb">len</span><span class="p">(</span><span class="n">arrays</span><span class="p">):</span>
    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Need at least one array to stack.&quot;</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">out</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
    <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;The &#39;out&#39; argument to jnp.stack is not supported.&quot;</span><span class="p">)</span>
  <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">arrays</span><span class="p">,</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">Array</span><span class="p">)):</span>
    <span class="n">axis</span> <span class="o">=</span> <span class="n">_canonicalize_axis</span><span class="p">(</span><span class="n">axis</span><span class="p">,</span> <span class="n">arrays</span><span class="o">.</span><span class="n">ndim</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">concatenate</span><span class="p">(</span><span class="n">expand_dims</span><span class="p">(</span><span class="n">arrays</span><span class="p">,</span> <span class="n">axis</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="n">util</span><span class="o">.</span><span class="n">check_arraylike</span><span class="p">(</span><span class="s2">&quot;stack&quot;</span><span class="p">,</span> <span class="o">*</span><span class="n">arrays</span><span class="p">)</span>
    <span class="n">shape0</span> <span class="o">=</span> <span class="n">shape</span><span class="p">(</span><span class="n">arrays</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="n">axis</span> <span class="o">=</span> <span class="n">_canonicalize_axis</span><span class="p">(</span><span class="n">axis</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">shape0</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">new_arrays</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">arrays</span><span class="p">:</span>
      <span class="k">if</span> <span class="n">shape</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">!=</span> <span class="n">shape0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;All input arrays must have the same shape.&quot;</span><span class="p">)</span>
      <span class="n">new_arrays</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">expand_dims</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">concatenate</span><span class="p">(</span><span class="n">new_arrays</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>

<span class="nd">@util</span><span class="o">.</span><span class="n">_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">tile</span><span class="p">(</span><span class="n">A</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">,</span> <span class="n">reps</span><span class="p">:</span> <span class="n">DimSize</span> <span class="o">|</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">DimSize</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Array</span><span class="p">:</span>
  <span class="n">util</span><span class="o">.</span><span class="n">check_arraylike</span><span class="p">(</span><span class="s2">&quot;tile&quot;</span><span class="p">,</span> <span class="n">A</span><span class="p">)</span>
  <span class="k">try</span><span class="p">:</span>
    <span class="nb">iter</span><span class="p">(</span><span class="n">reps</span><span class="p">)</span>  <span class="c1"># type: ignore[arg-type]</span>
  <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
    <span class="n">reps_tup</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">DimSize</span><span class="p">,</span> <span class="o">...</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">reps</span><span class="p">,)</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="n">reps_tup</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">reps</span><span class="p">)</span>  <span class="c1"># type: ignore[assignment,arg-type]</span>
  <span class="n">reps_tup</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">operator</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">rep</span><span class="p">)</span> <span class="k">if</span> <span class="n">core</span><span class="o">.</span><span class="n">is_constant_dim</span><span class="p">(</span><span class="n">rep</span><span class="p">)</span> <span class="k">else</span> <span class="n">rep</span>
                   <span class="k">for</span> <span class="n">rep</span> <span class="ow">in</span> <span class="n">reps_tup</span><span class="p">)</span>
  <span class="n">A_shape</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,)</span> <span class="o">*</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">reps_tup</span><span class="p">)</span> <span class="o">-</span> <span class="n">ndim</span><span class="p">(</span><span class="n">A</span><span class="p">))</span> <span class="o">+</span> <span class="n">shape</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
  <span class="n">reps_tup</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,)</span> <span class="o">*</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">A_shape</span><span class="p">)</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">reps_tup</span><span class="p">))</span> <span class="o">+</span> <span class="n">reps_tup</span>
  <span class="n">result</span> <span class="o">=</span> <span class="n">broadcast_to</span><span class="p">(</span><span class="n">reshape</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="p">[</span><span class="n">j</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">A_shape</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">i</span><span class="p">]]),</span>
                        <span class="p">[</span><span class="n">k</span> <span class="k">for</span> <span class="n">pair</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">reps_tup</span><span class="p">,</span> <span class="n">A_shape</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">pair</span><span class="p">])</span>
  <span class="k">return</span> <span class="n">reshape</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span><span class="n">A_shape</span><span class="p">,</span> <span class="n">reps_tup</span><span class="p">)))</span>

<span class="k">def</span> <span class="nf">_concatenate_array</span><span class="p">(</span><span class="n">arr</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">,</span> <span class="n">axis</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="kc">None</span><span class="p">,</span>
                       <span class="n">dtype</span><span class="p">:</span> <span class="n">DTypeLike</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Array</span><span class="p">:</span>
  <span class="c1"># Fast path for concatenation when the input is an ndarray rather than a list.</span>
  <span class="n">arr</span> <span class="o">=</span> <span class="n">asarray</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">arr</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">arr</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Need at least one array to concatenate.&quot;</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">axis</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">lax</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="p">(</span><span class="n">arr</span><span class="o">.</span><span class="n">size</span><span class="p">,))</span>
  <span class="k">if</span> <span class="n">arr</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Zero-dimensional arrays cannot be concatenated.&quot;</span><span class="p">)</span>
  <span class="n">axis</span> <span class="o">=</span> <span class="n">_canonicalize_axis</span><span class="p">(</span><span class="n">axis</span><span class="p">,</span> <span class="n">arr</span><span class="o">.</span><span class="n">ndim</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
  <span class="n">shape</span> <span class="o">=</span> <span class="n">arr</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="n">axis</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="n">arr</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">arr</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],)</span> <span class="o">+</span> <span class="n">arr</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span> <span class="o">+</span> <span class="mi">2</span><span class="p">:]</span>
  <span class="n">dimensions</span> <span class="o">=</span> <span class="p">[</span><span class="o">*</span><span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">axis</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="o">*</span><span class="nb">range</span><span class="p">(</span><span class="n">axis</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">arr</span><span class="o">.</span><span class="n">ndim</span><span class="p">)]</span>
  <span class="k">return</span> <span class="n">lax</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">shape</span><span class="p">,</span> <span class="n">dimensions</span><span class="p">)</span>

<span class="nd">@util</span><span class="o">.</span><span class="n">_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">concatenate</span><span class="p">(</span><span class="n">arrays</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">|</span> <span class="n">Array</span> <span class="o">|</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">ArrayLike</span><span class="p">],</span>
                <span class="n">axis</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">dtype</span><span class="p">:</span> <span class="n">DTypeLike</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Array</span><span class="p">:</span>
  <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">arrays</span><span class="p">,</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">Array</span><span class="p">)):</span>
    <span class="k">return</span> <span class="n">_concatenate_array</span><span class="p">(</span><span class="n">arrays</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>
  <span class="n">util</span><span class="o">.</span><span class="n">check_arraylike</span><span class="p">(</span><span class="s2">&quot;concatenate&quot;</span><span class="p">,</span> <span class="o">*</span><span class="n">arrays</span><span class="p">)</span>
  <span class="k">if</span> <span class="ow">not</span> <span class="nb">len</span><span class="p">(</span><span class="n">arrays</span><span class="p">):</span>
    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Need at least one array to concatenate.&quot;</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">ndim</span><span class="p">(</span><span class="n">arrays</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Zero-dimensional arrays cannot be concatenated.&quot;</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">axis</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">concatenate</span><span class="p">([</span><span class="n">ravel</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">arrays</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>
  <span class="n">axis</span> <span class="o">=</span> <span class="n">_canonicalize_axis</span><span class="p">(</span><span class="n">axis</span><span class="p">,</span> <span class="n">ndim</span><span class="p">(</span><span class="n">arrays</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
  <span class="k">if</span> <span class="n">dtype</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
    <span class="n">arrays_out</span> <span class="o">=</span> <span class="n">util</span><span class="o">.</span><span class="n">promote_dtypes</span><span class="p">(</span><span class="o">*</span><span class="n">arrays</span><span class="p">)</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="n">arrays_out</span> <span class="o">=</span> <span class="p">[</span><span class="n">asarray</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span> <span class="k">for</span> <span class="n">arr</span> <span class="ow">in</span> <span class="n">arrays</span><span class="p">]</span>
  <span class="c1"># lax.concatenate can be slow to compile for wide concatenations, so form a</span>
  <span class="c1"># tree of concatenations as a workaround especially for op-by-op mode.</span>
  <span class="c1"># (https://github.com/google/jax/issues/653).</span>
  <span class="n">k</span> <span class="o">=</span> <span class="mi">16</span>
  <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">arrays_out</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
    <span class="n">arrays_out</span> <span class="o">=</span> <span class="p">[</span><span class="n">lax</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">arrays_out</span><span class="p">[</span><span class="n">i</span><span class="p">:</span><span class="n">i</span><span class="o">+</span><span class="n">k</span><span class="p">],</span> <span class="n">axis</span><span class="p">)</span>
                  <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">arrays_out</span><span class="p">),</span> <span class="n">k</span><span class="p">)]</span>
  <span class="k">return</span> <span class="n">arrays_out</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>


<span class="nd">@util</span><span class="o">.</span><span class="n">_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">vstack</span><span class="p">(</span><span class="n">tup</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">|</span> <span class="n">Array</span> <span class="o">|</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">ArrayLike</span><span class="p">],</span>
           <span class="n">dtype</span><span class="p">:</span> <span class="n">DTypeLike</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Array</span><span class="p">:</span>
  <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">tup</span><span class="p">,</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">Array</span><span class="p">)):</span>
    <span class="n">arrs</span> <span class="o">=</span> <span class="n">jax</span><span class="o">.</span><span class="n">vmap</span><span class="p">(</span><span class="n">atleast_2d</span><span class="p">)(</span><span class="n">tup</span><span class="p">)</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="n">arrs</span> <span class="o">=</span> <span class="p">[</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">m</span><span class="p">)</span> <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">tup</span><span class="p">]</span>
  <span class="k">return</span> <span class="n">concatenate</span><span class="p">(</span><span class="n">arrs</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>


<span class="nd">@util</span><span class="o">.</span><span class="n">_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">hstack</span><span class="p">(</span><span class="n">tup</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">|</span> <span class="n">Array</span> <span class="o">|</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">ArrayLike</span><span class="p">],</span>
           <span class="n">dtype</span><span class="p">:</span> <span class="n">DTypeLike</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Array</span><span class="p">:</span>
  <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">tup</span><span class="p">,</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">Array</span><span class="p">)):</span>
    <span class="n">arrs</span> <span class="o">=</span> <span class="n">jax</span><span class="o">.</span><span class="n">vmap</span><span class="p">(</span><span class="n">atleast_1d</span><span class="p">)(</span><span class="n">tup</span><span class="p">)</span>
    <span class="n">arr0_ndim</span> <span class="o">=</span> <span class="n">arrs</span><span class="o">.</span><span class="n">ndim</span> <span class="o">-</span> <span class="mi">1</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="n">arrs</span> <span class="o">=</span> <span class="p">[</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">m</span><span class="p">)</span> <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">tup</span><span class="p">]</span>
    <span class="n">arr0_ndim</span> <span class="o">=</span> <span class="n">arrs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">ndim</span>
  <span class="k">return</span> <span class="n">concatenate</span><span class="p">(</span><span class="n">arrs</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span> <span class="k">if</span> <span class="n">arr0_ndim</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">else</span> <span class="mi">1</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>


<span class="nd">@util</span><span class="o">.</span><span class="n">_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dstack</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">dstack</span><span class="p">(</span><span class="n">tup</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">|</span> <span class="n">Array</span> <span class="o">|</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">ArrayLike</span><span class="p">],</span>
           <span class="n">dtype</span><span class="p">:</span> <span class="n">DTypeLike</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Array</span><span class="p">:</span>
  <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">tup</span><span class="p">,</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">Array</span><span class="p">)):</span>
    <span class="n">arrs</span> <span class="o">=</span> <span class="n">jax</span><span class="o">.</span><span class="n">vmap</span><span class="p">(</span><span class="n">atleast_3d</span><span class="p">)(</span><span class="n">tup</span><span class="p">)</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="n">arrs</span> <span class="o">=</span> <span class="p">[</span><span class="n">atleast_3d</span><span class="p">(</span><span class="n">m</span><span class="p">)</span> <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">tup</span><span class="p">]</span>
  <span class="k">return</span> <span class="n">concatenate</span><span class="p">(</span><span class="n">arrs</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>


<span class="nd">@util</span><span class="o">.</span><span class="n">_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">column_stack</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">column_stack</span><span class="p">(</span><span class="n">tup</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">|</span> <span class="n">Array</span> <span class="o">|</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">ArrayLike</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Array</span><span class="p">:</span>
  <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">tup</span><span class="p">,</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">Array</span><span class="p">)):</span>
    <span class="n">arrs</span> <span class="o">=</span> <span class="n">jax</span><span class="o">.</span><span class="n">vmap</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">atleast_2d</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">T</span><span class="p">)(</span><span class="n">tup</span><span class="p">)</span> <span class="k">if</span> <span class="n">tup</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&lt;</span> <span class="mi">3</span> <span class="k">else</span> <span class="n">tup</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="n">arrs</span> <span class="o">=</span> <span class="p">[</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span><span class="o">.</span><span class="n">T</span> <span class="k">if</span> <span class="n">arr</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&lt;</span> <span class="mi">2</span> <span class="k">else</span> <span class="n">arr</span> <span class="k">for</span> <span class="n">arr</span> <span class="ow">in</span> <span class="nb">map</span><span class="p">(</span><span class="n">asarray</span><span class="p">,</span> <span class="n">tup</span><span class="p">)]</span>
  <span class="k">return</span> <span class="n">concatenate</span><span class="p">(</span><span class="n">arrs</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>


<span class="nd">@util</span><span class="o">.</span><span class="n">_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">choose</span><span class="p">,</span> <span class="n">skip_params</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;out&#39;</span><span class="p">])</span>
<span class="k">def</span> <span class="nf">choose</span><span class="p">(</span><span class="n">a</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">,</span> <span class="n">choices</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">ArrayLike</span><span class="p">],</span>
           <span class="n">out</span><span class="p">:</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">mode</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;raise&#39;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Array</span><span class="p">:</span>
  <span class="k">if</span> <span class="n">out</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
    <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;The &#39;out&#39; argument to jnp.choose is not supported.&quot;</span><span class="p">)</span>
  <span class="n">util</span><span class="o">.</span><span class="n">check_arraylike</span><span class="p">(</span><span class="s1">&#39;choose&#39;</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="o">*</span><span class="n">choices</span><span class="p">)</span>
  <span class="k">if</span> <span class="ow">not</span> <span class="n">issubdtype</span><span class="p">(</span><span class="n">_dtype</span><span class="p">(</span><span class="n">a</span><span class="p">),</span> <span class="n">integer</span><span class="p">):</span>
    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;`a` array must be integer typed&quot;</span><span class="p">)</span>
  <span class="n">N</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">choices</span><span class="p">)</span>

  <span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="s1">&#39;raise&#39;</span><span class="p">:</span>
    <span class="n">arr</span><span class="p">:</span> <span class="n">Array</span> <span class="o">=</span> <span class="n">core</span><span class="o">.</span><span class="n">concrete_or_error</span><span class="p">(</span><span class="n">asarray</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span>
      <span class="s2">&quot;The error occurred because jnp.choose was jit-compiled&quot;</span>
      <span class="s2">&quot; with mode=&#39;raise&#39;. Use mode=&#39;wrap&#39; or mode=&#39;clip&#39; instead.&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">reductions</span><span class="o">.</span><span class="n">any</span><span class="p">((</span><span class="n">arr</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">arr</span> <span class="o">&gt;=</span> <span class="n">N</span><span class="p">)):</span>
      <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;invalid entry in choice array&quot;</span><span class="p">)</span>
  <span class="k">elif</span> <span class="n">mode</span> <span class="o">==</span> <span class="s1">&#39;wrap&#39;</span><span class="p">:</span>
    <span class="n">arr</span> <span class="o">=</span> <span class="n">asarray</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">%</span> <span class="n">N</span>
  <span class="k">elif</span> <span class="n">mode</span> <span class="o">==</span> <span class="s1">&#39;clip&#39;</span><span class="p">:</span>
    <span class="n">arr</span> <span class="o">=</span> <span class="n">clip</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">N</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;mode=</span><span class="si">{</span><span class="n">mode</span><span class="si">!r}</span><span class="s2"> not understood. Must be &#39;raise&#39;, &#39;wrap&#39;, or &#39;clip&#39;&quot;</span><span class="p">)</span>

  <span class="n">arr</span><span class="p">,</span> <span class="o">*</span><span class="n">choices</span> <span class="o">=</span> <span class="n">broadcast_arrays</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="o">*</span><span class="n">choices</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">array</span><span class="p">(</span><span class="n">choices</span><span class="p">)[(</span><span class="n">arr</span><span class="p">,)</span> <span class="o">+</span> <span class="n">indices</span><span class="p">(</span><span class="n">arr</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">sparse</span><span class="o">=</span><span class="kc">True</span><span class="p">)]</span>


<span class="k">def</span> <span class="nf">_atleast_nd</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">,</span> <span class="n">n</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Array</span><span class="p">:</span>
  <span class="n">m</span> <span class="o">=</span> <span class="n">ndim</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">lax</span><span class="o">.</span><span class="n">broadcast</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="p">(</span><span class="mi">1</span><span class="p">,)</span> <span class="o">*</span> <span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="n">m</span><span class="p">))</span> <span class="k">if</span> <span class="n">m</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="k">else</span> <span class="n">asarray</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">_block</span><span class="p">(</span><span class="n">xs</span><span class="p">:</span> <span class="n">ArrayLike</span> <span class="o">|</span> <span class="nb">list</span><span class="p">[</span><span class="n">ArrayLike</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">Array</span><span class="p">,</span> <span class="nb">int</span><span class="p">]:</span>
  <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">xs</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;jax.numpy.block does not allow tuples, got </span><span class="si">{}</span><span class="s2">&quot;</span>
                     <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">xs</span><span class="p">))</span>
  <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">xs</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">xs</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
      <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;jax.numpy.block does not allow empty list arguments&quot;</span><span class="p">)</span>
    <span class="n">xs_tup</span><span class="p">,</span> <span class="n">depths</span> <span class="o">=</span> <span class="n">unzip2</span><span class="p">([</span><span class="n">_block</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">xs</span><span class="p">])</span>
    <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">d</span> <span class="o">!=</span> <span class="n">depths</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">depths</span><span class="p">[</span><span class="mi">1</span><span class="p">:]):</span>
      <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Mismatched list depths in jax.numpy.block&quot;</span><span class="p">)</span>
    <span class="n">rank</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">depths</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">max</span><span class="p">(</span><span class="n">ndim</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">xs_tup</span><span class="p">))</span>
    <span class="n">xs_tup</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">_atleast_nd</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">rank</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">xs_tup</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">concatenate</span><span class="p">(</span><span class="n">xs_tup</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="n">depths</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">depths</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">asarray</span><span class="p">(</span><span class="n">xs</span><span class="p">),</span> <span class="mi">1</span>

<span class="nd">@util</span><span class="o">.</span><span class="n">_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">block</span><span class="p">)</span>
<span class="nd">@jit</span>
<span class="k">def</span> <span class="nf">block</span><span class="p">(</span><span class="n">arrays</span><span class="p">:</span> <span class="n">ArrayLike</span> <span class="o">|</span> <span class="nb">list</span><span class="p">[</span><span class="n">ArrayLike</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Array</span><span class="p">:</span>
  <span class="n">out</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">_block</span><span class="p">(</span><span class="n">arrays</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">out</span>

<span class="nd">@util</span><span class="o">.</span><span class="n">_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">,</span> <span class="n">update_doc</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">lax_description</span><span class="o">=</span><span class="n">_ARRAY_VIEW_DOC</span><span class="p">)</span>
<span class="nd">@jit</span>
<span class="k">def</span> <span class="nf">atleast_1d</span><span class="p">(</span><span class="o">*</span><span class="n">arys</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Array</span> <span class="o">|</span> <span class="nb">list</span><span class="p">[</span><span class="n">Array</span><span class="p">]:</span>
  <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">arys</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
    <span class="n">arr</span> <span class="o">=</span> <span class="n">asarray</span><span class="p">(</span><span class="n">arys</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">arr</span> <span class="k">if</span> <span class="n">ndim</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">1</span> <span class="k">else</span> <span class="n">reshape</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span> <span class="k">for</span> <span class="n">arr</span> <span class="ow">in</span> <span class="n">arys</span><span class="p">]</span>


<span class="nd">@util</span><span class="o">.</span><span class="n">_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">,</span> <span class="n">update_doc</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">lax_description</span><span class="o">=</span><span class="n">_ARRAY_VIEW_DOC</span><span class="p">)</span>
<span class="nd">@jit</span>
<span class="k">def</span> <span class="nf">atleast_2d</span><span class="p">(</span><span class="o">*</span><span class="n">arys</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Array</span> <span class="o">|</span> <span class="nb">list</span><span class="p">[</span><span class="n">Array</span><span class="p">]:</span>
  <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">arys</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
    <span class="n">arr</span> <span class="o">=</span> <span class="n">asarray</span><span class="p">(</span><span class="n">arys</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="k">if</span> <span class="n">ndim</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="p">:</span>
      <span class="k">return</span> <span class="n">arr</span>
    <span class="k">elif</span> <span class="n">ndim</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
      <span class="k">return</span> <span class="n">expand_dims</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="k">return</span> <span class="n">expand_dims</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span> <span class="k">for</span> <span class="n">arr</span> <span class="ow">in</span> <span class="n">arys</span><span class="p">]</span>


<span class="nd">@util</span><span class="o">.</span><span class="n">_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">atleast_3d</span><span class="p">,</span> <span class="n">update_doc</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">lax_description</span><span class="o">=</span><span class="n">_ARRAY_VIEW_DOC</span><span class="p">)</span>
<span class="nd">@jit</span>
<span class="k">def</span> <span class="nf">atleast_3d</span><span class="p">(</span><span class="o">*</span><span class="n">arys</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Array</span> <span class="o">|</span> <span class="nb">list</span><span class="p">[</span><span class="n">Array</span><span class="p">]:</span>
  <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">arys</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
    <span class="n">arr</span> <span class="o">=</span> <span class="n">asarray</span><span class="p">(</span><span class="n">arys</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="k">if</span> <span class="n">ndim</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
      <span class="n">arr</span> <span class="o">=</span> <span class="n">expand_dims</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
    <span class="k">elif</span> <span class="n">ndim</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
      <span class="n">arr</span> <span class="o">=</span> <span class="n">expand_dims</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
    <span class="k">elif</span> <span class="n">ndim</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
      <span class="n">arr</span> <span class="o">=</span> <span class="n">expand_dims</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">arr</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">atleast_3d</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span> <span class="k">for</span> <span class="n">arr</span> <span class="ow">in</span> <span class="n">arys</span><span class="p">]</span>


<span class="n">_ARRAY_DOC</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span>
<span class="s2">This function will create arrays on JAX&#39;s default device. For control of the</span>
<span class="s2">device placement of data, see :func:`jax.device_put`. More information is</span>
<span class="s2">available in the JAX FAQ at :ref:`faq-data-placement` (full FAQ at</span>
<span class="s2">https://jax.readthedocs.io/en/latest/faq.html).</span>
<span class="s2">&quot;&quot;&quot;</span>

<span class="nd">@util</span><span class="o">.</span><span class="n">_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">,</span> <span class="n">lax_description</span><span class="o">=</span><span class="n">_ARRAY_DOC</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">array</span><span class="p">(</span><span class="nb">object</span><span class="p">:</span> <span class="n">Any</span><span class="p">,</span> <span class="n">dtype</span><span class="p">:</span> <span class="n">DTypeLike</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">copy</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
          <span class="n">order</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="s2">&quot;K&quot;</span><span class="p">,</span> <span class="n">ndmin</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Array</span><span class="p">:</span>
  <span class="k">if</span> <span class="n">order</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">order</span> <span class="o">!=</span> <span class="s2">&quot;K&quot;</span><span class="p">:</span>
    <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;Only implemented for order=&#39;K&#39;&quot;</span><span class="p">)</span>

  <span class="c1"># check if the given dtype is compatible with JAX</span>
  <span class="n">dtypes</span><span class="o">.</span><span class="n">check_user_dtype_supported</span><span class="p">(</span><span class="n">dtype</span><span class="p">,</span> <span class="s2">&quot;array&quot;</span><span class="p">)</span>

  <span class="c1"># Here we make a judgment call: we only return a weakly-typed array when the</span>
  <span class="c1"># input object itself is weakly typed. That ensures asarray(x) is a no-op</span>
  <span class="c1"># whenever x is weak, but avoids introducing weak types with something like</span>
  <span class="c1"># array([1, 2, 3])</span>
  <span class="n">weak_type</span> <span class="o">=</span> <span class="n">dtype</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">dtypes</span><span class="o">.</span><span class="n">is_weakly_typed</span><span class="p">(</span><span class="nb">object</span><span class="p">)</span>

  <span class="c1"># For Python scalar literals, call coerce_to_array to catch any overflow</span>
  <span class="c1"># errors. We don&#39;t use dtypes.is_python_scalar because we don&#39;t want this</span>
  <span class="c1"># triggering for traced values. We do this here because it matters whether or</span>
  <span class="c1"># not dtype is None. We don&#39;t assign the result because we want the raw object</span>
  <span class="c1"># to be used for type inference below.</span>
  <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="nb">object</span><span class="p">,</span> <span class="p">(</span><span class="nb">bool</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="nb">complex</span><span class="p">)):</span>
    <span class="n">_</span> <span class="o">=</span> <span class="n">dtypes</span><span class="o">.</span><span class="n">coerce_to_array</span><span class="p">(</span><span class="nb">object</span><span class="p">,</span> <span class="n">dtype</span><span class="p">)</span>

  <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="nb">object</span><span class="p">,</span> <span class="s1">&#39;__jax_array__&#39;</span><span class="p">):</span>
    <span class="nb">object</span> <span class="o">=</span> <span class="nb">object</span><span class="o">.</span><span class="n">__jax_array__</span><span class="p">()</span>
  <span class="nb">object</span> <span class="o">=</span> <span class="n">tree_map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">leaf</span><span class="p">:</span> <span class="n">leaf</span><span class="o">.</span><span class="n">__jax_array__</span><span class="p">()</span> <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="s2">&quot;__jax_array__&quot;</span><span class="p">)</span> <span class="k">else</span> <span class="n">leaf</span><span class="p">,</span>
                    <span class="nb">object</span><span class="p">)</span>
  <span class="n">leaves</span> <span class="o">=</span> <span class="n">tree_leaves</span><span class="p">(</span><span class="nb">object</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">dtype</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
    <span class="c1"># Use lattice_result_type rather than result_type to avoid canonicalization.</span>
    <span class="c1"># Otherwise, weakly-typed inputs would have their dtypes canonicalized.</span>
    <span class="k">try</span><span class="p">:</span>
      <span class="n">dtype</span> <span class="o">=</span> <span class="n">dtypes</span><span class="o">.</span><span class="n">_lattice_result_type</span><span class="p">(</span><span class="o">*</span><span class="n">leaves</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="k">if</span> <span class="n">leaves</span> <span class="k">else</span> <span class="n">dtypes</span><span class="o">.</span><span class="n">float_</span>
    <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
      <span class="c1"># This happens if, e.g. one of the entries is a memoryview object.</span>
      <span class="c1"># This is rare, so we only handle it if the normal path fails.</span>
      <span class="n">leaves</span> <span class="o">=</span> <span class="p">[</span><span class="n">_convert_to_array_if_dtype_fails</span><span class="p">(</span><span class="n">leaf</span><span class="p">)</span> <span class="k">for</span> <span class="n">leaf</span> <span class="ow">in</span> <span class="n">leaves</span><span class="p">]</span>
      <span class="n">dtype</span> <span class="o">=</span> <span class="n">dtypes</span><span class="o">.</span><span class="n">_lattice_result_type</span><span class="p">(</span><span class="o">*</span><span class="n">leaves</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

  <span class="k">if</span> <span class="ow">not</span> <span class="n">weak_type</span><span class="p">:</span>
    <span class="n">dtype</span> <span class="o">=</span> <span class="n">dtypes</span><span class="o">.</span><span class="n">canonicalize_dtype</span><span class="p">(</span><span class="n">dtype</span><span class="p">,</span> <span class="n">allow_extended_dtype</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

  <span class="n">out</span><span class="p">:</span> <span class="n">ArrayLike</span>

  <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">Array</span><span class="p">)</span> <span class="k">for</span> <span class="n">leaf</span> <span class="ow">in</span> <span class="n">leaves</span><span class="p">):</span>
    <span class="c1"># TODO(jakevdp): falling back to numpy here fails to overflow for lists</span>
    <span class="c1"># containing large integers; see discussion in</span>
    <span class="c1"># https://github.com/google/jax/pull/6047. More correct would be to call</span>
    <span class="c1"># coerce_to_array on each leaf, but this may have performance implications.</span>
    <span class="n">out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">object</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span> <span class="n">ndmin</span><span class="o">=</span><span class="n">ndmin</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>  <span class="c1"># type: ignore[arg-type]</span>
  <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="nb">object</span><span class="p">,</span> <span class="n">Array</span><span class="p">):</span>
    <span class="k">assert</span> <span class="nb">object</span><span class="o">.</span><span class="n">aval</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
    <span class="n">out</span> <span class="o">=</span> <span class="n">_array_copy</span><span class="p">(</span><span class="nb">object</span><span class="p">)</span> <span class="k">if</span> <span class="n">copy</span> <span class="k">else</span> <span class="nb">object</span>
  <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="nb">object</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)):</span>
    <span class="k">if</span> <span class="nb">object</span><span class="p">:</span>
      <span class="n">out</span> <span class="o">=</span> <span class="n">stack</span><span class="p">([</span><span class="n">asarray</span><span class="p">(</span><span class="n">elt</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span> <span class="k">for</span> <span class="n">elt</span> <span class="ow">in</span> <span class="nb">object</span><span class="p">])</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="n">out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>  <span class="c1"># type: ignore[arg-type]</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="k">try</span><span class="p">:</span>
      <span class="n">view</span> <span class="o">=</span> <span class="nb">memoryview</span><span class="p">(</span><span class="nb">object</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
      <span class="k">pass</span>  <span class="c1"># `object` does not support the buffer interface.</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="k">return</span> <span class="n">array</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">view</span><span class="p">),</span> <span class="n">dtype</span><span class="p">,</span> <span class="n">copy</span><span class="p">,</span> <span class="n">ndmin</span><span class="o">=</span><span class="n">ndmin</span><span class="p">)</span>

    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Unexpected input type for array: </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="nb">object</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

  <span class="n">out_array</span><span class="p">:</span> <span class="n">Array</span> <span class="o">=</span> <span class="n">lax_internal</span><span class="o">.</span><span class="n">_convert_element_type</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="n">dtype</span><span class="p">,</span> <span class="n">weak_type</span><span class="o">=</span><span class="n">weak_type</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">ndmin</span> <span class="o">&gt;</span> <span class="n">ndim</span><span class="p">(</span><span class="n">out_array</span><span class="p">):</span>
    <span class="n">out_array</span> <span class="o">=</span> <span class="n">lax</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">(</span><span class="n">out_array</span><span class="p">,</span> <span class="nb">range</span><span class="p">(</span><span class="n">ndmin</span> <span class="o">-</span> <span class="n">ndim</span><span class="p">(</span><span class="n">out_array</span><span class="p">)))</span>
  <span class="k">return</span> <span class="n">out_array</span>


<span class="k">def</span> <span class="nf">_convert_to_array_if_dtype_fails</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ArrayLike</span><span class="p">:</span>
  <span class="k">try</span><span class="p">:</span>
    <span class="n">dtypes</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
  <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">x</span>


<span class="nd">@util</span><span class="o">.</span><span class="n">_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">,</span> <span class="n">lax_description</span><span class="o">=</span><span class="n">_ARRAY_DOC</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">asarray</span><span class="p">(</span><span class="n">a</span><span class="p">:</span> <span class="n">Any</span><span class="p">,</span> <span class="n">dtype</span><span class="p">:</span> <span class="n">DTypeLike</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">order</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Array</span><span class="p">:</span>
  <span class="n">dtypes</span><span class="o">.</span><span class="n">check_user_dtype_supported</span><span class="p">(</span><span class="n">dtype</span><span class="p">,</span> <span class="s2">&quot;asarray&quot;</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">dtype</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
    <span class="n">dtype</span> <span class="o">=</span> <span class="n">dtypes</span><span class="o">.</span><span class="n">canonicalize_dtype</span><span class="p">(</span><span class="n">dtype</span><span class="p">,</span> <span class="n">allow_extended_dtype</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">array</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="n">order</span><span class="p">)</span>  <span class="c1"># type: ignore</span>


<span class="nd">@util</span><span class="o">.</span><span class="n">_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">,</span> <span class="n">lax_description</span><span class="o">=</span><span class="n">_ARRAY_DOC</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">copy</span><span class="p">(</span><span class="n">a</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">,</span> <span class="n">order</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Array</span><span class="p">:</span>
  <span class="n">util</span><span class="o">.</span><span class="n">check_arraylike</span><span class="p">(</span><span class="s2">&quot;copy&quot;</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">array</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="n">order</span><span class="p">)</span>


<span class="nd">@util</span><span class="o">.</span><span class="n">_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">zeros_like</span><span class="p">(</span><span class="n">a</span><span class="p">:</span> <span class="n">ArrayLike</span> <span class="o">|</span> <span class="n">DuckTypedArray</span><span class="p">,</span>
               <span class="n">dtype</span><span class="p">:</span> <span class="n">DTypeLike</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
               <span class="n">shape</span><span class="p">:</span> <span class="n">Any</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Array</span><span class="p">:</span>
  <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="nb">hasattr</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="s1">&#39;dtype&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="s1">&#39;shape&#39;</span><span class="p">)):</span>  <span class="c1"># support duck typing</span>
    <span class="n">util</span><span class="o">.</span><span class="n">check_arraylike</span><span class="p">(</span><span class="s2">&quot;zeros_like&quot;</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
  <span class="n">dtypes</span><span class="o">.</span><span class="n">check_user_dtype_supported</span><span class="p">(</span><span class="n">dtype</span><span class="p">,</span> <span class="s2">&quot;zeros_like&quot;</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">shape</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
    <span class="n">shape</span> <span class="o">=</span> <span class="n">canonicalize_shape</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">lax</span><span class="o">.</span><span class="n">full_like</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">dtype</span><span class="p">,</span> <span class="n">shape</span><span class="p">)</span>


<span class="nd">@util</span><span class="o">.</span><span class="n">_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ones_like</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">ones_like</span><span class="p">(</span><span class="n">a</span><span class="p">:</span> <span class="n">ArrayLike</span> <span class="o">|</span> <span class="n">DuckTypedArray</span><span class="p">,</span>
              <span class="n">dtype</span><span class="p">:</span> <span class="n">DTypeLike</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
              <span class="n">shape</span><span class="p">:</span> <span class="n">Any</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Array</span><span class="p">:</span>
  <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="nb">hasattr</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="s1">&#39;dtype&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="s1">&#39;shape&#39;</span><span class="p">)):</span>  <span class="c1"># support duck typing</span>
    <span class="n">util</span><span class="o">.</span><span class="n">check_arraylike</span><span class="p">(</span><span class="s2">&quot;ones_like&quot;</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
  <span class="n">dtypes</span><span class="o">.</span><span class="n">check_user_dtype_supported</span><span class="p">(</span><span class="n">dtype</span><span class="p">,</span> <span class="s2">&quot;ones_like&quot;</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">shape</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
    <span class="n">shape</span> <span class="o">=</span> <span class="n">canonicalize_shape</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">lax</span><span class="o">.</span><span class="n">full_like</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">dtype</span><span class="p">,</span> <span class="n">shape</span><span class="p">)</span>


<span class="nd">@util</span><span class="o">.</span><span class="n">_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">empty_like</span><span class="p">,</span> <span class="n">lax_description</span><span class="o">=</span><span class="s2">&quot;&quot;&quot;</span><span class="se">\</span>
<span class="s2">Because XLA cannot create uninitialized arrays, the JAX version will</span>
<span class="s2">return an array initialized with zeros.&quot;&quot;&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">empty_like</span><span class="p">(</span><span class="n">prototype</span><span class="p">:</span> <span class="n">ArrayLike</span> <span class="o">|</span> <span class="n">DuckTypedArray</span><span class="p">,</span>
               <span class="n">dtype</span><span class="p">:</span> <span class="n">DTypeLike</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
               <span class="n">shape</span><span class="p">:</span> <span class="n">Any</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Array</span><span class="p">:</span>
  <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="nb">hasattr</span><span class="p">(</span><span class="n">prototype</span><span class="p">,</span> <span class="s1">&#39;dtype&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">prototype</span><span class="p">,</span> <span class="s1">&#39;shape&#39;</span><span class="p">)):</span>  <span class="c1"># support duck typing</span>
    <span class="n">util</span><span class="o">.</span><span class="n">check_arraylike</span><span class="p">(</span><span class="s2">&quot;empty_like&quot;</span><span class="p">,</span> <span class="n">prototype</span><span class="p">)</span>
  <span class="n">dtypes</span><span class="o">.</span><span class="n">check_user_dtype_supported</span><span class="p">(</span><span class="n">dtype</span><span class="p">,</span> <span class="s2">&quot;empty_like&quot;</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">zeros_like</span><span class="p">(</span><span class="n">prototype</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="n">shape</span><span class="p">)</span>


<span class="nd">@util</span><span class="o">.</span><span class="n">_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">full</span><span class="p">(</span><span class="n">shape</span><span class="p">:</span> <span class="n">Any</span><span class="p">,</span> <span class="n">fill_value</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">,</span>
         <span class="n">dtype</span><span class="p">:</span> <span class="n">DTypeLike</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Array</span><span class="p">:</span>
  <span class="n">dtypes</span><span class="o">.</span><span class="n">check_user_dtype_supported</span><span class="p">(</span><span class="n">dtype</span><span class="p">,</span> <span class="s2">&quot;full&quot;</span><span class="p">)</span>
  <span class="n">util</span><span class="o">.</span><span class="n">check_arraylike</span><span class="p">(</span><span class="s2">&quot;full&quot;</span><span class="p">,</span> <span class="n">fill_value</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">ndim</span><span class="p">(</span><span class="n">fill_value</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
    <span class="n">shape</span> <span class="o">=</span> <span class="n">canonicalize_shape</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">lax</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="n">shape</span><span class="p">,</span> <span class="n">fill_value</span><span class="p">,</span> <span class="n">dtype</span><span class="p">)</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">broadcast_to</span><span class="p">(</span><span class="n">asarray</span><span class="p">(</span><span class="n">fill_value</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">),</span> <span class="n">shape</span><span class="p">)</span>


<span class="nd">@util</span><span class="o">.</span><span class="n">_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">full_like</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">full_like</span><span class="p">(</span><span class="n">a</span><span class="p">:</span> <span class="n">ArrayLike</span> <span class="o">|</span> <span class="n">DuckTypedArray</span><span class="p">,</span>
              <span class="n">fill_value</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">,</span> <span class="n">dtype</span><span class="p">:</span> <span class="n">DTypeLike</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
              <span class="n">shape</span><span class="p">:</span> <span class="n">Any</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Array</span><span class="p">:</span>
  <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="s1">&#39;dtype&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="s1">&#39;shape&#39;</span><span class="p">):</span>  <span class="c1"># support duck typing</span>
    <span class="n">util</span><span class="o">.</span><span class="n">check_arraylike</span><span class="p">(</span><span class="s2">&quot;full_like&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">fill_value</span><span class="p">)</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="n">util</span><span class="o">.</span><span class="n">check_arraylike</span><span class="p">(</span><span class="s2">&quot;full_like&quot;</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">fill_value</span><span class="p">)</span>
  <span class="n">dtypes</span><span class="o">.</span><span class="n">check_user_dtype_supported</span><span class="p">(</span><span class="n">dtype</span><span class="p">,</span> <span class="s2">&quot;full_like&quot;</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">shape</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
    <span class="n">shape</span> <span class="o">=</span> <span class="n">canonicalize_shape</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">ndim</span><span class="p">(</span><span class="n">fill_value</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">lax</span><span class="o">.</span><span class="n">full_like</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">fill_value</span><span class="p">,</span> <span class="n">dtype</span><span class="p">,</span> <span class="n">shape</span><span class="p">)</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="n">shape</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="k">if</span> <span class="n">shape</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">shape</span>  <span class="c1"># type: ignore[arg-type]</span>
    <span class="n">dtype</span> <span class="o">=</span> <span class="n">result_type</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="k">if</span> <span class="n">dtype</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">dtype</span>  <span class="c1"># type: ignore[arg-type]</span>
    <span class="k">return</span> <span class="n">broadcast_to</span><span class="p">(</span><span class="n">asarray</span><span class="p">(</span><span class="n">fill_value</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">),</span> <span class="n">shape</span><span class="p">)</span>


<span class="nd">@util</span><span class="o">.</span><span class="n">_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">zeros</span><span class="p">(</span><span class="n">shape</span><span class="p">:</span> <span class="n">Any</span><span class="p">,</span> <span class="n">dtype</span><span class="p">:</span> <span class="n">DTypeLike</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Array</span><span class="p">:</span>
  <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">shape</span><span class="p">,</span> <span class="n">types</span><span class="o">.</span><span class="n">GeneratorType</span><span class="p">):</span>
    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;expected sequence object with len &gt;= 0 or a single integer&quot;</span><span class="p">)</span>
  <span class="n">dtypes</span><span class="o">.</span><span class="n">check_user_dtype_supported</span><span class="p">(</span><span class="n">dtype</span><span class="p">,</span> <span class="s2">&quot;zeros&quot;</span><span class="p">)</span>
  <span class="n">shape</span> <span class="o">=</span> <span class="n">canonicalize_shape</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">lax</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="n">shape</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">_jnp_dtype</span><span class="p">(</span><span class="n">dtype</span><span class="p">))</span>

<span class="nd">@util</span><span class="o">.</span><span class="n">_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">ones</span><span class="p">(</span><span class="n">shape</span><span class="p">:</span> <span class="n">Any</span><span class="p">,</span> <span class="n">dtype</span><span class="p">:</span> <span class="n">DTypeLike</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Array</span><span class="p">:</span>
  <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">shape</span><span class="p">,</span> <span class="n">types</span><span class="o">.</span><span class="n">GeneratorType</span><span class="p">):</span>
    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;expected sequence object with len &gt;= 0 or a single integer&quot;</span><span class="p">)</span>
  <span class="n">shape</span> <span class="o">=</span> <span class="n">canonicalize_shape</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span>
  <span class="n">dtypes</span><span class="o">.</span><span class="n">check_user_dtype_supported</span><span class="p">(</span><span class="n">dtype</span><span class="p">,</span> <span class="s2">&quot;ones&quot;</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">lax</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="n">shape</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">_jnp_dtype</span><span class="p">(</span><span class="n">dtype</span><span class="p">))</span>


<span class="nd">@util</span><span class="o">.</span><span class="n">_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">,</span> <span class="n">lax_description</span><span class="o">=</span><span class="s2">&quot;&quot;&quot;</span><span class="se">\</span>
<span class="s2">Because XLA cannot create uninitialized arrays, the JAX version will</span>
<span class="s2">return an array initialized with zeros.&quot;&quot;&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">empty</span><span class="p">(</span><span class="n">shape</span><span class="p">:</span> <span class="n">Any</span><span class="p">,</span> <span class="n">dtype</span><span class="p">:</span> <span class="n">DTypeLike</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Array</span><span class="p">:</span>
  <span class="n">dtypes</span><span class="o">.</span><span class="n">check_user_dtype_supported</span><span class="p">(</span><span class="n">dtype</span><span class="p">,</span> <span class="s2">&quot;empty&quot;</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">zeros</span><span class="p">(</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="p">)</span>


<span class="nd">@util</span><span class="o">.</span><span class="n">_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array_equal</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">array_equal</span><span class="p">(</span><span class="n">a1</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">,</span> <span class="n">a2</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">,</span> <span class="n">equal_nan</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Array</span><span class="p">:</span>
  <span class="k">try</span><span class="p">:</span>
    <span class="n">a1</span><span class="p">,</span> <span class="n">a2</span> <span class="o">=</span> <span class="n">asarray</span><span class="p">(</span><span class="n">a1</span><span class="p">),</span> <span class="n">asarray</span><span class="p">(</span><span class="n">a2</span><span class="p">)</span>
  <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">bool_</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">shape</span><span class="p">(</span><span class="n">a1</span><span class="p">)</span> <span class="o">!=</span> <span class="n">shape</span><span class="p">(</span><span class="n">a2</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">bool_</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
  <span class="n">eq</span> <span class="o">=</span> <span class="n">asarray</span><span class="p">(</span><span class="n">a1</span> <span class="o">==</span> <span class="n">a2</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">equal_nan</span><span class="p">:</span>
    <span class="n">eq</span> <span class="o">=</span> <span class="n">ufuncs</span><span class="o">.</span><span class="n">logical_or</span><span class="p">(</span><span class="n">eq</span><span class="p">,</span> <span class="n">ufuncs</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">ufuncs</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">a1</span><span class="p">),</span> <span class="n">ufuncs</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">a2</span><span class="p">)))</span>
  <span class="k">return</span> <span class="n">reductions</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">eq</span><span class="p">)</span>


<span class="nd">@util</span><span class="o">.</span><span class="n">_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array_equiv</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">array_equiv</span><span class="p">(</span><span class="n">a1</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">,</span> <span class="n">a2</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Array</span><span class="p">:</span>
  <span class="k">try</span><span class="p">:</span>
    <span class="n">a1</span><span class="p">,</span> <span class="n">a2</span> <span class="o">=</span> <span class="n">asarray</span><span class="p">(</span><span class="n">a1</span><span class="p">),</span> <span class="n">asarray</span><span class="p">(</span><span class="n">a2</span><span class="p">)</span>
  <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">bool_</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
  <span class="k">try</span><span class="p">:</span>
    <span class="n">eq</span> <span class="o">=</span> <span class="n">ufuncs</span><span class="o">.</span><span class="n">equal</span><span class="p">(</span><span class="n">a1</span><span class="p">,</span> <span class="n">a2</span><span class="p">)</span>
  <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
    <span class="c1"># shapes are not broadcastable</span>
    <span class="k">return</span> <span class="n">bool_</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">reductions</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">eq</span><span class="p">)</span>


<span class="c1"># General np.from* style functions mostly delegate to numpy.</span>

<span class="nd">@util</span><span class="o">.</span><span class="n">_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">frombuffer</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">frombuffer</span><span class="p">(</span><span class="n">buffer</span><span class="p">:</span> <span class="nb">bytes</span> <span class="o">|</span> <span class="n">Any</span><span class="p">,</span> <span class="n">dtype</span><span class="p">:</span> <span class="n">DTypeLike</span> <span class="o">=</span> <span class="nb">float</span><span class="p">,</span>
               <span class="n">count</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">offset</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Array</span><span class="p">:</span>
  <span class="k">return</span> <span class="n">asarray</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">frombuffer</span><span class="p">(</span><span class="n">buffer</span><span class="o">=</span><span class="n">buffer</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span> <span class="n">count</span><span class="o">=</span><span class="n">count</span><span class="p">,</span> <span class="n">offset</span><span class="o">=</span><span class="n">offset</span><span class="p">))</span>


<span class="k">def</span> <span class="nf">fromfile</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">  </span><span class="sd">&quot;&quot;&quot;Unimplemented JAX wrapper for jnp.fromfile.</span>

<span class="sd">  This function is left deliberately unimplemented because it may be non-pure and thus</span>
<span class="sd">  unsafe for use with JIT and other JAX transformations. Consider using</span>
<span class="sd">  ``jnp.asarray(np.fromfile(...))`` instead, although care should be taken if ``np.fromfile``</span>
<span class="sd">  is used within jax transformations because of its potential side-effect of consuming the</span>
<span class="sd">  file object; for more information see `Common Gotchas: Pure Functions</span>
<span class="sd">  &lt;https://jax.readthedocs.io/en/latest/notebooks/Common_Gotchas_in_JAX.html#pure-functions&gt;`_.</span>
<span class="sd">  &quot;&quot;&quot;</span>
  <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
    <span class="s2">&quot;jnp.fromfile() is not implemented because it may be non-pure and thus unsafe for use &quot;</span>
    <span class="s2">&quot;with JIT and other JAX transformations. Consider using jnp.asarray(np.fromfile(...)) &quot;</span>
    <span class="s2">&quot;instead, although care should be taken if np.fromfile is used within a jax transformations &quot;</span>
    <span class="s2">&quot;because of its potential side-effect of consuming the file object; for more information see &quot;</span>
    <span class="s2">&quot;https://jax.readthedocs.io/en/latest/notebooks/Common_Gotchas_in_JAX.html#pure-functions&quot;</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">fromiter</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">  </span><span class="sd">&quot;&quot;&quot;Unimplemented JAX wrapper for jnp.fromiter.</span>

<span class="sd">  This function is left deliberately unimplemented because it may be non-pure and thus</span>
<span class="sd">  unsafe for use with JIT and other JAX transformations. Consider using</span>
<span class="sd">  ``jnp.asarray(np.fromiter(...))`` instead, although care should be taken if ``np.fromiter``</span>
<span class="sd">  is used within jax transformations because of its potential side-effect of consuming the</span>
<span class="sd">  iterable object; for more information see `Common Gotchas: Pure Functions</span>
<span class="sd">  &lt;https://jax.readthedocs.io/en/latest/notebooks/Common_Gotchas_in_JAX.html#pure-functions&gt;`_.</span>
<span class="sd">  &quot;&quot;&quot;</span>
  <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
    <span class="s2">&quot;jnp.fromiter() is not implemented because it may be non-pure and thus unsafe for use &quot;</span>
    <span class="s2">&quot;with JIT and other JAX transformations. Consider using jnp.asarray(np.fromiter(...)) &quot;</span>
    <span class="s2">&quot;instead, although care should be taken if np.fromiter is used within a jax transformations &quot;</span>
    <span class="s2">&quot;because of its potential side-effect of consuming the iterable object; for more information see &quot;</span>
    <span class="s2">&quot;https://jax.readthedocs.io/en/latest/notebooks/Common_Gotchas_in_JAX.html#pure-functions&quot;</span><span class="p">)</span>

<span class="nd">@util</span><span class="o">.</span><span class="n">_wraps</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="s2">&quot;from_dlpack&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">))</span>
<span class="k">def</span> <span class="nf">from_dlpack</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">Any</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Array</span><span class="p">:</span>
  <span class="kn">from</span> <span class="nn">jax.dlpack</span> <span class="kn">import</span> <span class="n">from_dlpack</span>  <span class="c1"># pylint: disable=g-import-not-at-top</span>
  <span class="k">return</span> <span class="n">from_dlpack</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">__dlpack__</span><span class="p">())</span>

<span class="nd">@util</span><span class="o">.</span><span class="n">_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">fromfunction</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">fromfunction</span><span class="p">(</span><span class="n">function</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">Array</span><span class="p">],</span> <span class="n">shape</span><span class="p">:</span> <span class="n">Any</span><span class="p">,</span>
                 <span class="o">*</span><span class="p">,</span> <span class="n">dtype</span><span class="p">:</span> <span class="n">DTypeLike</span> <span class="o">=</span> <span class="nb">float</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Array</span><span class="p">:</span>
  <span class="n">shape</span> <span class="o">=</span> <span class="n">core</span><span class="o">.</span><span class="n">canonicalize_shape</span><span class="p">(</span><span class="n">shape</span><span class="p">,</span> <span class="n">context</span><span class="o">=</span><span class="s2">&quot;shape argument of jnp.fromfunction()&quot;</span><span class="p">)</span>
  <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">shape</span><span class="p">)):</span>
    <span class="n">in_axes</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span> <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="n">j</span> <span class="k">else</span> <span class="kc">None</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">shape</span><span class="p">))]</span>
    <span class="n">function</span> <span class="o">=</span> <span class="n">jax</span><span class="o">.</span><span class="n">vmap</span><span class="p">(</span><span class="n">function</span><span class="p">,</span> <span class="n">in_axes</span><span class="o">=</span><span class="nb">tuple</span><span class="p">(</span><span class="n">in_axes</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span>
  <span class="k">return</span> <span class="n">function</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">arange</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">shape</span><span class="p">),</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>


<span class="nd">@util</span><span class="o">.</span><span class="n">_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">fromstring</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">fromstring</span><span class="p">(</span><span class="n">string</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">dtype</span><span class="p">:</span> <span class="n">DTypeLike</span> <span class="o">=</span> <span class="nb">float</span><span class="p">,</span> <span class="n">count</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">sep</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Array</span><span class="p">:</span>
  <span class="k">return</span> <span class="n">asarray</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">fromstring</span><span class="p">(</span><span class="n">string</span><span class="o">=</span><span class="n">string</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span> <span class="n">count</span><span class="o">=</span><span class="n">count</span><span class="p">,</span> <span class="n">sep</span><span class="o">=</span><span class="n">sep</span><span class="p">))</span>


<span class="nd">@util</span><span class="o">.</span><span class="n">_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">eye</span><span class="p">(</span><span class="n">N</span><span class="p">:</span> <span class="n">DimSize</span><span class="p">,</span> <span class="n">M</span><span class="p">:</span> <span class="n">DimSize</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">k</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
        <span class="n">dtype</span><span class="p">:</span> <span class="n">DTypeLike</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Array</span><span class="p">:</span>
  <span class="n">dtypes</span><span class="o">.</span><span class="n">check_user_dtype_supported</span><span class="p">(</span><span class="n">dtype</span><span class="p">,</span> <span class="s2">&quot;eye&quot;</span><span class="p">)</span>
  <span class="n">N_int</span> <span class="o">=</span> <span class="n">core</span><span class="o">.</span><span class="n">canonicalize_dim</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="s2">&quot;&#39;N&#39; argument of jnp.eye()&quot;</span><span class="p">)</span>
  <span class="n">M_int</span> <span class="o">=</span> <span class="n">N_int</span> <span class="k">if</span> <span class="n">M</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">core</span><span class="o">.</span><span class="n">canonicalize_dim</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="s2">&quot;&#39;M&#39; argument of jnp.eye()&quot;</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">N_int</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">M_int</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;negative dimensions are not allowed, got </span><span class="si">{</span><span class="n">N</span><span class="si">}</span><span class="s2"> and </span><span class="si">{</span><span class="n">M</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
  <span class="n">k</span> <span class="o">=</span> <span class="n">operator</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">lax_internal</span><span class="o">.</span><span class="n">_eye</span><span class="p">(</span><span class="n">_jnp_dtype</span><span class="p">(</span><span class="n">dtype</span><span class="p">),</span> <span class="p">(</span><span class="n">N_int</span><span class="p">,</span> <span class="n">M_int</span><span class="p">),</span> <span class="n">k</span><span class="p">)</span>


<span class="nd">@util</span><span class="o">.</span><span class="n">_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">identity</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">identity</span><span class="p">(</span><span class="n">n</span><span class="p">:</span> <span class="n">DimSize</span><span class="p">,</span> <span class="n">dtype</span><span class="p">:</span> <span class="n">DTypeLike</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Array</span><span class="p">:</span>
  <span class="n">dtypes</span><span class="o">.</span><span class="n">check_user_dtype_supported</span><span class="p">(</span><span class="n">dtype</span><span class="p">,</span> <span class="s2">&quot;identity&quot;</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">eye</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>


<span class="nd">@util</span><span class="o">.</span><span class="n">_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">arange</span><span class="p">(</span><span class="n">start</span><span class="p">:</span> <span class="n">DimSize</span><span class="p">,</span> <span class="n">stop</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">DimSize</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
           <span class="n">step</span><span class="p">:</span> <span class="n">DimSize</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">dtype</span><span class="p">:</span> <span class="n">DTypeLike</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Array</span><span class="p">:</span>
  <span class="n">dtypes</span><span class="o">.</span><span class="n">check_user_dtype_supported</span><span class="p">(</span><span class="n">dtype</span><span class="p">,</span> <span class="s2">&quot;arange&quot;</span><span class="p">)</span>
  <span class="k">if</span> <span class="ow">not</span> <span class="n">jax</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">jax_dynamic_shapes</span><span class="p">:</span>
    <span class="n">util</span><span class="o">.</span><span class="n">check_arraylike</span><span class="p">(</span><span class="s2">&quot;arange&quot;</span><span class="p">,</span> <span class="n">start</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">stop</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">step</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
      <span class="n">start</span> <span class="o">=</span> <span class="n">core</span><span class="o">.</span><span class="n">concrete_or_error</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="s2">&quot;It arose in the jnp.arange argument &#39;stop&#39;&quot;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="n">start</span> <span class="o">=</span> <span class="n">core</span><span class="o">.</span><span class="n">concrete_or_error</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="s2">&quot;It arose in the jnp.arange argument &#39;start&#39;&quot;</span><span class="p">)</span>
  <span class="n">util</span><span class="o">.</span><span class="n">check_arraylike_or_none</span><span class="p">(</span><span class="s2">&quot;arange&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="n">step</span><span class="p">)</span>
  <span class="n">stop</span> <span class="o">=</span> <span class="n">core</span><span class="o">.</span><span class="n">concrete_or_error</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="s2">&quot;It arose in the jnp.arange argument &#39;stop&#39;&quot;</span><span class="p">)</span>
  <span class="n">step</span> <span class="o">=</span> <span class="n">core</span><span class="o">.</span><span class="n">concrete_or_error</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="n">step</span><span class="p">,</span> <span class="s2">&quot;It arose in the jnp.arange argument &#39;step&#39;&quot;</span><span class="p">)</span>
  <span class="n">start_name</span> <span class="o">=</span> <span class="s2">&quot;stop&quot;</span> <span class="k">if</span> <span class="n">stop</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">step</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="s2">&quot;start&quot;</span>
  <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="p">[(</span><span class="n">start_name</span><span class="p">,</span> <span class="n">start</span><span class="p">),</span> <span class="p">(</span><span class="s2">&quot;stop&quot;</span><span class="p">,</span> <span class="n">stop</span><span class="p">),</span> <span class="p">(</span><span class="s2">&quot;step&quot;</span><span class="p">,</span> <span class="n">step</span><span class="p">)]:</span>
    <span class="k">if</span> <span class="n">val</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">ndim</span><span class="p">(</span><span class="n">val</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
      <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;jax.numpy.arange: arguments must be scalars; got </span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2">=</span><span class="si">{</span><span class="n">val</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
  <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">core</span><span class="o">.</span><span class="n">is_symbolic_dim</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="n">step</span><span class="p">)):</span>
    <span class="c1"># Some dynamic shapes</span>
    <span class="k">if</span> <span class="n">stop</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">step</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
      <span class="n">stop</span> <span class="o">=</span> <span class="n">start</span>
      <span class="n">start</span> <span class="o">=</span> <span class="mi">0</span>
      <span class="n">step</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="k">elif</span> <span class="n">stop</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">step</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
      <span class="n">step</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="k">return</span> <span class="n">_arange_dynamic</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="n">step</span><span class="p">,</span> <span class="n">dtype</span> <span class="ow">or</span> <span class="n">dtypes</span><span class="o">.</span><span class="n">canonicalize_dtype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">))</span>
  <span class="k">if</span> <span class="n">dtype</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
    <span class="n">dtype</span> <span class="o">=</span> <span class="n">result_type</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="o">*</span><span class="p">(</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="p">[</span><span class="n">stop</span><span class="p">,</span> <span class="n">step</span><span class="p">]</span> <span class="k">if</span> <span class="n">x</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">))</span>
  <span class="n">dtype</span> <span class="o">=</span> <span class="n">_jnp_dtype</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">stop</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">step</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
    <span class="n">start_dtype</span> <span class="o">=</span> <span class="n">_dtype</span><span class="p">(</span><span class="n">start</span><span class="p">)</span>
    <span class="k">if</span> <span class="p">(</span><span class="ow">not</span> <span class="n">dtypes</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="n">start_dtype</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">integer</span><span class="p">)</span> <span class="ow">and</span>
        <span class="ow">not</span> <span class="n">dtypes</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="n">start_dtype</span><span class="p">,</span> <span class="n">dtypes</span><span class="o">.</span><span class="n">extended</span><span class="p">)):</span>
      <span class="n">ceil_</span> <span class="o">=</span> <span class="n">ufuncs</span><span class="o">.</span><span class="n">ceil</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">core</span><span class="o">.</span><span class="n">Tracer</span><span class="p">)</span> <span class="k">else</span> <span class="n">np</span><span class="o">.</span><span class="n">ceil</span>
      <span class="n">start</span> <span class="o">=</span> <span class="n">ceil_</span><span class="p">(</span><span class="n">start</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>  <span class="c1"># type: ignore</span>
    <span class="k">return</span> <span class="n">lax</span><span class="o">.</span><span class="n">iota</span><span class="p">(</span><span class="n">dtype</span><span class="p">,</span> <span class="n">start</span><span class="p">)</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="k">if</span> <span class="n">step</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">start</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">stop</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
      <span class="n">stop</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">stop</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
      <span class="k">return</span> <span class="n">lax</span><span class="o">.</span><span class="n">iota</span><span class="p">(</span><span class="n">dtype</span><span class="p">,</span> <span class="n">stop</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">array</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="o">=</span><span class="n">stop</span><span class="p">,</span> <span class="n">step</span><span class="o">=</span><span class="n">step</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">))</span>


<span class="k">def</span> <span class="nf">_arange_dynamic</span><span class="p">(</span>
    <span class="n">start</span><span class="p">:</span> <span class="n">DimSize</span><span class="p">,</span> <span class="n">stop</span><span class="p">:</span> <span class="n">DimSize</span><span class="p">,</span> <span class="n">step</span><span class="p">:</span> <span class="n">DimSize</span><span class="p">,</span> <span class="n">dtype</span><span class="p">:</span> <span class="n">DTypeLike</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Array</span><span class="p">:</span>
  <span class="c1"># Here if at least one of start, stop, step are dynamic.</span>
  <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="ow">not</span> <span class="n">core</span><span class="o">.</span><span class="n">is_dim</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="n">step</span><span class="p">)):</span>
    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
        <span class="s2">&quot;In arange with non-constant arguments all of start, stop, and step &quot;</span>
        <span class="sa">f</span><span class="s2">&quot;must be either dimension expressions or integers: start=</span><span class="si">{</span><span class="n">start</span><span class="si">}</span><span class="s2">, &quot;</span>
        <span class="sa">f</span><span class="s2">&quot;stop=</span><span class="si">{</span><span class="n">stop</span><span class="si">}</span><span class="s2">, step=</span><span class="si">{</span><span class="n">step</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
  <span class="c1"># Must resolve statically if step is {&lt;0, ==0, &gt;0}</span>
  <span class="k">try</span><span class="p">:</span>
    <span class="k">if</span> <span class="n">step</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
      <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;arange has step == 0&quot;</span><span class="p">)</span>
    <span class="n">step_gt_0</span> <span class="o">=</span> <span class="p">(</span><span class="n">step</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
  <span class="k">except</span> <span class="n">core</span><span class="o">.</span><span class="n">InconclusiveDimensionOperation</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
    <span class="k">raise</span> <span class="n">core</span><span class="o">.</span><span class="n">InconclusiveDimensionOperation</span><span class="p">(</span>
        <span class="sa">f</span><span class="s2">&quot;In arange with non-constant arguments the step (</span><span class="si">{</span><span class="n">step</span><span class="si">}</span><span class="s2">) must &quot;</span> <span class="o">+</span>
        <span class="sa">f</span><span class="s2">&quot;be resolved statically if it is &gt; 0 or &lt; 0.</span><span class="se">\n</span><span class="s2">Details: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
  <span class="n">gap</span> <span class="o">=</span> <span class="n">step</span> <span class="k">if</span> <span class="n">step_gt_0</span> <span class="k">else</span> <span class="o">-</span> <span class="n">step</span>
  <span class="n">distance</span> <span class="o">=</span> <span class="p">(</span><span class="n">stop</span> <span class="o">-</span> <span class="n">start</span><span class="p">)</span> <span class="k">if</span> <span class="n">step_gt_0</span> <span class="k">else</span> <span class="p">(</span><span class="n">start</span> <span class="o">-</span> <span class="n">stop</span><span class="p">)</span>
  <span class="n">size</span> <span class="o">=</span> <span class="n">core</span><span class="o">.</span><span class="n">non_negative_dim</span><span class="p">(</span><span class="n">distance</span> <span class="o">+</span> <span class="n">gap</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">//</span> <span class="n">gap</span>
  <span class="k">return</span> <span class="p">(</span><span class="n">array</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span> <span class="o">+</span>
          <span class="n">array</span><span class="p">(</span><span class="n">step</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span> <span class="o">*</span> <span class="n">lax</span><span class="o">.</span><span class="n">iota</span><span class="p">(</span><span class="n">dtype</span><span class="p">,</span> <span class="n">size</span><span class="p">))</span>

<span class="nd">@overload</span>
<span class="k">def</span> <span class="nf">linspace</span><span class="p">(</span><span class="n">start</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">,</span> <span class="n">stop</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">,</span> <span class="n">num</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">50</span><span class="p">,</span>
             <span class="n">endpoint</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">retstep</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="kc">False</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
             <span class="n">dtype</span><span class="p">:</span> <span class="n">DTypeLike</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
             <span class="n">axis</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Array</span><span class="p">:</span> <span class="o">...</span>
<span class="nd">@overload</span>
<span class="k">def</span> <span class="nf">linspace</span><span class="p">(</span><span class="n">start</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">,</span> <span class="n">stop</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">,</span> <span class="n">num</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
             <span class="n">endpoint</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span> <span class="n">retstep</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="kc">True</span><span class="p">],</span>
             <span class="n">dtype</span><span class="p">:</span> <span class="n">DTypeLike</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
             <span class="n">axis</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">Array</span><span class="p">,</span> <span class="n">Array</span><span class="p">]:</span> <span class="o">...</span>
<span class="nd">@overload</span>
<span class="k">def</span> <span class="nf">linspace</span><span class="p">(</span><span class="n">start</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">,</span> <span class="n">stop</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">,</span> <span class="n">num</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">50</span><span class="p">,</span>
             <span class="n">endpoint</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">retstep</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="kc">True</span><span class="p">],</span>
             <span class="n">dtype</span><span class="p">:</span> <span class="n">DTypeLike</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
             <span class="n">axis</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">Array</span><span class="p">,</span> <span class="n">Array</span><span class="p">]:</span> <span class="o">...</span>
<span class="nd">@overload</span>
<span class="k">def</span> <span class="nf">linspace</span><span class="p">(</span><span class="n">start</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">,</span> <span class="n">stop</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">,</span> <span class="n">num</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">50</span><span class="p">,</span>
             <span class="n">endpoint</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">retstep</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
             <span class="n">dtype</span><span class="p">:</span> <span class="n">DTypeLike</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
             <span class="n">axis</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Array</span> <span class="o">|</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">Array</span><span class="p">,</span> <span class="n">Array</span><span class="p">]:</span> <span class="o">...</span>
<span class="nd">@util</span><span class="o">.</span><span class="n">_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">linspace</span><span class="p">(</span><span class="n">start</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">,</span> <span class="n">stop</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">,</span> <span class="n">num</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">50</span><span class="p">,</span>
             <span class="n">endpoint</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">retstep</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
             <span class="n">dtype</span><span class="p">:</span> <span class="n">DTypeLike</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
             <span class="n">axis</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Array</span> <span class="o">|</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">Array</span><span class="p">,</span> <span class="n">Array</span><span class="p">]:</span>
  <span class="n">num</span> <span class="o">=</span> <span class="n">core</span><span class="o">.</span><span class="n">concrete_or_error</span><span class="p">(</span><span class="n">operator</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">num</span><span class="p">,</span> <span class="s2">&quot;&#39;num&#39; argument of jnp.linspace&quot;</span><span class="p">)</span>
  <span class="n">axis</span> <span class="o">=</span> <span class="n">core</span><span class="o">.</span><span class="n">concrete_or_error</span><span class="p">(</span><span class="n">operator</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="s2">&quot;&#39;axis&#39; argument of jnp.linspace&quot;</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">_linspace</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="n">num</span><span class="p">,</span> <span class="n">endpoint</span><span class="p">,</span> <span class="n">retstep</span><span class="p">,</span> <span class="n">dtype</span><span class="p">,</span> <span class="n">axis</span><span class="p">)</span>

<span class="nd">@partial</span><span class="p">(</span><span class="n">jit</span><span class="p">,</span> <span class="n">static_argnames</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;num&#39;</span><span class="p">,</span> <span class="s1">&#39;endpoint&#39;</span><span class="p">,</span> <span class="s1">&#39;retstep&#39;</span><span class="p">,</span> <span class="s1">&#39;dtype&#39;</span><span class="p">,</span> <span class="s1">&#39;axis&#39;</span><span class="p">))</span>
<span class="k">def</span> <span class="nf">_linspace</span><span class="p">(</span><span class="n">start</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">,</span> <span class="n">stop</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">,</span> <span class="n">num</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">50</span><span class="p">,</span>
              <span class="n">endpoint</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">retstep</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
              <span class="n">dtype</span><span class="p">:</span> <span class="n">DTypeLike</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
              <span class="n">axis</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Array</span> <span class="o">|</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">Array</span><span class="p">,</span> <span class="n">Array</span><span class="p">]:</span>
<span class="w">  </span><span class="sd">&quot;&quot;&quot;Implementation of linspace differentiable in start and stop args.&quot;&quot;&quot;</span>
  <span class="n">dtypes</span><span class="o">.</span><span class="n">check_user_dtype_supported</span><span class="p">(</span><span class="n">dtype</span><span class="p">,</span> <span class="s2">&quot;linspace&quot;</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">num</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Number of samples, </span><span class="si">{</span><span class="n">num</span><span class="si">}</span><span class="s2">, must be non-negative.&quot;</span><span class="p">)</span>
  <span class="n">util</span><span class="o">.</span><span class="n">check_arraylike</span><span class="p">(</span><span class="s2">&quot;linspace&quot;</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">)</span>

  <span class="k">if</span> <span class="n">dtype</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
    <span class="n">dtype</span> <span class="o">=</span> <span class="n">dtypes</span><span class="o">.</span><span class="n">to_inexact_dtype</span><span class="p">(</span><span class="n">result_type</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">))</span>
  <span class="n">dtype</span> <span class="o">=</span> <span class="n">_jnp_dtype</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span>
  <span class="n">computation_dtype</span> <span class="o">=</span> <span class="n">dtypes</span><span class="o">.</span><span class="n">to_inexact_dtype</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span>
  <span class="n">start</span> <span class="o">=</span> <span class="n">asarray</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">computation_dtype</span><span class="p">)</span>
  <span class="n">stop</span> <span class="o">=</span> <span class="n">asarray</span><span class="p">(</span><span class="n">stop</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">computation_dtype</span><span class="p">)</span>

  <span class="n">bounds_shape</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">lax</span><span class="o">.</span><span class="n">broadcast_shapes</span><span class="p">(</span><span class="n">shape</span><span class="p">(</span><span class="n">start</span><span class="p">),</span> <span class="n">shape</span><span class="p">(</span><span class="n">stop</span><span class="p">)))</span>
  <span class="n">broadcast_start</span> <span class="o">=</span> <span class="n">broadcast_to</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">bounds_shape</span><span class="p">)</span>
  <span class="n">broadcast_stop</span> <span class="o">=</span> <span class="n">broadcast_to</span><span class="p">(</span><span class="n">stop</span><span class="p">,</span> <span class="n">bounds_shape</span><span class="p">)</span>
  <span class="n">axis</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">bounds_shape</span><span class="p">)</span> <span class="o">+</span> <span class="n">axis</span> <span class="o">+</span> <span class="mi">1</span> <span class="k">if</span> <span class="n">axis</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="n">axis</span>
  <span class="n">bounds_shape</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">axis</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
  <span class="n">div</span> <span class="o">=</span> <span class="p">(</span><span class="n">num</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="k">if</span> <span class="n">endpoint</span> <span class="k">else</span> <span class="n">num</span>
  <span class="k">if</span> <span class="n">num</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
    <span class="n">delta</span><span class="p">:</span> <span class="n">Array</span> <span class="o">=</span> <span class="n">lax</span><span class="o">.</span><span class="n">convert_element_type</span><span class="p">(</span><span class="n">stop</span> <span class="o">-</span> <span class="n">start</span><span class="p">,</span> <span class="n">computation_dtype</span><span class="p">)</span> <span class="o">/</span> <span class="n">div</span>
    <span class="n">iota_shape</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">bounds_shape</span><span class="p">)</span>
    <span class="n">iota_shape</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="n">div</span>
    <span class="c1"># This approach recovers the endpoints with float32 arithmetic,</span>
    <span class="c1"># but can lead to rounding errors for integer outputs.</span>
    <span class="n">real_dtype</span> <span class="o">=</span> <span class="n">finfo</span><span class="p">(</span><span class="n">computation_dtype</span><span class="p">)</span><span class="o">.</span><span class="n">dtype</span>
    <span class="n">step</span> <span class="o">=</span> <span class="n">reshape</span><span class="p">(</span><span class="n">lax</span><span class="o">.</span><span class="n">iota</span><span class="p">(</span><span class="n">real_dtype</span><span class="p">,</span> <span class="n">div</span><span class="p">),</span> <span class="n">iota_shape</span><span class="p">)</span> <span class="o">/</span> <span class="n">div</span>
    <span class="n">step</span> <span class="o">=</span> <span class="n">step</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">computation_dtype</span><span class="p">)</span>
    <span class="n">out</span> <span class="o">=</span> <span class="p">(</span><span class="n">reshape</span><span class="p">(</span><span class="n">broadcast_start</span><span class="p">,</span> <span class="n">bounds_shape</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">step</span><span class="p">)</span> <span class="o">+</span>
      <span class="n">reshape</span><span class="p">(</span><span class="n">broadcast_stop</span><span class="p">,</span> <span class="n">bounds_shape</span><span class="p">)</span> <span class="o">*</span> <span class="n">step</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">endpoint</span><span class="p">:</span>
      <span class="n">out</span> <span class="o">=</span> <span class="n">lax</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">out</span><span class="p">,</span> <span class="n">lax</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">(</span><span class="n">broadcast_stop</span><span class="p">,</span> <span class="p">(</span><span class="n">axis</span><span class="p">,))],</span>
                            <span class="n">_canonicalize_axis</span><span class="p">(</span><span class="n">axis</span><span class="p">,</span> <span class="n">out</span><span class="o">.</span><span class="n">ndim</span><span class="p">))</span>

  <span class="k">elif</span> <span class="n">num</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
    <span class="n">delta</span> <span class="o">=</span> <span class="n">asarray</span><span class="p">(</span><span class="n">nan</span> <span class="k">if</span> <span class="n">endpoint</span> <span class="k">else</span> <span class="n">stop</span> <span class="o">-</span> <span class="n">start</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">computation_dtype</span><span class="p">)</span>
    <span class="n">out</span> <span class="o">=</span> <span class="n">reshape</span><span class="p">(</span><span class="n">broadcast_start</span><span class="p">,</span> <span class="n">bounds_shape</span><span class="p">)</span>
  <span class="k">else</span><span class="p">:</span> <span class="c1"># num == 0 degenerate case, match numpy behavior</span>
    <span class="n">empty_shape</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">lax</span><span class="o">.</span><span class="n">broadcast_shapes</span><span class="p">(</span><span class="n">shape</span><span class="p">(</span><span class="n">start</span><span class="p">),</span> <span class="n">shape</span><span class="p">(</span><span class="n">stop</span><span class="p">)))</span>
    <span class="n">empty_shape</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">axis</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">delta</span> <span class="o">=</span> <span class="n">asarray</span><span class="p">(</span><span class="n">nan</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">computation_dtype</span><span class="p">)</span>
    <span class="n">out</span> <span class="o">=</span> <span class="n">reshape</span><span class="p">(</span><span class="n">array</span><span class="p">([],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">),</span> <span class="n">empty_shape</span><span class="p">)</span>

  <span class="k">if</span> <span class="n">issubdtype</span><span class="p">(</span><span class="n">dtype</span><span class="p">,</span> <span class="n">integer</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">issubdtype</span><span class="p">(</span><span class="n">out</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">integer</span><span class="p">):</span>
    <span class="n">out</span> <span class="o">=</span> <span class="n">lax</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">out</span><span class="p">)</span>

  <span class="k">if</span> <span class="n">retstep</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">lax</span><span class="o">.</span><span class="n">convert_element_type</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="n">dtype</span><span class="p">),</span> <span class="n">delta</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">lax</span><span class="o">.</span><span class="n">convert_element_type</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="n">dtype</span><span class="p">)</span>


<span class="nd">@util</span><span class="o">.</span><span class="n">_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">logspace</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">logspace</span><span class="p">(</span><span class="n">start</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">,</span> <span class="n">stop</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">,</span> <span class="n">num</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">50</span><span class="p">,</span>
             <span class="n">endpoint</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">base</span><span class="p">:</span> <span class="n">ArrayLike</span> <span class="o">=</span> <span class="mf">10.0</span><span class="p">,</span>
             <span class="n">dtype</span><span class="p">:</span> <span class="n">DTypeLike</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">axis</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Array</span><span class="p">:</span>
  <span class="n">num</span> <span class="o">=</span> <span class="n">core</span><span class="o">.</span><span class="n">concrete_or_error</span><span class="p">(</span><span class="n">operator</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">num</span><span class="p">,</span> <span class="s2">&quot;&#39;num&#39; argument of jnp.logspace&quot;</span><span class="p">)</span>
  <span class="n">axis</span> <span class="o">=</span> <span class="n">core</span><span class="o">.</span><span class="n">concrete_or_error</span><span class="p">(</span><span class="n">operator</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="s2">&quot;&#39;axis&#39; argument of jnp.logspace&quot;</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">_logspace</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="n">num</span><span class="p">,</span> <span class="n">endpoint</span><span class="p">,</span> <span class="n">base</span><span class="p">,</span> <span class="n">dtype</span><span class="p">,</span> <span class="n">axis</span><span class="p">)</span>

<span class="nd">@partial</span><span class="p">(</span><span class="n">jit</span><span class="p">,</span> <span class="n">static_argnames</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;num&#39;</span><span class="p">,</span> <span class="s1">&#39;endpoint&#39;</span><span class="p">,</span> <span class="s1">&#39;dtype&#39;</span><span class="p">,</span> <span class="s1">&#39;axis&#39;</span><span class="p">))</span>
<span class="k">def</span> <span class="nf">_logspace</span><span class="p">(</span><span class="n">start</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">,</span> <span class="n">stop</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">,</span> <span class="n">num</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">50</span><span class="p">,</span>
              <span class="n">endpoint</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">base</span><span class="p">:</span> <span class="n">ArrayLike</span> <span class="o">=</span> <span class="mf">10.0</span><span class="p">,</span>
              <span class="n">dtype</span><span class="p">:</span> <span class="n">DTypeLike</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">axis</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Array</span><span class="p">:</span>
<span class="w">  </span><span class="sd">&quot;&quot;&quot;Implementation of logspace differentiable in start and stop args.&quot;&quot;&quot;</span>
  <span class="n">dtypes</span><span class="o">.</span><span class="n">check_user_dtype_supported</span><span class="p">(</span><span class="n">dtype</span><span class="p">,</span> <span class="s2">&quot;logspace&quot;</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">dtype</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
    <span class="n">dtype</span> <span class="o">=</span> <span class="n">dtypes</span><span class="o">.</span><span class="n">to_inexact_dtype</span><span class="p">(</span><span class="n">result_type</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">))</span>
  <span class="n">dtype</span> <span class="o">=</span> <span class="n">_jnp_dtype</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span>
  <span class="n">computation_dtype</span> <span class="o">=</span> <span class="n">dtypes</span><span class="o">.</span><span class="n">to_inexact_dtype</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span>
  <span class="n">util</span><span class="o">.</span><span class="n">check_arraylike</span><span class="p">(</span><span class="s2">&quot;logspace&quot;</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">)</span>
  <span class="n">start</span> <span class="o">=</span> <span class="n">asarray</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">computation_dtype</span><span class="p">)</span>
  <span class="n">stop</span> <span class="o">=</span> <span class="n">asarray</span><span class="p">(</span><span class="n">stop</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">computation_dtype</span><span class="p">)</span>
  <span class="n">lin</span> <span class="o">=</span> <span class="n">linspace</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="n">num</span><span class="p">,</span>
                 <span class="n">endpoint</span><span class="o">=</span><span class="n">endpoint</span><span class="p">,</span> <span class="n">retstep</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">lax</span><span class="o">.</span><span class="n">convert_element_type</span><span class="p">(</span><span class="n">ufuncs</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">lin</span><span class="p">),</span> <span class="n">dtype</span><span class="p">)</span>


<span class="nd">@util</span><span class="o">.</span><span class="n">_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">geomspace</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">geomspace</span><span class="p">(</span><span class="n">start</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">,</span> <span class="n">stop</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">,</span> <span class="n">num</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">50</span><span class="p">,</span> <span class="n">endpoint</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
              <span class="n">dtype</span><span class="p">:</span> <span class="n">DTypeLike</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">axis</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Array</span><span class="p">:</span>
  <span class="n">num</span> <span class="o">=</span> <span class="n">core</span><span class="o">.</span><span class="n">concrete_or_error</span><span class="p">(</span><span class="n">operator</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">num</span><span class="p">,</span> <span class="s2">&quot;&#39;num&#39; argument of jnp.geomspace&quot;</span><span class="p">)</span>
  <span class="n">axis</span> <span class="o">=</span> <span class="n">core</span><span class="o">.</span><span class="n">concrete_or_error</span><span class="p">(</span><span class="n">operator</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="s2">&quot;&#39;axis&#39; argument of jnp.geomspace&quot;</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">_geomspace</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="n">num</span><span class="p">,</span> <span class="n">endpoint</span><span class="p">,</span> <span class="n">dtype</span><span class="p">,</span> <span class="n">axis</span><span class="p">)</span>

<span class="nd">@partial</span><span class="p">(</span><span class="n">jit</span><span class="p">,</span> <span class="n">static_argnames</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;num&#39;</span><span class="p">,</span> <span class="s1">&#39;endpoint&#39;</span><span class="p">,</span> <span class="s1">&#39;dtype&#39;</span><span class="p">,</span> <span class="s1">&#39;axis&#39;</span><span class="p">))</span>
<span class="k">def</span> <span class="nf">_geomspace</span><span class="p">(</span><span class="n">start</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">,</span> <span class="n">stop</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">,</span> <span class="n">num</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">50</span><span class="p">,</span> <span class="n">endpoint</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
               <span class="n">dtype</span><span class="p">:</span> <span class="n">DTypeLike</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">axis</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Array</span><span class="p">:</span>
<span class="w">  </span><span class="sd">&quot;&quot;&quot;Implementation of geomspace differentiable in start and stop args.&quot;&quot;&quot;</span>
  <span class="n">dtypes</span><span class="o">.</span><span class="n">check_user_dtype_supported</span><span class="p">(</span><span class="n">dtype</span><span class="p">,</span> <span class="s2">&quot;geomspace&quot;</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">dtype</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
    <span class="n">dtype</span> <span class="o">=</span> <span class="n">dtypes</span><span class="o">.</span><span class="n">to_inexact_dtype</span><span class="p">(</span><span class="n">result_type</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">))</span>
  <span class="n">dtype</span> <span class="o">=</span> <span class="n">_jnp_dtype</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span>
  <span class="n">computation_dtype</span> <span class="o">=</span> <span class="n">dtypes</span><span class="o">.</span><span class="n">to_inexact_dtype</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span>
  <span class="n">util</span><span class="o">.</span><span class="n">check_arraylike</span><span class="p">(</span><span class="s2">&quot;geomspace&quot;</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">)</span>
  <span class="n">start</span> <span class="o">=</span> <span class="n">asarray</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">computation_dtype</span><span class="p">)</span>
  <span class="n">stop</span> <span class="o">=</span> <span class="n">asarray</span><span class="p">(</span><span class="n">stop</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">computation_dtype</span><span class="p">)</span>
  <span class="c1"># follow the numpy geomspace convention for negative and complex endpoints</span>
  <span class="n">signflip</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">ufuncs</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">ufuncs</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">start</span><span class="p">)))</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">ufuncs</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">ufuncs</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">stop</span><span class="p">)))</span> <span class="o">//</span> <span class="mi">2</span>
  <span class="n">signflip</span> <span class="o">=</span> <span class="n">signflip</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">computation_dtype</span><span class="p">)</span>
  <span class="n">res</span> <span class="o">=</span> <span class="n">signflip</span> <span class="o">*</span> <span class="n">logspace</span><span class="p">(</span><span class="n">ufuncs</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">signflip</span> <span class="o">*</span> <span class="n">start</span><span class="p">),</span>
                            <span class="n">ufuncs</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">signflip</span> <span class="o">*</span> <span class="n">stop</span><span class="p">),</span> <span class="n">num</span><span class="p">,</span>
                            <span class="n">endpoint</span><span class="o">=</span><span class="n">endpoint</span><span class="p">,</span> <span class="n">base</span><span class="o">=</span><span class="mf">10.0</span><span class="p">,</span>
                            <span class="n">dtype</span><span class="o">=</span><span class="n">computation_dtype</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">axis</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
    <span class="n">res</span> <span class="o">=</span> <span class="n">moveaxis</span><span class="p">(</span><span class="n">res</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">axis</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">lax</span><span class="o">.</span><span class="n">convert_element_type</span><span class="p">(</span><span class="n">res</span><span class="p">,</span> <span class="n">dtype</span><span class="p">)</span>


<span class="nd">@util</span><span class="o">.</span><span class="n">_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">,</span> <span class="n">lax_description</span><span class="o">=</span><span class="n">_ARRAY_VIEW_DOC</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">meshgrid</span><span class="p">(</span><span class="o">*</span><span class="n">xi</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">,</span> <span class="n">copy</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">sparse</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
             <span class="n">indexing</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;xy&#39;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="n">Array</span><span class="p">]:</span>
  <span class="n">util</span><span class="o">.</span><span class="n">check_arraylike</span><span class="p">(</span><span class="s2">&quot;meshgrid&quot;</span><span class="p">,</span> <span class="o">*</span><span class="n">xi</span><span class="p">)</span>
  <span class="n">args</span> <span class="o">=</span> <span class="p">[</span><span class="n">asarray</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">xi</span><span class="p">]</span>
  <span class="k">if</span> <span class="ow">not</span> <span class="n">copy</span><span class="p">:</span>
    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;jax.numpy.meshgrid only supports copy=True&quot;</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">indexing</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;xy&quot;</span><span class="p">,</span> <span class="s2">&quot;ij&quot;</span><span class="p">]:</span>
    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Valid values for indexing are &#39;xy&#39; and &#39;ij&#39;, got </span><span class="si">{</span><span class="n">indexing</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
  <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">1</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">args</span><span class="p">):</span>
    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Arguments to jax.numpy.meshgrid must be 1D, got shapes &quot;</span>
                     <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="p">[</span><span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">in</span><span class="w"> </span><span class="n">args</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">indexing</span> <span class="o">==</span> <span class="s2">&quot;xy&quot;</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="p">:</span>
    <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
  <span class="n">shape</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span> <span class="k">if</span> <span class="n">sparse</span> <span class="k">else</span> <span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">args</span><span class="p">]</span>
  <span class="n">_a_shape</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">i</span><span class="p">,</span> <span class="n">a</span><span class="p">:</span> <span class="p">[</span><span class="o">*</span><span class="n">shape</span><span class="p">[:</span><span class="n">i</span><span class="p">],</span> <span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="o">*</span><span class="n">shape</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:]]</span> <span class="k">if</span> <span class="n">sparse</span> <span class="k">else</span> <span class="n">shape</span>
  <span class="n">output</span> <span class="o">=</span> <span class="p">[</span><span class="n">lax</span><span class="o">.</span><span class="n">broadcast_in_dim</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">_a_shape</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">a</span><span class="p">),</span> <span class="p">(</span><span class="n">i</span><span class="p">,))</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">args</span><span class="p">)]</span>
  <span class="k">if</span> <span class="n">indexing</span> <span class="o">==</span> <span class="s2">&quot;xy&quot;</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="p">:</span>
    <span class="n">output</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">output</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">output</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">output</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
  <span class="k">return</span> <span class="n">output</span>


<span class="nd">@util</span><span class="o">.</span><span class="n">_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">i0</span><span class="p">)</span>
<span class="nd">@jit</span>
<span class="k">def</span> <span class="nf">i0</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Array</span><span class="p">:</span>
  <span class="n">x_arr</span><span class="p">,</span> <span class="o">=</span> <span class="n">util</span><span class="o">.</span><span class="n">promote_args_inexact</span><span class="p">(</span><span class="s2">&quot;i0&quot;</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
  <span class="k">if</span> <span class="ow">not</span> <span class="n">issubdtype</span><span class="p">(</span><span class="n">x_arr</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">floating</span><span class="p">):</span>
    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Unsupported input type to jax.numpy.i0: </span><span class="si">{</span><span class="n">_dtype</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
  <span class="n">x_arr</span> <span class="o">=</span> <span class="n">lax</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">x_arr</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">lax</span><span class="o">.</span><span class="n">mul</span><span class="p">(</span><span class="n">lax</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">x_arr</span><span class="p">),</span> <span class="n">lax</span><span class="o">.</span><span class="n">bessel_i0e</span><span class="p">(</span><span class="n">x_arr</span><span class="p">))</span>


<span class="nd">@util</span><span class="o">.</span><span class="n">_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ix_</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">ix_</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">Array</span><span class="p">,</span> <span class="o">...</span><span class="p">]:</span>
  <span class="n">util</span><span class="o">.</span><span class="n">check_arraylike</span><span class="p">(</span><span class="s2">&quot;ix&quot;</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>
  <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>
  <span class="n">output</span> <span class="o">=</span> <span class="p">[]</span>
  <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">a</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">args</span><span class="p">):</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">asarray</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
      <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;Arguments to jax.numpy.ix_ must be 1-dimensional, got shape </span><span class="si">{}</span><span class="s2">&quot;</span>
      <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">_dtype</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">==</span> <span class="n">bool_</span><span class="p">:</span>
      <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
        <span class="s2">&quot;Boolean arguments to jax.numpy.ix_ are not implemented&quot;</span><span class="p">)</span>
    <span class="n">shape</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">n</span>
    <span class="n">shape</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
      <span class="c1"># Numpy uses an integer index type for empty arrays.</span>
      <span class="n">output</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">lax</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="n">shape</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((),</span> <span class="n">np</span><span class="o">.</span><span class="n">intp</span><span class="p">)))</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="n">output</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">lax</span><span class="o">.</span><span class="n">broadcast_in_dim</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">shape</span><span class="p">,</span> <span class="p">(</span><span class="n">i</span><span class="p">,)))</span>
  <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">output</span><span class="p">)</span>


<span class="nd">@overload</span>
<span class="k">def</span> <span class="nf">indices</span><span class="p">(</span><span class="n">dimensions</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">dtype</span><span class="p">:</span> <span class="n">DTypeLike</span> <span class="o">=</span> <span class="n">int32</span><span class="p">,</span>
            <span class="n">sparse</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="kc">False</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Array</span><span class="p">:</span> <span class="o">...</span>
<span class="nd">@overload</span>
<span class="k">def</span> <span class="nf">indices</span><span class="p">(</span><span class="n">dimensions</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">dtype</span><span class="p">:</span> <span class="n">DTypeLike</span> <span class="o">=</span> <span class="n">int32</span><span class="p">,</span>
            <span class="o">*</span><span class="p">,</span> <span class="n">sparse</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="kc">True</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">Array</span><span class="p">,</span> <span class="o">...</span><span class="p">]:</span> <span class="o">...</span>
<span class="nd">@overload</span>
<span class="k">def</span> <span class="nf">indices</span><span class="p">(</span><span class="n">dimensions</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">dtype</span><span class="p">:</span> <span class="n">DTypeLike</span> <span class="o">=</span> <span class="n">int32</span><span class="p">,</span>
            <span class="n">sparse</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Array</span> <span class="o">|</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">Array</span><span class="p">,</span> <span class="o">...</span><span class="p">]:</span> <span class="o">...</span>
<span class="nd">@util</span><span class="o">.</span><span class="n">_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">indices</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">indices</span><span class="p">(</span><span class="n">dimensions</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">dtype</span><span class="p">:</span> <span class="n">DTypeLike</span> <span class="o">=</span> <span class="n">int32</span><span class="p">,</span>
            <span class="n">sparse</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Array</span> <span class="o">|</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">Array</span><span class="p">,</span> <span class="o">...</span><span class="p">]:</span>
  <span class="n">dimensions</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span>
      <span class="n">core</span><span class="o">.</span><span class="n">concrete_or_error</span><span class="p">(</span><span class="n">operator</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="s2">&quot;dimensions argument of jnp.indices&quot;</span><span class="p">)</span>
      <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">dimensions</span><span class="p">)</span>
  <span class="n">N</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">dimensions</span><span class="p">)</span>
  <span class="n">output</span> <span class="o">=</span> <span class="p">[]</span>
  <span class="n">s</span> <span class="o">=</span> <span class="n">dimensions</span>
  <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">dim</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">dimensions</span><span class="p">):</span>
    <span class="n">idx</span> <span class="o">=</span> <span class="n">lax</span><span class="o">.</span><span class="n">iota</span><span class="p">(</span><span class="n">dtype</span><span class="p">,</span> <span class="n">dim</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">sparse</span><span class="p">:</span>
      <span class="n">s</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,)</span><span class="o">*</span><span class="n">i</span> <span class="o">+</span> <span class="p">(</span><span class="n">dim</span><span class="p">,)</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span><span class="p">,)</span><span class="o">*</span><span class="p">(</span><span class="n">N</span> <span class="o">-</span> <span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">output</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">lax</span><span class="o">.</span><span class="n">broadcast_in_dim</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="p">(</span><span class="n">i</span><span class="p">,)))</span>
  <span class="k">if</span> <span class="n">sparse</span><span class="p">:</span>
    <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">output</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">stack</span><span class="p">(</span><span class="n">output</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="k">if</span> <span class="n">output</span> <span class="k">else</span> <span class="n">array</span><span class="p">([],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>


<span class="n">_TOTAL_REPEAT_LENGTH_DOC</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span><span class="se">\</span>
<span class="s2">JAX adds the optional `total_repeat_length` parameter which specifies the total</span>
<span class="s2">number of repeat, and defaults to sum(repeats). It must be specified for repeat</span>
<span class="s2">to be compilable. If `sum(repeats)` is larger than the specified</span>
<span class="s2">`total_repeat_length` the remaining values will be discarded. In the case of</span>
<span class="s2">`sum(repeats)` being smaller than the specified target length, the final value</span>
<span class="s2">will be repeated.</span>
<span class="s2">&quot;&quot;&quot;</span>


<span class="nd">@util</span><span class="o">.</span><span class="n">_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">,</span> <span class="n">lax_description</span><span class="o">=</span><span class="n">_TOTAL_REPEAT_LENGTH_DOC</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">repeat</span><span class="p">(</span><span class="n">a</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">,</span> <span class="n">repeats</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">,</span> <span class="n">axis</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span>
           <span class="n">total_repeat_length</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Array</span><span class="p">:</span>
  <span class="n">util</span><span class="o">.</span><span class="n">check_arraylike</span><span class="p">(</span><span class="s2">&quot;repeat&quot;</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
  <span class="n">core</span><span class="o">.</span><span class="n">is_dim</span><span class="p">(</span><span class="n">repeats</span><span class="p">)</span> <span class="ow">or</span> <span class="n">util</span><span class="o">.</span><span class="n">check_arraylike</span><span class="p">(</span><span class="s2">&quot;repeat&quot;</span><span class="p">,</span> <span class="n">repeats</span><span class="p">)</span>

  <span class="k">if</span> <span class="n">axis</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">ravel</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="n">axis</span> <span class="o">=</span> <span class="mi">0</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">asarray</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>

  <span class="n">axis</span> <span class="o">=</span> <span class="n">core</span><span class="o">.</span><span class="n">concrete_or_error</span><span class="p">(</span><span class="n">operator</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="s2">&quot;&#39;axis&#39; argument of jnp.repeat()&quot;</span><span class="p">)</span>
  <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">axis</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span>  <span class="c1"># to appease mypy</span>

  <span class="k">if</span> <span class="n">core</span><span class="o">.</span><span class="n">is_symbolic_dim</span><span class="p">(</span><span class="n">repeats</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">total_repeat_length</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
      <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;jnp.repeat with a non-constant `repeats` is supported only &quot;</span>
                       <span class="sa">f</span><span class="s2">&quot;when `total_repeat_length` is None. (</span><span class="si">{</span><span class="n">repeats</span><span class="si">=}</span><span class="s2"> </span><span class="si">{</span><span class="n">total_repeat_length</span><span class="si">=}</span><span class="s2">)&quot;</span><span class="p">)</span>

  <span class="c1"># If total_repeat_length is not given, use a default.</span>
  <span class="k">if</span> <span class="n">total_repeat_length</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
    <span class="n">repeats</span> <span class="o">=</span> <span class="n">core</span><span class="o">.</span><span class="n">concrete_or_error</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="n">repeats</span><span class="p">,</span>
      <span class="s2">&quot;When jit-compiling jnp.repeat, the total number of repeats must be static. &quot;</span>
      <span class="s2">&quot;To fix this, either specify a static value for `repeats`, or pass a static &quot;</span>
      <span class="s2">&quot;value to `total_repeat_length`.&quot;</span><span class="p">)</span>

    <span class="c1"># Fast path for when repeats is a scalar.</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">ndim</span><span class="p">(</span><span class="n">repeats</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">ndim</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
      <span class="n">input_shape</span> <span class="o">=</span> <span class="n">shape</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
      <span class="n">aux_axis</span> <span class="o">=</span> <span class="n">axis</span> <span class="k">if</span> <span class="n">axis</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="n">axis</span> <span class="o">+</span> <span class="mi">1</span>
      <span class="n">a</span> <span class="o">=</span> <span class="n">expand_dims</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">aux_axis</span><span class="p">)</span>
      <span class="n">reps</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">DimSize</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">shape</span><span class="p">(</span><span class="n">a</span><span class="p">))</span>
      <span class="n">reps</span><span class="p">[</span><span class="n">aux_axis</span><span class="p">]</span> <span class="o">=</span> <span class="n">repeats</span>
      <span class="n">a</span> <span class="o">=</span> <span class="n">tile</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">reps</span><span class="p">)</span>
      <span class="n">result_shape</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">DimSize</span><span class="p">]</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">input_shape</span><span class="p">)</span>
      <span class="n">result_shape</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">*=</span> <span class="n">repeats</span>
      <span class="k">return</span> <span class="n">reshape</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">result_shape</span><span class="p">)</span>

    <span class="n">repeats</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ravel</span><span class="p">(</span><span class="n">repeats</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">ndim</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
      <span class="n">repeats</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">broadcast_to</span><span class="p">(</span><span class="n">repeats</span><span class="p">,</span> <span class="p">[</span><span class="n">shape</span><span class="p">(</span><span class="n">a</span><span class="p">)[</span><span class="n">axis</span><span class="p">]])</span>
    <span class="n">total_repeat_length</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">repeats</span><span class="p">)</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="n">repeats</span> <span class="o">=</span> <span class="n">ravel</span><span class="p">(</span><span class="n">repeats</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">ndim</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
      <span class="n">repeats</span> <span class="o">=</span> <span class="n">broadcast_to</span><span class="p">(</span><span class="n">repeats</span><span class="p">,</span> <span class="p">[</span><span class="n">shape</span><span class="p">(</span><span class="n">a</span><span class="p">)[</span><span class="n">axis</span><span class="p">]])</span>

  <span class="c1"># Special case when a is a scalar.</span>
  <span class="k">if</span> <span class="n">ndim</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
    <span class="k">if</span> <span class="n">shape</span><span class="p">(</span><span class="n">repeats</span><span class="p">)</span> <span class="o">==</span> <span class="p">(</span><span class="mi">1</span><span class="p">,):</span>
      <span class="k">return</span> <span class="n">full</span><span class="p">([</span><span class="n">total_repeat_length</span><span class="p">],</span> <span class="n">a</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;`repeat` with a scalar parameter `a` is only &#39;</span>
      <span class="s1">&#39;implemented for scalar values of the parameter `repeats`.&#39;</span><span class="p">)</span>

  <span class="c1"># Special case if total_repeat_length is zero.</span>
  <span class="k">if</span> <span class="n">total_repeat_length</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
    <span class="n">result_shape</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">shape</span><span class="p">(</span><span class="n">a</span><span class="p">))</span>
    <span class="n">result_shape</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">return</span> <span class="n">reshape</span><span class="p">(</span><span class="n">array</span><span class="p">([],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">_dtype</span><span class="p">(</span><span class="n">a</span><span class="p">)),</span> <span class="n">result_shape</span><span class="p">)</span>

  <span class="c1"># If repeats is on a zero sized axis, then return the array.</span>
  <span class="k">if</span> <span class="n">shape</span><span class="p">(</span><span class="n">a</span><span class="p">)[</span><span class="n">axis</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">asarray</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>

  <span class="c1"># This implementation of repeat avoid having to instantiate a large.</span>
  <span class="c1">#intermediate tensor.</span>

  <span class="c1"># Modify repeats from e.g. [1,2,0,5] -&gt; [0,1,2,0] for exclusive repeat.</span>
  <span class="n">exclusive_repeats</span> <span class="o">=</span> <span class="n">roll</span><span class="p">(</span><span class="n">repeats</span><span class="p">,</span> <span class="n">shift</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">at</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
  <span class="c1"># Cumsum to get indices of new number in repeated tensor, e.g. [0, 1, 3, 3]</span>
  <span class="n">scatter_indices</span> <span class="o">=</span> <span class="n">reductions</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">exclusive_repeats</span><span class="p">)</span>
  <span class="c1"># Scatter these onto a zero buffer, e.g. [1,1,0,2,0,0,0,0]</span>
  <span class="n">block_split_indicators</span> <span class="o">=</span> <span class="n">zeros</span><span class="p">([</span><span class="n">total_repeat_length</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">int32</span><span class="p">)</span>
  <span class="n">block_split_indicators</span> <span class="o">=</span> <span class="n">block_split_indicators</span><span class="o">.</span><span class="n">at</span><span class="p">[</span><span class="n">scatter_indices</span><span class="p">]</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
  <span class="c1"># Cumsum again to get scatter indices for repeat, e.g. [0,1,1,3,3,3,3,3]</span>
  <span class="n">gather_indices</span> <span class="o">=</span> <span class="n">reductions</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">block_split_indicators</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
  <span class="k">return</span> <span class="n">take</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">gather_indices</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>


<span class="nd">@util</span><span class="o">.</span><span class="n">_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">tri</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">tri</span><span class="p">(</span><span class="n">N</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">M</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">k</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">dtype</span><span class="p">:</span> <span class="n">DTypeLike</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Array</span><span class="p">:</span>
  <span class="n">dtypes</span><span class="o">.</span><span class="n">check_user_dtype_supported</span><span class="p">(</span><span class="n">dtype</span><span class="p">,</span> <span class="s2">&quot;tri&quot;</span><span class="p">)</span>
  <span class="n">M</span> <span class="o">=</span> <span class="n">M</span> <span class="k">if</span> <span class="n">M</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">N</span>
  <span class="n">dtype</span> <span class="o">=</span> <span class="n">dtype</span> <span class="ow">or</span> <span class="n">float32</span>
  <span class="k">return</span> <span class="n">lax_internal</span><span class="o">.</span><span class="n">_tri</span><span class="p">(</span><span class="n">dtype</span><span class="p">,</span> <span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">M</span><span class="p">),</span> <span class="n">k</span><span class="p">)</span>


<span class="nd">@util</span><span class="o">.</span><span class="n">_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">tril</span><span class="p">)</span>
<span class="nd">@partial</span><span class="p">(</span><span class="n">jit</span><span class="p">,</span> <span class="n">static_argnames</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;k&#39;</span><span class="p">,))</span>
<span class="k">def</span> <span class="nf">tril</span><span class="p">(</span><span class="n">m</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">,</span> <span class="n">k</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Array</span><span class="p">:</span>
  <span class="n">util</span><span class="o">.</span><span class="n">check_arraylike</span><span class="p">(</span><span class="s2">&quot;tril&quot;</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span>
  <span class="n">m_shape</span> <span class="o">=</span> <span class="n">shape</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
  <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">m_shape</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Argument to jax.numpy.tril must be at least 2D&quot;</span><span class="p">)</span>
  <span class="n">N</span><span class="p">,</span> <span class="n">M</span> <span class="o">=</span> <span class="n">m_shape</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">:]</span>
  <span class="n">mask</span> <span class="o">=</span> <span class="n">tri</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">M</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="n">k</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">lax</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="n">lax</span><span class="o">.</span><span class="n">broadcast</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">m_shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">2</span><span class="p">]),</span> <span class="n">m</span><span class="p">,</span> <span class="n">zeros_like</span><span class="p">(</span><span class="n">m</span><span class="p">))</span>


<span class="nd">@util</span><span class="o">.</span><span class="n">_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">triu</span><span class="p">,</span> <span class="n">update_doc</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="nd">@partial</span><span class="p">(</span><span class="n">jit</span><span class="p">,</span> <span class="n">static_argnames</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;k&#39;</span><span class="p">,))</span>
<span class="k">def</span> <span class="nf">triu</span><span class="p">(</span><span class="n">m</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">,</span> <span class="n">k</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Array</span><span class="p">:</span>
  <span class="n">util</span><span class="o">.</span><span class="n">check_arraylike</span><span class="p">(</span><span class="s2">&quot;triu&quot;</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span>
  <span class="n">m_shape</span> <span class="o">=</span> <span class="n">shape</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
  <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">m_shape</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Argument to jax.numpy.triu must be at least 2D&quot;</span><span class="p">)</span>
  <span class="n">N</span><span class="p">,</span> <span class="n">M</span> <span class="o">=</span> <span class="n">m_shape</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">:]</span>
  <span class="n">mask</span> <span class="o">=</span> <span class="n">tri</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">M</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="n">k</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">lax</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="n">lax</span><span class="o">.</span><span class="n">broadcast</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">m_shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">2</span><span class="p">]),</span> <span class="n">zeros_like</span><span class="p">(</span><span class="n">m</span><span class="p">),</span> <span class="n">m</span><span class="p">)</span>


<span class="nd">@util</span><span class="o">.</span><span class="n">_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">trace</span><span class="p">,</span> <span class="n">skip_params</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;out&#39;</span><span class="p">])</span>
<span class="nd">@partial</span><span class="p">(</span><span class="n">jit</span><span class="p">,</span> <span class="n">static_argnames</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;offset&#39;</span><span class="p">,</span> <span class="s1">&#39;axis1&#39;</span><span class="p">,</span> <span class="s1">&#39;axis2&#39;</span><span class="p">,</span> <span class="s1">&#39;dtype&#39;</span><span class="p">))</span>
<span class="k">def</span> <span class="nf">trace</span><span class="p">(</span><span class="n">a</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">,</span> <span class="n">offset</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">axis1</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">axis2</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
          <span class="n">dtype</span><span class="p">:</span> <span class="n">DTypeLike</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">out</span><span class="p">:</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Array</span><span class="p">:</span>
  <span class="n">util</span><span class="o">.</span><span class="n">check_arraylike</span><span class="p">(</span><span class="s2">&quot;trace&quot;</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">out</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
    <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;The &#39;out&#39; argument to jnp.trace is not supported.&quot;</span><span class="p">)</span>
  <span class="n">dtypes</span><span class="o">.</span><span class="n">check_user_dtype_supported</span><span class="p">(</span><span class="n">dtype</span><span class="p">,</span> <span class="s2">&quot;trace&quot;</span><span class="p">)</span>

  <span class="n">a_shape</span> <span class="o">=</span> <span class="n">shape</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">dtype</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
    <span class="n">dtype</span> <span class="o">=</span> <span class="n">_dtype</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">issubdtype</span><span class="p">(</span><span class="n">dtype</span><span class="p">,</span> <span class="n">integer</span><span class="p">):</span>
      <span class="n">default_int</span> <span class="o">=</span> <span class="n">dtypes</span><span class="o">.</span><span class="n">canonicalize_dtype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int_</span><span class="p">)</span>
      <span class="k">if</span> <span class="n">iinfo</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span><span class="o">.</span><span class="n">bits</span> <span class="o">&lt;</span> <span class="n">iinfo</span><span class="p">(</span><span class="n">default_int</span><span class="p">)</span><span class="o">.</span><span class="n">bits</span><span class="p">:</span>
        <span class="n">dtype</span> <span class="o">=</span> <span class="n">default_int</span>

  <span class="n">a</span> <span class="o">=</span> <span class="n">moveaxis</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="p">(</span><span class="n">axis1</span><span class="p">,</span> <span class="n">axis2</span><span class="p">),</span> <span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">))</span>

  <span class="c1"># Mask out the diagonal and reduce.</span>
  <span class="n">a</span> <span class="o">=</span> <span class="n">where</span><span class="p">(</span><span class="n">eye</span><span class="p">(</span><span class="n">a_shape</span><span class="p">[</span><span class="n">axis1</span><span class="p">],</span> <span class="n">a_shape</span><span class="p">[</span><span class="n">axis2</span><span class="p">],</span> <span class="n">k</span><span class="o">=</span><span class="n">offset</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">),</span>
            <span class="n">a</span><span class="p">,</span> <span class="n">zeros_like</span><span class="p">(</span><span class="n">a</span><span class="p">))</span>
  <span class="k">return</span> <span class="n">reductions</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_wrap_indices_function</span><span class="p">(</span><span class="n">f</span><span class="p">):</span>
  <span class="nd">@util</span><span class="o">.</span><span class="n">_wraps</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">update_doc</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
  <span class="k">def</span> <span class="nf">wrapper</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">args</span> <span class="o">=</span> <span class="p">[</span><span class="n">core</span><span class="o">.</span><span class="n">concrete_or_error</span><span class="p">(</span>
              <span class="kc">None</span><span class="p">,</span> <span class="n">arg</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;argument </span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2"> of jnp.</span><span class="si">{</span><span class="n">f</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">()&quot;</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">arg</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">args</span><span class="p">)]</span>
    <span class="n">kwargs</span> <span class="o">=</span> <span class="p">{</span><span class="n">key</span><span class="p">:</span> <span class="n">core</span><span class="o">.</span><span class="n">concrete_or_error</span><span class="p">(</span>
                <span class="kc">None</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;argument &#39;</span><span class="si">{</span><span class="n">key</span><span class="si">}</span><span class="s2">&#39; of jnp.</span><span class="si">{</span><span class="n">f</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">()&quot;</span><span class="p">)</span>
              <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>
    <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">asarray</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">f</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">))</span>
  <span class="k">return</span> <span class="n">wrapper</span>

<span class="n">mask_indices</span> <span class="o">=</span> <span class="n">_wrap_indices_function</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mask_indices</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_triu_size</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">k</span><span class="p">):</span>
  <span class="k">if</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">n</span> <span class="o">*</span> <span class="n">m</span> <span class="o">-</span> <span class="n">_triu_size</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">k</span><span class="p">))</span>
  <span class="k">elif</span> <span class="n">k</span> <span class="o">&gt;=</span> <span class="n">m</span><span class="p">:</span>
    <span class="k">return</span> <span class="mi">0</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="n">mk</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">m</span> <span class="o">-</span> <span class="n">k</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">mk</span> <span class="o">*</span> <span class="p">(</span><span class="n">mk</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">mk</span> <span class="o">*</span> <span class="p">(</span><span class="n">m</span> <span class="o">-</span> <span class="n">k</span> <span class="o">-</span> <span class="n">mk</span><span class="p">)</span>


<span class="nd">@util</span><span class="o">.</span><span class="n">_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">triu_indices</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">triu_indices</span><span class="p">(</span><span class="n">n</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">k</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">m</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">Array</span><span class="p">,</span> <span class="n">Array</span><span class="p">]:</span>
  <span class="n">n</span> <span class="o">=</span> <span class="n">core</span><span class="o">.</span><span class="n">concrete_or_error</span><span class="p">(</span><span class="n">operator</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="s2">&quot;n argument of jnp.triu_indices&quot;</span><span class="p">)</span>
  <span class="n">k</span> <span class="o">=</span> <span class="n">core</span><span class="o">.</span><span class="n">concrete_or_error</span><span class="p">(</span><span class="n">operator</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="s2">&quot;k argument of jnp.triu_indices&quot;</span><span class="p">)</span>
  <span class="n">m</span> <span class="o">=</span> <span class="n">n</span> <span class="k">if</span> <span class="n">m</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">core</span><span class="o">.</span><span class="n">concrete_or_error</span><span class="p">(</span><span class="n">operator</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="s2">&quot;m argument of jnp.triu_indices&quot;</span><span class="p">)</span>
  <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="o">=</span> <span class="n">nonzero</span><span class="p">(</span><span class="n">triu</span><span class="p">(</span><span class="n">ones</span><span class="p">((</span><span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="p">)),</span> <span class="n">k</span><span class="o">=</span><span class="n">k</span><span class="p">),</span> <span class="n">size</span><span class="o">=</span><span class="n">_triu_size</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">k</span><span class="p">))</span>
  <span class="k">return</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span>


<span class="nd">@util</span><span class="o">.</span><span class="n">_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">tril_indices</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">tril_indices</span><span class="p">(</span><span class="n">n</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">k</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">m</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">Array</span><span class="p">,</span> <span class="n">Array</span><span class="p">]:</span>
  <span class="n">n</span> <span class="o">=</span> <span class="n">core</span><span class="o">.</span><span class="n">concrete_or_error</span><span class="p">(</span><span class="n">operator</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="s2">&quot;n argument of jnp.triu_indices&quot;</span><span class="p">)</span>
  <span class="n">k</span> <span class="o">=</span> <span class="n">core</span><span class="o">.</span><span class="n">concrete_or_error</span><span class="p">(</span><span class="n">operator</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="s2">&quot;k argument of jnp.triu_indices&quot;</span><span class="p">)</span>
  <span class="n">m</span> <span class="o">=</span> <span class="n">n</span> <span class="k">if</span> <span class="n">m</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">core</span><span class="o">.</span><span class="n">concrete_or_error</span><span class="p">(</span><span class="n">operator</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="s2">&quot;m argument of jnp.triu_indices&quot;</span><span class="p">)</span>
  <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="o">=</span> <span class="n">nonzero</span><span class="p">(</span><span class="n">tril</span><span class="p">(</span><span class="n">ones</span><span class="p">((</span><span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="p">)),</span> <span class="n">k</span><span class="o">=</span><span class="n">k</span><span class="p">),</span> <span class="n">size</span><span class="o">=</span><span class="n">_triu_size</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="o">-</span><span class="n">k</span><span class="p">))</span>
  <span class="k">return</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span>


<span class="nd">@util</span><span class="o">.</span><span class="n">_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">triu_indices_from</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">triu_indices_from</span><span class="p">(</span><span class="n">arr</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">,</span> <span class="n">k</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">Array</span><span class="p">,</span> <span class="n">Array</span><span class="p">]:</span>
  <span class="n">arr_shape</span> <span class="o">=</span> <span class="n">shape</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">triu_indices</span><span class="p">(</span><span class="n">arr_shape</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">],</span> <span class="n">k</span><span class="o">=</span><span class="n">k</span><span class="p">,</span> <span class="n">m</span><span class="o">=</span><span class="n">arr_shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>


<span class="nd">@util</span><span class="o">.</span><span class="n">_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">tril_indices_from</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">tril_indices_from</span><span class="p">(</span><span class="n">arr</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">,</span> <span class="n">k</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">Array</span><span class="p">,</span> <span class="n">Array</span><span class="p">]:</span>
  <span class="n">arr_shape</span> <span class="o">=</span> <span class="n">shape</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">tril_indices</span><span class="p">(</span><span class="n">arr_shape</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">],</span> <span class="n">k</span><span class="o">=</span><span class="n">k</span><span class="p">,</span> <span class="n">m</span><span class="o">=</span><span class="n">arr_shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>


<span class="nd">@util</span><span class="o">.</span><span class="n">_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diag_indices</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">diag_indices</span><span class="p">(</span><span class="n">n</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">ndim</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">2</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">Array</span><span class="p">,</span> <span class="o">...</span><span class="p">]:</span>
  <span class="n">n</span> <span class="o">=</span> <span class="n">core</span><span class="o">.</span><span class="n">concrete_or_error</span><span class="p">(</span><span class="n">operator</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="s2">&quot;&#39;n&#39; argument of jnp.diag_indices()&quot;</span><span class="p">)</span>
  <span class="n">ndim</span> <span class="o">=</span> <span class="n">core</span><span class="o">.</span><span class="n">concrete_or_error</span><span class="p">(</span><span class="n">operator</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">ndim</span><span class="p">,</span> <span class="s2">&quot;&#39;ndim&#39; argument of jnp.diag_indices()&quot;</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;n argument to diag_indices must be nonnegative, got </span><span class="si">{}</span><span class="s2">&quot;</span>
                     <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">n</span><span class="p">))</span>
  <span class="k">if</span> <span class="n">ndim</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;ndim argument to diag_indices must be nonnegative, got </span><span class="si">{}</span><span class="s2">&quot;</span>
                     <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">ndim</span><span class="p">))</span>
  <span class="k">return</span> <span class="p">(</span><span class="n">lax</span><span class="o">.</span><span class="n">iota</span><span class="p">(</span><span class="n">int_</span><span class="p">,</span> <span class="n">n</span><span class="p">),)</span> <span class="o">*</span> <span class="n">ndim</span>

<span class="nd">@util</span><span class="o">.</span><span class="n">_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diag_indices_from</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">diag_indices_from</span><span class="p">(</span><span class="n">arr</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">Array</span><span class="p">,</span> <span class="o">...</span><span class="p">]:</span>
  <span class="n">util</span><span class="o">.</span><span class="n">check_arraylike</span><span class="p">(</span><span class="s2">&quot;diag_indices_from&quot;</span><span class="p">,</span> <span class="n">arr</span><span class="p">)</span>
  <span class="n">nd</span> <span class="o">=</span> <span class="n">ndim</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span>
  <span class="k">if</span> <span class="ow">not</span> <span class="n">ndim</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="p">:</span>
    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;input array must be at least 2-d&quot;</span><span class="p">)</span>

  <span class="n">s</span> <span class="o">=</span> <span class="n">shape</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span>
  <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">shape</span><span class="p">(</span><span class="n">arr</span><span class="p">)))</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;All dimensions of input must be of equal length&quot;</span><span class="p">)</span>

  <span class="k">return</span> <span class="n">diag_indices</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">ndim</span><span class="o">=</span><span class="n">nd</span><span class="p">)</span>

<span class="nd">@util</span><span class="o">.</span><span class="n">_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diagonal</span><span class="p">,</span> <span class="n">lax_description</span><span class="o">=</span><span class="n">_ARRAY_VIEW_DOC</span><span class="p">)</span>
<span class="nd">@partial</span><span class="p">(</span><span class="n">jit</span><span class="p">,</span> <span class="n">static_argnames</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;offset&#39;</span><span class="p">,</span> <span class="s1">&#39;axis1&#39;</span><span class="p">,</span> <span class="s1">&#39;axis2&#39;</span><span class="p">))</span>
<span class="k">def</span> <span class="nf">diagonal</span><span class="p">(</span><span class="n">a</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">,</span> <span class="n">offset</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">axis1</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
             <span class="n">axis2</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Array</span><span class="p">:</span>
  <span class="n">util</span><span class="o">.</span><span class="n">check_arraylike</span><span class="p">(</span><span class="s2">&quot;diagonal&quot;</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
  <span class="n">a_shape</span> <span class="o">=</span> <span class="n">shape</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">ndim</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;diagonal requires an array of at least two dimensions.&quot;</span><span class="p">)</span>
  <span class="n">offset</span> <span class="o">=</span> <span class="n">core</span><span class="o">.</span><span class="n">concrete_or_error</span><span class="p">(</span><span class="n">operator</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="s2">&quot;&#39;offset&#39; argument of jnp.diagonal()&quot;</span><span class="p">)</span>

  <span class="n">a</span> <span class="o">=</span> <span class="n">moveaxis</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="p">(</span><span class="n">axis1</span><span class="p">,</span> <span class="n">axis2</span><span class="p">),</span> <span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">))</span>

  <span class="n">diag_size</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">min</span><span class="p">(</span><span class="n">a_shape</span><span class="p">[</span><span class="n">axis1</span><span class="p">]</span> <span class="o">+</span> <span class="nb">min</span><span class="p">(</span><span class="n">offset</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
                         <span class="n">a_shape</span><span class="p">[</span><span class="n">axis2</span><span class="p">]</span> <span class="o">-</span> <span class="nb">max</span><span class="p">(</span><span class="n">offset</span><span class="p">,</span> <span class="mi">0</span><span class="p">)))</span>
  <span class="n">i</span> <span class="o">=</span> <span class="n">arange</span><span class="p">(</span><span class="n">diag_size</span><span class="p">)</span>
  <span class="n">j</span> <span class="o">=</span> <span class="n">arange</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">offset</span><span class="p">),</span> <span class="nb">abs</span><span class="p">(</span><span class="n">offset</span><span class="p">)</span> <span class="o">+</span> <span class="n">diag_size</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">a</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="k">if</span> <span class="n">offset</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="k">else</span> <span class="n">a</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span>


<span class="nd">@util</span><span class="o">.</span><span class="n">_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">,</span> <span class="n">lax_description</span><span class="o">=</span><span class="n">_ARRAY_VIEW_DOC</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">diag</span><span class="p">(</span><span class="n">v</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">,</span> <span class="n">k</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Array</span><span class="p">:</span>
  <span class="k">return</span> <span class="n">_diag</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">operator</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">k</span><span class="p">))</span>

<span class="nd">@partial</span><span class="p">(</span><span class="n">jit</span><span class="p">,</span> <span class="n">static_argnames</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;k&#39;</span><span class="p">,))</span>
<span class="k">def</span> <span class="nf">_diag</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">k</span><span class="p">):</span>
  <span class="n">util</span><span class="o">.</span><span class="n">check_arraylike</span><span class="p">(</span><span class="s2">&quot;diag&quot;</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
  <span class="n">v_shape</span> <span class="o">=</span> <span class="n">shape</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
  <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">v_shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
    <span class="n">zero</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">lax</span><span class="o">.</span><span class="n">full_like</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="p">(),</span> <span class="n">fill_value</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">n</span> <span class="o">=</span> <span class="n">v_shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="nb">abs</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
    <span class="n">v</span> <span class="o">=</span> <span class="n">lax</span><span class="o">.</span><span class="n">pad</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">zero</span><span class="p">(</span><span class="n">v</span><span class="p">),</span> <span class="p">((</span><span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">k</span><span class="p">),</span> <span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="n">k</span><span class="p">),</span> <span class="mi">0</span><span class="p">),))</span>
    <span class="k">return</span> <span class="n">where</span><span class="p">(</span><span class="n">eye</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="n">k</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">),</span> <span class="n">v</span><span class="p">,</span> <span class="n">zeros_like</span><span class="p">(</span><span class="n">v</span><span class="p">))</span>
  <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">v_shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">diagonal</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">offset</span><span class="o">=</span><span class="n">k</span><span class="p">)</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;diag input must be 1d or 2d&quot;</span><span class="p">)</span>

<span class="n">_SCALAR_VALUE_DOC</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span><span class="se">\</span>
<span class="s2">This differs from np.diagflat for some scalar values of v,</span>
<span class="s2">jax always returns a two-dimensional array, whereas numpy may</span>
<span class="s2">return a scalar depending on the type of v.</span>
<span class="s2">&quot;&quot;&quot;</span>

<span class="nd">@util</span><span class="o">.</span><span class="n">_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diagflat</span><span class="p">,</span> <span class="n">lax_description</span><span class="o">=</span><span class="n">_SCALAR_VALUE_DOC</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">diagflat</span><span class="p">(</span><span class="n">v</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">,</span> <span class="n">k</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Array</span><span class="p">:</span>
  <span class="n">util</span><span class="o">.</span><span class="n">check_arraylike</span><span class="p">(</span><span class="s2">&quot;diagflat&quot;</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
  <span class="n">v_ravel</span> <span class="o">=</span> <span class="n">ravel</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
  <span class="n">v_length</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">v_ravel</span><span class="p">)</span>
  <span class="n">adj_length</span> <span class="o">=</span> <span class="n">v_length</span> <span class="o">+</span> <span class="nb">abs</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
  <span class="n">res</span> <span class="o">=</span> <span class="n">zeros</span><span class="p">(</span><span class="n">adj_length</span><span class="o">*</span><span class="n">adj_length</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">v_ravel</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
  <span class="n">i</span> <span class="o">=</span> <span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">adj_length</span><span class="o">-</span><span class="nb">abs</span><span class="p">(</span><span class="n">k</span><span class="p">))</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">k</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">):</span>
    <span class="n">fi</span> <span class="o">=</span> <span class="n">i</span><span class="o">+</span><span class="n">k</span><span class="o">+</span><span class="n">i</span><span class="o">*</span><span class="n">adj_length</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="n">fi</span> <span class="o">=</span> <span class="n">i</span><span class="o">+</span><span class="p">(</span><span class="n">i</span><span class="o">-</span><span class="n">k</span><span class="p">)</span><span class="o">*</span><span class="n">adj_length</span>
  <span class="n">res</span> <span class="o">=</span> <span class="n">res</span><span class="o">.</span><span class="n">at</span><span class="p">[</span><span class="n">fi</span><span class="p">]</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">v_ravel</span><span class="p">)</span>
  <span class="n">res</span> <span class="o">=</span> <span class="n">res</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">adj_length</span><span class="p">,</span> <span class="n">adj_length</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">res</span>


<span class="nd">@util</span><span class="o">.</span><span class="n">_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">trim_zeros</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">trim_zeros</span><span class="p">(</span><span class="n">filt</span><span class="p">,</span> <span class="n">trim</span><span class="o">=</span><span class="s1">&#39;fb&#39;</span><span class="p">):</span>
  <span class="n">filt</span> <span class="o">=</span> <span class="n">core</span><span class="o">.</span><span class="n">concrete_or_error</span><span class="p">(</span><span class="n">asarray</span><span class="p">,</span> <span class="n">filt</span><span class="p">,</span>
    <span class="s2">&quot;Error arose in the `filt` argument of trim_zeros()&quot;</span><span class="p">)</span>
  <span class="n">nz</span> <span class="o">=</span> <span class="p">(</span><span class="n">filt</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">reductions</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">nz</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">empty</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">_dtype</span><span class="p">(</span><span class="n">filt</span><span class="p">))</span>
  <span class="n">start</span> <span class="o">=</span> <span class="n">argmin</span><span class="p">(</span><span class="n">nz</span><span class="p">)</span> <span class="k">if</span> <span class="s1">&#39;f&#39;</span> <span class="ow">in</span> <span class="n">trim</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="k">else</span> <span class="mi">0</span>
  <span class="n">end</span> <span class="o">=</span> <span class="n">argmin</span><span class="p">(</span><span class="n">nz</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="k">if</span> <span class="s1">&#39;b&#39;</span> <span class="ow">in</span> <span class="n">trim</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="k">else</span> <span class="mi">0</span>
  <span class="k">return</span> <span class="n">filt</span><span class="p">[</span><span class="n">start</span><span class="p">:</span><span class="nb">len</span><span class="p">(</span><span class="n">filt</span><span class="p">)</span> <span class="o">-</span> <span class="n">end</span><span class="p">]</span>


<span class="k">def</span> <span class="nf">trim_zeros_tol</span><span class="p">(</span><span class="n">filt</span><span class="p">,</span> <span class="n">tol</span><span class="p">,</span> <span class="n">trim</span><span class="o">=</span><span class="s1">&#39;fb&#39;</span><span class="p">):</span>
  <span class="n">filt</span> <span class="o">=</span> <span class="n">core</span><span class="o">.</span><span class="n">concrete_or_error</span><span class="p">(</span><span class="n">asarray</span><span class="p">,</span> <span class="n">filt</span><span class="p">,</span>
    <span class="s2">&quot;Error arose in the `filt` argument of trim_zeros_tol()&quot;</span><span class="p">)</span>
  <span class="n">nz</span> <span class="o">=</span> <span class="p">(</span><span class="n">ufuncs</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">filt</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">tol</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">reductions</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">nz</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">empty</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">_dtype</span><span class="p">(</span><span class="n">filt</span><span class="p">))</span>
  <span class="n">start</span> <span class="o">=</span> <span class="n">argmin</span><span class="p">(</span><span class="n">nz</span><span class="p">)</span> <span class="k">if</span> <span class="s1">&#39;f&#39;</span> <span class="ow">in</span> <span class="n">trim</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="k">else</span> <span class="mi">0</span>
  <span class="n">end</span> <span class="o">=</span> <span class="n">argmin</span><span class="p">(</span><span class="n">nz</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="k">if</span> <span class="s1">&#39;b&#39;</span> <span class="ow">in</span> <span class="n">trim</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="k">else</span> <span class="mi">0</span>
  <span class="k">return</span> <span class="n">filt</span><span class="p">[</span><span class="n">start</span><span class="p">:</span><span class="nb">len</span><span class="p">(</span><span class="n">filt</span><span class="p">)</span> <span class="o">-</span> <span class="n">end</span><span class="p">]</span>


<span class="nd">@util</span><span class="o">.</span><span class="n">_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">)</span>
<span class="nd">@partial</span><span class="p">(</span><span class="n">jit</span><span class="p">,</span> <span class="n">static_argnames</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;axis&#39;</span><span class="p">,))</span>
<span class="k">def</span> <span class="nf">append</span><span class="p">(</span>
    <span class="n">arr</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">,</span> <span class="n">values</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">,</span> <span class="n">axis</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Array</span><span class="p">:</span>
  <span class="k">if</span> <span class="n">axis</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">concatenate</span><span class="p">([</span><span class="n">ravel</span><span class="p">(</span><span class="n">arr</span><span class="p">),</span> <span class="n">ravel</span><span class="p">(</span><span class="n">values</span><span class="p">)],</span> <span class="mi">0</span><span class="p">)</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">concatenate</span><span class="p">([</span><span class="n">arr</span><span class="p">,</span> <span class="n">values</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>


<span class="nd">@util</span><span class="o">.</span><span class="n">_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">,</span>
  <span class="n">lax_description</span><span class="o">=</span><span class="n">_dedent</span><span class="p">(</span><span class="s2">&quot;&quot;&quot;</span>
<span class="s2">    delete() usually requires the index specification to be static. If the index</span>
<span class="s2">    is an integer array that is guaranteed to contain unique entries, you may</span>
<span class="s2">    specify ``assume_unique_indices=True`` to perform the operation in a</span>
<span class="s2">    manner that does not require static indices.&quot;&quot;&quot;</span><span class="p">),</span>
  <span class="n">extra_params</span><span class="o">=</span><span class="n">_dedent</span><span class="p">(</span><span class="s2">&quot;&quot;&quot;</span>
<span class="s2">    assume_unique_indices : int, optional (default=False)</span>
<span class="s2">        In case of array-like integer (not boolean) indices, assume the indices are unique,</span>
<span class="s2">        and perform the deletion in a way that is compatible with JIT and other JAX</span>
<span class="s2">        transformations.&quot;&quot;&quot;</span><span class="p">))</span>
<span class="k">def</span> <span class="nf">delete</span><span class="p">(</span>
    <span class="n">arr</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">,</span>
    <span class="n">obj</span><span class="p">:</span> <span class="n">ArrayLike</span> <span class="o">|</span> <span class="nb">slice</span><span class="p">,</span>
    <span class="n">axis</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">assume_unique_indices</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Array</span><span class="p">:</span>
  <span class="n">util</span><span class="o">.</span><span class="n">check_arraylike</span><span class="p">(</span><span class="s2">&quot;delete&quot;</span><span class="p">,</span> <span class="n">arr</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">axis</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
    <span class="n">arr</span> <span class="o">=</span> <span class="n">ravel</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span>
    <span class="n">axis</span> <span class="o">=</span> <span class="mi">0</span>
  <span class="n">a</span> <span class="o">=</span> <span class="n">asarray</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span>
  <span class="n">axis</span> <span class="o">=</span> <span class="n">_canonicalize_axis</span><span class="p">(</span><span class="n">axis</span><span class="p">,</span> <span class="n">a</span><span class="o">.</span><span class="n">ndim</span><span class="p">)</span>

  <span class="c1"># Case 1: obj is a static integer.</span>
  <span class="k">try</span><span class="p">:</span>
    <span class="n">obj</span> <span class="o">=</span> <span class="n">operator</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>  <span class="c1"># type: ignore[arg-type]</span>
    <span class="n">obj</span> <span class="o">=</span> <span class="n">_canonicalize_axis</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="p">])</span>
  <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
    <span class="k">pass</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="n">idx</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">axis</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">concatenate</span><span class="p">([</span><span class="n">a</span><span class="p">[</span><span class="n">idx</span> <span class="o">+</span> <span class="p">(</span><span class="nb">slice</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">obj</span><span class="p">),)],</span> <span class="n">a</span><span class="p">[</span><span class="n">idx</span> <span class="o">+</span> <span class="p">(</span><span class="nb">slice</span><span class="p">(</span><span class="n">obj</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="kc">None</span><span class="p">),)]],</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>

  <span class="c1"># Case 2: obj is a static slice.</span>
  <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="nb">slice</span><span class="p">):</span>
    <span class="n">obj</span> <span class="o">=</span> <span class="n">arange</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="p">])[</span><span class="n">obj</span><span class="p">]</span>
    <span class="n">assume_unique_indices</span> <span class="o">=</span> <span class="kc">True</span>

  <span class="c1"># Case 3: obj is an array</span>
  <span class="c1"># NB: pass both arrays to check for appropriate error message.</span>
  <span class="n">util</span><span class="o">.</span><span class="n">check_arraylike</span><span class="p">(</span><span class="s2">&quot;delete&quot;</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">obj</span><span class="p">)</span>

  <span class="c1"># Case 3a: unique integer indices; delete in a JIT-compatible way</span>
  <span class="k">if</span> <span class="n">issubdtype</span><span class="p">(</span><span class="n">_dtype</span><span class="p">(</span><span class="n">obj</span><span class="p">),</span> <span class="n">integer</span><span class="p">)</span> <span class="ow">and</span> <span class="n">assume_unique_indices</span><span class="p">:</span>
    <span class="n">obj</span> <span class="o">=</span> <span class="n">asarray</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
    <span class="n">obj</span> <span class="o">=</span> <span class="n">clip</span><span class="p">(</span><span class="n">where</span><span class="p">(</span><span class="n">obj</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">,</span> <span class="n">obj</span> <span class="o">+</span> <span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="p">],</span> <span class="n">obj</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="p">])</span>
    <span class="n">obj</span> <span class="o">=</span> <span class="n">sort</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>
    <span class="n">obj</span> <span class="o">-=</span> <span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">obj</span><span class="p">))</span>  <span class="c1"># type: ignore[arg-type,operator]</span>
    <span class="n">i</span> <span class="o">=</span> <span class="n">arange</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">-</span> <span class="n">obj</span><span class="o">.</span><span class="n">size</span><span class="p">)</span>
    <span class="n">i</span> <span class="o">+=</span> <span class="p">(</span><span class="n">i</span><span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="p">:]</span> <span class="o">&gt;=</span> <span class="n">obj</span><span class="p">[:,</span> <span class="kc">None</span><span class="p">])</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">a</span><span class="p">[(</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">),)</span> <span class="o">*</span> <span class="n">axis</span> <span class="o">+</span> <span class="p">(</span><span class="n">i</span><span class="p">,)]</span>

  <span class="c1"># Case 3b: non-unique indices: must be static.</span>
  <span class="n">obj_array</span> <span class="o">=</span> <span class="n">core</span><span class="o">.</span><span class="n">concrete_or_error</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">,</span> <span class="n">obj</span><span class="p">,</span> <span class="s2">&quot;&#39;obj&#39; array argument of jnp.delete()&quot;</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">issubdtype</span><span class="p">(</span><span class="n">obj_array</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">integer</span><span class="p">):</span>
    <span class="c1"># TODO(jakevdp): in theory this could be done dynamically if obj has no duplicates,</span>
    <span class="c1"># but this would require the complement of lax.gather.</span>
    <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
    <span class="n">mask</span><span class="p">[</span><span class="n">obj_array</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>
  <span class="k">elif</span> <span class="n">obj_array</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="nb">bool</span><span class="p">:</span>
    <span class="k">if</span> <span class="n">obj_array</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="p">],):</span>
      <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;np.delete(arr, obj): for boolean indices, obj must be one-dimensional &quot;</span>
                       <span class="s2">&quot;with length matching specified axis.&quot;</span><span class="p">)</span>
    <span class="n">mask</span> <span class="o">=</span> <span class="o">~</span><span class="n">obj_array</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;np.delete(arr, obj): got obj.dtype=</span><span class="si">{</span><span class="n">obj_array</span><span class="o">.</span><span class="n">dtype</span><span class="si">}</span><span class="s2">; must be integer or bool.&quot;</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">a</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">axis</span><span class="p">))</span> <span class="o">+</span> <span class="p">(</span><span class="n">mask</span><span class="p">,)]</span>


<span class="nd">@util</span><span class="o">.</span><span class="n">_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">insert</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">insert</span><span class="p">(</span><span class="n">arr</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">,</span> <span class="n">obj</span><span class="p">:</span> <span class="n">ArrayLike</span> <span class="o">|</span> <span class="nb">slice</span><span class="p">,</span> <span class="n">values</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">,</span>
           <span class="n">axis</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Array</span><span class="p">:</span>
  <span class="n">util</span><span class="o">.</span><span class="n">check_arraylike</span><span class="p">(</span><span class="s2">&quot;insert&quot;</span><span class="p">,</span> <span class="n">arr</span><span class="p">,</span> <span class="mi">0</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="nb">slice</span><span class="p">)</span> <span class="k">else</span> <span class="n">obj</span><span class="p">,</span> <span class="n">values</span><span class="p">)</span>
  <span class="n">a</span> <span class="o">=</span> <span class="n">asarray</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span>
  <span class="n">values_arr</span> <span class="o">=</span> <span class="n">asarray</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>

  <span class="k">if</span> <span class="n">axis</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">ravel</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="n">axis</span> <span class="o">=</span> <span class="mi">0</span>
  <span class="n">axis</span> <span class="o">=</span> <span class="n">core</span><span class="o">.</span><span class="n">concrete_or_error</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="s2">&quot;axis argument of jnp.insert()&quot;</span><span class="p">)</span>
  <span class="n">axis</span> <span class="o">=</span> <span class="n">_canonicalize_axis</span><span class="p">(</span><span class="n">axis</span><span class="p">,</span> <span class="n">a</span><span class="o">.</span><span class="n">ndim</span><span class="p">)</span>
  <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="nb">slice</span><span class="p">):</span>
    <span class="n">indices</span> <span class="o">=</span> <span class="n">arange</span><span class="p">(</span><span class="o">*</span><span class="n">obj</span><span class="o">.</span><span class="n">indices</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="p">]))</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="n">indices</span> <span class="o">=</span> <span class="n">asarray</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>

  <span class="k">if</span> <span class="n">indices</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;jnp.insert(): obj must be a slice, a one-dimensional &quot;</span>
                     <span class="sa">f</span><span class="s2">&quot;array, or a scalar; got </span><span class="si">{</span><span class="n">obj</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
  <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="n">indices</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">integer</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">indices</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">Array</span><span class="p">):</span>
      <span class="n">indices</span> <span class="o">=</span> <span class="n">indices</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="c1"># Note: np.insert allows boolean inputs but the behavior is deprecated.</span>
      <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;jnp.insert(): index array must be &quot;</span>
                       <span class="sa">f</span><span class="s2">&quot;integer typed; got </span><span class="si">{</span><span class="n">obj</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
  <span class="n">values_arr</span> <span class="o">=</span> <span class="n">array</span><span class="p">(</span><span class="n">values_arr</span><span class="p">,</span> <span class="n">ndmin</span><span class="o">=</span><span class="n">a</span><span class="o">.</span><span class="n">ndim</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">a</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

  <span class="k">if</span> <span class="n">indices</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
    <span class="n">index</span> <span class="o">=</span> <span class="n">ravel</span><span class="p">(</span><span class="n">indices</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">indices</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
      <span class="n">values_arr</span> <span class="o">=</span> <span class="n">moveaxis</span><span class="p">(</span><span class="n">values_arr</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">axis</span><span class="p">)</span>
    <span class="n">indices</span> <span class="o">=</span> <span class="n">full</span><span class="p">(</span><span class="n">values_arr</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="p">],</span> <span class="n">index</span><span class="p">)</span>
  <span class="n">n_input</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span>
  <span class="n">n_insert</span> <span class="o">=</span> <span class="n">broadcast_shapes</span><span class="p">(</span><span class="n">indices</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="p">(</span><span class="n">values_arr</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="p">],))[</span><span class="mi">0</span><span class="p">]</span>
  <span class="n">out_shape</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
  <span class="n">out_shape</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">+=</span> <span class="n">n_insert</span>
  <span class="n">out</span> <span class="o">=</span> <span class="n">zeros_like</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="nb">tuple</span><span class="p">(</span><span class="n">out_shape</span><span class="p">))</span>

  <span class="n">indices</span> <span class="o">=</span> <span class="n">where</span><span class="p">(</span><span class="n">indices</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">,</span> <span class="n">indices</span> <span class="o">+</span> <span class="n">n_input</span><span class="p">,</span> <span class="n">indices</span><span class="p">)</span>
  <span class="n">indices</span> <span class="o">=</span> <span class="n">clip</span><span class="p">(</span><span class="n">indices</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">n_input</span><span class="p">)</span>

  <span class="n">values_ind</span> <span class="o">=</span> <span class="n">indices</span><span class="o">.</span><span class="n">at</span><span class="p">[</span><span class="n">argsort</span><span class="p">(</span><span class="n">indices</span><span class="p">)]</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">arange</span><span class="p">(</span><span class="n">n_insert</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">indices</span><span class="o">.</span><span class="n">dtype</span><span class="p">))</span>
  <span class="n">arr_mask</span> <span class="o">=</span> <span class="n">ones</span><span class="p">(</span><span class="n">n_input</span> <span class="o">+</span> <span class="n">n_insert</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span><span class="o">.</span><span class="n">at</span><span class="p">[</span><span class="n">values_ind</span><span class="p">]</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
  <span class="n">arr_ind</span> <span class="o">=</span> <span class="n">where</span><span class="p">(</span><span class="n">arr_mask</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="n">n_input</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

  <span class="n">out</span> <span class="o">=</span> <span class="n">out</span><span class="o">.</span><span class="n">at</span><span class="p">[(</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">),)</span> <span class="o">*</span> <span class="n">axis</span> <span class="o">+</span> <span class="p">(</span><span class="n">values_ind</span><span class="p">,)]</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">values_arr</span><span class="p">)</span>
  <span class="n">out</span> <span class="o">=</span> <span class="n">out</span><span class="o">.</span><span class="n">at</span><span class="p">[(</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">),)</span> <span class="o">*</span> <span class="n">axis</span> <span class="o">+</span> <span class="p">(</span><span class="n">arr_ind</span><span class="p">,)]</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>

  <span class="k">return</span> <span class="n">out</span>


<span class="nd">@util</span><span class="o">.</span><span class="n">_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">apply_along_axis</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">apply_along_axis</span><span class="p">(</span>
    <span class="n">func1d</span><span class="p">:</span> <span class="n">Callable</span><span class="p">,</span> <span class="n">axis</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">arr</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Array</span><span class="p">:</span>
  <span class="n">num_dims</span> <span class="o">=</span> <span class="n">ndim</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span>
  <span class="n">axis</span> <span class="o">=</span> <span class="n">_canonicalize_axis</span><span class="p">(</span><span class="n">axis</span><span class="p">,</span> <span class="n">num_dims</span><span class="p">)</span>
  <span class="n">func</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">arr</span><span class="p">:</span> <span class="n">func1d</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
  <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">num_dims</span> <span class="o">-</span> <span class="n">axis</span><span class="p">):</span>
    <span class="n">func</span> <span class="o">=</span> <span class="n">jax</span><span class="o">.</span><span class="n">vmap</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">in_axes</span><span class="o">=</span><span class="n">i</span><span class="p">,</span> <span class="n">out_axes</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
  <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">axis</span><span class="p">):</span>
    <span class="n">func</span> <span class="o">=</span> <span class="n">jax</span><span class="o">.</span><span class="n">vmap</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">in_axes</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">out_axes</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">func</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span>


<span class="nd">@util</span><span class="o">.</span><span class="n">_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">apply_over_axes</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">apply_over_axes</span><span class="p">(</span><span class="n">func</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">ArrayLike</span><span class="p">,</span> <span class="nb">int</span><span class="p">],</span> <span class="n">Array</span><span class="p">],</span> <span class="n">a</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">,</span>
                    <span class="n">axes</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Array</span><span class="p">:</span>
  <span class="n">a_arr</span> <span class="o">=</span> <span class="n">asarray</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
  <span class="k">for</span> <span class="n">axis</span> <span class="ow">in</span> <span class="n">axes</span><span class="p">:</span>
    <span class="n">b</span> <span class="o">=</span> <span class="n">func</span><span class="p">(</span><span class="n">a_arr</span><span class="p">,</span> <span class="n">axis</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">b</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="n">a_arr</span><span class="o">.</span><span class="n">ndim</span><span class="p">:</span>
      <span class="n">a_arr</span> <span class="o">=</span> <span class="n">b</span>
    <span class="k">elif</span> <span class="n">b</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="n">a_arr</span><span class="o">.</span><span class="n">ndim</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
      <span class="n">a_arr</span> <span class="o">=</span> <span class="n">expand_dims</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">axis</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;function is not returning an array of the correct shape&quot;</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">a_arr</span>


<span class="c1">### Tensor contraction operations</span>


<span class="nd">@util</span><span class="o">.</span><span class="n">_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">,</span> <span class="n">lax_description</span><span class="o">=</span><span class="n">_PRECISION_DOC</span><span class="p">)</span>
<span class="nd">@partial</span><span class="p">(</span><span class="n">jit</span><span class="p">,</span> <span class="n">static_argnames</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;precision&#39;</span><span class="p">,</span> <span class="s1">&#39;preferred_element_type&#39;</span><span class="p">),</span> <span class="n">inline</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">dot</span><span class="p">(</span><span class="n">a</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span>
        <span class="n">precision</span><span class="p">:</span> <span class="n">PrecisionLike</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">preferred_element_type</span><span class="p">:</span> <span class="n">DTypeLike</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Array</span><span class="p">:</span>
  <span class="n">util</span><span class="o">.</span><span class="n">check_arraylike</span><span class="p">(</span><span class="s2">&quot;dot&quot;</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
  <span class="n">dtypes</span><span class="o">.</span><span class="n">check_user_dtype_supported</span><span class="p">(</span><span class="n">preferred_element_type</span><span class="p">,</span> <span class="s2">&quot;dot&quot;</span><span class="p">)</span>
  <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">asarray</span><span class="p">(</span><span class="n">a</span><span class="p">),</span> <span class="n">asarray</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">preferred_element_type</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
    <span class="n">preferred_element_type</span><span class="p">,</span> <span class="n">output_weak_type</span> <span class="o">=</span> <span class="n">dtypes</span><span class="o">.</span><span class="n">result_type</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">return_weak_type_flag</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="n">output_weak_type</span> <span class="o">=</span> <span class="kc">False</span>

  <span class="n">batch_dims</span> <span class="o">=</span> <span class="p">((),</span> <span class="p">())</span>
  <span class="n">a_ndim</span><span class="p">,</span> <span class="n">b_ndim</span> <span class="o">=</span> <span class="n">ndim</span><span class="p">(</span><span class="n">a</span><span class="p">),</span> <span class="n">ndim</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">a_ndim</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">b_ndim</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
    <span class="c1"># TODO(jakevdp): lower this case to dot_general as well?</span>
    <span class="c1"># Currently, doing so causes issues in remat tests due to #16805</span>
    <span class="k">if</span> <span class="n">preferred_element_type</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
      <span class="n">a</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">preferred_element_type</span><span class="p">)</span>
      <span class="n">b</span> <span class="o">=</span> <span class="n">b</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">preferred_element_type</span><span class="p">)</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">lax</span><span class="o">.</span><span class="n">mul</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="k">if</span> <span class="n">b_ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
      <span class="n">contract_dims</span> <span class="o">=</span> <span class="p">((</span><span class="n">a_ndim</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,))</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="n">contract_dims</span> <span class="o">=</span> <span class="p">((</span><span class="n">a_ndim</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,),</span> <span class="p">(</span><span class="n">b_ndim</span> <span class="o">-</span> <span class="mi">2</span><span class="p">,))</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">lax</span><span class="o">.</span><span class="n">dot_general</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">dimension_numbers</span><span class="o">=</span><span class="p">(</span><span class="n">contract_dims</span><span class="p">,</span> <span class="n">batch_dims</span><span class="p">),</span>
                             <span class="n">precision</span><span class="o">=</span><span class="n">precision</span><span class="p">,</span> <span class="n">preferred_element_type</span><span class="o">=</span><span class="n">preferred_element_type</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">lax_internal</span><span class="o">.</span><span class="n">_convert_element_type</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">preferred_element_type</span><span class="p">,</span> <span class="n">output_weak_type</span><span class="p">)</span>


<span class="nd">@util</span><span class="o">.</span><span class="n">_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">matmul</span><span class="p">,</span> <span class="n">module</span><span class="o">=</span><span class="s1">&#39;numpy&#39;</span><span class="p">,</span> <span class="n">lax_description</span><span class="o">=</span><span class="n">_PRECISION_DOC</span><span class="p">)</span>
<span class="nd">@partial</span><span class="p">(</span><span class="n">jit</span><span class="p">,</span> <span class="n">static_argnames</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;precision&#39;</span><span class="p">,</span> <span class="s1">&#39;preferred_element_type&#39;</span><span class="p">),</span> <span class="n">inline</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">matmul</span><span class="p">(</span><span class="n">a</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span>
           <span class="n">precision</span><span class="p">:</span> <span class="n">PrecisionLike</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
           <span class="n">preferred_element_type</span><span class="p">:</span> <span class="n">DTypeLike</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
           <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Array</span><span class="p">:</span>
<span class="w">  </span><span class="sd">&quot;&quot;&quot;Matrix Multiply.&quot;&quot;&quot;</span>
  <span class="n">util</span><span class="o">.</span><span class="n">check_arraylike</span><span class="p">(</span><span class="s2">&quot;matmul&quot;</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
  <span class="n">dtypes</span><span class="o">.</span><span class="n">check_user_dtype_supported</span><span class="p">(</span><span class="n">preferred_element_type</span><span class="p">,</span> <span class="s2">&quot;matmul&quot;</span><span class="p">)</span>
  <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">asarray</span><span class="p">(</span><span class="n">a</span><span class="p">),</span> <span class="n">asarray</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
  <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">((</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)):</span>
    <span class="k">if</span> <span class="n">ndim</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
      <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span><span class="sa">f</span><span class="s2">&quot;matmul input operand </span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2"> must have ndim at least 1, &quot;</span>
             <span class="sa">f</span><span class="s2">&quot;but it has ndim </span><span class="si">{</span><span class="n">ndim</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
      <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">preferred_element_type</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
    <span class="n">preferred_element_type</span><span class="p">,</span> <span class="n">output_weak_type</span> <span class="o">=</span> <span class="n">dtypes</span><span class="o">.</span><span class="n">result_type</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">return_weak_type_flag</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="n">output_weak_type</span> <span class="o">=</span> <span class="kc">False</span>

  <span class="n">a_is_mat</span><span class="p">,</span> <span class="n">b_is_mat</span> <span class="o">=</span> <span class="p">(</span><span class="n">ndim</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="n">ndim</span><span class="p">(</span><span class="n">b</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span>
  <span class="n">a_batch_dims</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span> <span class="o">|</span> <span class="kc">None</span><span class="p">,</span> <span class="o">...</span><span class="p">]</span> <span class="o">=</span> <span class="n">shape</span><span class="p">(</span><span class="n">a</span><span class="p">)[:</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span> <span class="k">if</span> <span class="n">a_is_mat</span> <span class="k">else</span> <span class="p">()</span>
  <span class="n">b_batch_dims</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span> <span class="o">|</span> <span class="kc">None</span><span class="p">,</span> <span class="o">...</span><span class="p">]</span> <span class="o">=</span> <span class="n">shape</span><span class="p">(</span><span class="n">b</span><span class="p">)[:</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span> <span class="k">if</span> <span class="n">b_is_mat</span> <span class="k">else</span> <span class="p">()</span>
  <span class="n">num_batch_dims</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">a_batch_dims</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">b_batch_dims</span><span class="p">))</span>
  <span class="n">a_batch_dims</span> <span class="o">=</span> <span class="p">(</span><span class="kc">None</span><span class="p">,)</span> <span class="o">*</span> <span class="p">(</span><span class="n">num_batch_dims</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">a_batch_dims</span><span class="p">))</span> <span class="o">+</span> <span class="n">a_batch_dims</span>
  <span class="n">b_batch_dims</span> <span class="o">=</span> <span class="p">(</span><span class="kc">None</span><span class="p">,)</span> <span class="o">*</span> <span class="p">(</span><span class="n">num_batch_dims</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">b_batch_dims</span><span class="p">))</span> <span class="o">+</span> <span class="n">b_batch_dims</span>

  <span class="c1"># Dimensions to squeeze from the inputs.</span>
  <span class="n">a_squeeze</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
  <span class="n">b_squeeze</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>

  <span class="c1"># Positions of batch dimensions in squeezed inputs.</span>
  <span class="n">a_batch</span> <span class="o">=</span> <span class="p">[]</span>
  <span class="n">b_batch</span> <span class="o">=</span> <span class="p">[]</span>

  <span class="c1"># Desired index in final output of each kind of dimension, in the order that</span>
  <span class="c1"># lax.dot_general will emit them.</span>
  <span class="n">idx_batch</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
  <span class="n">idx_a_other</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># other = non-batch, non-contracting.</span>
  <span class="n">idx_b_other</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
  <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">ba</span><span class="p">,</span> <span class="n">bb</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">a_batch_dims</span><span class="p">,</span> <span class="n">b_batch_dims</span><span class="p">)):</span>
    <span class="k">if</span> <span class="n">ba</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
      <span class="n">idx_b_other</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">bb</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
      <span class="n">idx_a_other</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">core</span><span class="o">.</span><span class="n">definitely_equal</span><span class="p">(</span><span class="n">ba</span><span class="p">,</span> <span class="mi">1</span><span class="p">):</span>
      <span class="n">idx_b_other</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
      <span class="n">a_squeeze</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">idx_batch</span><span class="p">)</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">idx_a_other</span><span class="p">)</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">a_squeeze</span><span class="p">))</span>
    <span class="k">elif</span> <span class="n">core</span><span class="o">.</span><span class="n">definitely_equal</span><span class="p">(</span><span class="n">bb</span><span class="p">,</span> <span class="mi">1</span><span class="p">):</span>
      <span class="n">idx_a_other</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
      <span class="n">b_squeeze</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">idx_batch</span><span class="p">)</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">idx_b_other</span><span class="p">)</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">b_squeeze</span><span class="p">))</span>
    <span class="k">elif</span> <span class="n">core</span><span class="o">.</span><span class="n">definitely_equal</span><span class="p">(</span><span class="n">ba</span><span class="p">,</span> <span class="n">bb</span><span class="p">):</span>
      <span class="n">a_batch</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">idx_batch</span><span class="p">)</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">idx_a_other</span><span class="p">))</span>
      <span class="n">b_batch</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">idx_batch</span><span class="p">)</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">idx_b_other</span><span class="p">))</span>
      <span class="n">idx_batch</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Incompatible shapes for matmul arguments: </span><span class="si">{}</span><span class="s2"> and </span><span class="si">{}</span><span class="s2">&quot;</span>
                       <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">shape</span><span class="p">(</span><span class="n">a</span><span class="p">),</span> <span class="n">shape</span><span class="p">(</span><span class="n">b</span><span class="p">)))</span>

  <span class="k">if</span> <span class="n">a_is_mat</span><span class="p">:</span> <span class="n">idx_a_other</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">num_batch_dims</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">b_is_mat</span><span class="p">:</span> <span class="n">idx_b_other</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">num_batch_dims</span> <span class="o">+</span> <span class="n">a_is_mat</span><span class="p">)</span>
  <span class="n">perm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">idx_batch</span><span class="p">,</span> <span class="n">idx_a_other</span><span class="p">,</span> <span class="n">idx_b_other</span><span class="p">]))</span>

  <span class="n">a</span> <span class="o">=</span> <span class="n">lax</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">a_squeeze</span><span class="p">))</span>
  <span class="n">b</span> <span class="o">=</span> <span class="n">lax</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">b_squeeze</span><span class="p">))</span>
  <span class="n">out</span> <span class="o">=</span> <span class="n">lax</span><span class="o">.</span><span class="n">dot_general</span><span class="p">(</span>
    <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="p">(((</span><span class="n">ndim</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,),</span> <span class="p">(</span><span class="n">ndim</span><span class="p">(</span><span class="n">b</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">b_is_mat</span><span class="p">,)),</span> <span class="p">(</span><span class="n">a_batch</span><span class="p">,</span> <span class="n">b_batch</span><span class="p">)),</span>
    <span class="n">precision</span><span class="o">=</span><span class="n">precision</span><span class="p">,</span> <span class="n">preferred_element_type</span><span class="o">=</span><span class="n">preferred_element_type</span><span class="p">)</span>
  <span class="n">result</span> <span class="o">=</span> <span class="n">lax</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="n">perm</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">lax_internal</span><span class="o">.</span><span class="n">_convert_element_type</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">preferred_element_type</span><span class="p">,</span> <span class="n">output_weak_type</span><span class="p">)</span>


<span class="nd">@util</span><span class="o">.</span><span class="n">_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">vdot</span><span class="p">,</span> <span class="n">lax_description</span><span class="o">=</span><span class="n">_PRECISION_DOC</span><span class="p">)</span>
<span class="nd">@partial</span><span class="p">(</span><span class="n">jit</span><span class="p">,</span> <span class="n">static_argnames</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;precision&#39;</span><span class="p">,</span> <span class="s1">&#39;preferred_element_type&#39;</span><span class="p">),</span> <span class="n">inline</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">vdot</span><span class="p">(</span>
    <span class="n">a</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span>
    <span class="n">precision</span><span class="p">:</span> <span class="n">PrecisionLike</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">preferred_element_type</span><span class="p">:</span> <span class="n">DTypeLike</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Array</span><span class="p">:</span>
  <span class="n">util</span><span class="o">.</span><span class="n">check_arraylike</span><span class="p">(</span><span class="s2">&quot;vdot&quot;</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">issubdtype</span><span class="p">(</span><span class="n">_dtype</span><span class="p">(</span><span class="n">a</span><span class="p">),</span> <span class="n">complexfloating</span><span class="p">):</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">ufuncs</span><span class="o">.</span><span class="n">conj</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">dot</span><span class="p">(</span><span class="n">ravel</span><span class="p">(</span><span class="n">a</span><span class="p">),</span> <span class="n">ravel</span><span class="p">(</span><span class="n">b</span><span class="p">),</span> <span class="n">precision</span><span class="o">=</span><span class="n">precision</span><span class="p">,</span>
             <span class="n">preferred_element_type</span><span class="o">=</span><span class="n">preferred_element_type</span><span class="p">)</span>


<span class="nd">@util</span><span class="o">.</span><span class="n">_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">tensordot</span><span class="p">,</span> <span class="n">lax_description</span><span class="o">=</span><span class="n">_PRECISION_DOC</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">tensordot</span><span class="p">(</span><span class="n">a</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">,</span>
              <span class="n">axes</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">|</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
              <span class="o">*</span><span class="p">,</span> <span class="n">precision</span><span class="p">:</span> <span class="n">PrecisionLike</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
              <span class="n">preferred_element_type</span><span class="p">:</span> <span class="n">DTypeLike</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Array</span><span class="p">:</span>
  <span class="n">util</span><span class="o">.</span><span class="n">check_arraylike</span><span class="p">(</span><span class="s2">&quot;tensordot&quot;</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
  <span class="n">dtypes</span><span class="o">.</span><span class="n">check_user_dtype_supported</span><span class="p">(</span><span class="n">preferred_element_type</span><span class="p">,</span> <span class="s2">&quot;tensordot&quot;</span><span class="p">)</span>
  <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">asarray</span><span class="p">(</span><span class="n">a</span><span class="p">),</span> <span class="n">asarray</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
  <span class="n">a_ndim</span> <span class="o">=</span> <span class="n">ndim</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
  <span class="n">b_ndim</span> <span class="o">=</span> <span class="n">ndim</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>

  <span class="k">if</span> <span class="n">preferred_element_type</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
    <span class="n">preferred_element_type</span><span class="p">,</span> <span class="n">output_weak_type</span> <span class="o">=</span> <span class="n">dtypes</span><span class="o">.</span><span class="n">result_type</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">return_weak_type_flag</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="n">output_weak_type</span> <span class="o">=</span> <span class="kc">False</span>

  <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">axes</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">int</span><span class="p">:</span>
    <span class="k">if</span> <span class="n">axes</span> <span class="o">&gt;</span> <span class="nb">min</span><span class="p">(</span><span class="n">a_ndim</span><span class="p">,</span> <span class="n">b_ndim</span><span class="p">):</span>
      <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;Number of tensordot axes (axes </span><span class="si">{}</span><span class="s2">) exceeds input ranks (</span><span class="si">{}</span><span class="s2"> and </span><span class="si">{}</span><span class="s2">)&quot;</span>
      <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="n">msg</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">axes</span><span class="p">,</span> <span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">b</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>
    <span class="n">contracting_dims</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">a_ndim</span> <span class="o">-</span> <span class="n">axes</span><span class="p">,</span> <span class="n">a_ndim</span><span class="p">)),</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">axes</span><span class="p">))</span>
  <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">axes</span><span class="p">,</span> <span class="p">(</span><span class="nb">tuple</span><span class="p">,</span> <span class="nb">list</span><span class="p">))</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">axes</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
    <span class="n">ax1</span><span class="p">,</span> <span class="n">ax2</span> <span class="o">=</span> <span class="n">axes</span>
    <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">ax1</span><span class="p">)</span> <span class="o">==</span> <span class="nb">type</span><span class="p">(</span><span class="n">ax2</span><span class="p">)</span> <span class="o">==</span> <span class="nb">int</span><span class="p">:</span>
      <span class="n">contracting_dims</span> <span class="o">=</span> <span class="p">((</span><span class="n">_canonicalize_axis</span><span class="p">(</span><span class="n">ax1</span><span class="p">,</span> <span class="n">a_ndim</span><span class="p">),),</span>
                          <span class="p">(</span><span class="n">_canonicalize_axis</span><span class="p">(</span><span class="n">ax2</span><span class="p">,</span> <span class="n">b_ndim</span><span class="p">),))</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ax1</span><span class="p">,</span> <span class="p">(</span><span class="nb">tuple</span><span class="p">,</span> <span class="nb">list</span><span class="p">))</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ax2</span><span class="p">,</span> <span class="p">(</span><span class="nb">tuple</span><span class="p">,</span> <span class="nb">list</span><span class="p">)):</span>
      <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ax1</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">ax2</span><span class="p">):</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;tensordot requires axes lists to have equal length, got </span><span class="si">{}</span><span class="s2"> and </span><span class="si">{}</span><span class="s2">.&quot;</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="n">msg</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">ax1</span><span class="p">,</span> <span class="n">ax2</span><span class="p">))</span>
      <span class="n">contracting_dims</span> <span class="o">=</span> <span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">_canonicalize_axis</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">a_ndim</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">ax1</span><span class="p">),</span>
                          <span class="nb">tuple</span><span class="p">(</span><span class="n">_canonicalize_axis</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">b_ndim</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">ax2</span><span class="p">))</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;tensordot requires both axes lists to be either ints, tuples or &quot;</span>
             <span class="s2">&quot;lists, got </span><span class="si">{}</span><span class="s2"> and </span><span class="si">{}</span><span class="s2">&quot;</span><span class="p">)</span>
      <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="n">msg</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">ax1</span><span class="p">,</span> <span class="n">ax2</span><span class="p">))</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;tensordot axes argument must be an int, a pair of ints, or a pair &quot;</span>
           <span class="s2">&quot;of lists/tuples of ints.&quot;</span><span class="p">)</span>
    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
  <span class="n">result</span> <span class="o">=</span> <span class="n">lax</span><span class="o">.</span><span class="n">dot_general</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="p">(</span><span class="n">contracting_dims</span><span class="p">,</span> <span class="p">((),</span> <span class="p">())),</span>
                           <span class="n">precision</span><span class="o">=</span><span class="n">precision</span><span class="p">,</span> <span class="n">preferred_element_type</span><span class="o">=</span><span class="n">preferred_element_type</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">lax_internal</span><span class="o">.</span><span class="n">_convert_element_type</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">preferred_element_type</span><span class="p">,</span> <span class="n">output_weak_type</span><span class="p">)</span>


<span class="n">_EINSUM_DOC</span> <span class="o">=</span> <span class="n">_PRECISION_DOC</span> <span class="o">+</span> <span class="s2">&quot;&quot;&quot;</span><span class="se">\</span>
<span class="s2">A tuple ``precision`` does not necessarily map to multiple arguments of ``einsum()``;</span>
<span class="s2">rather, the specified ``precision`` is forwarded to each ``dot_general`` call used in</span>
<span class="s2">the implementation.</span>
<span class="s2">&quot;&quot;&quot;</span>

<span class="nd">@overload</span>
<span class="k">def</span> <span class="nf">einsum</span><span class="p">(</span>
    <span class="n">subscript</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="n">operands</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">optimize</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;optimal&quot;</span><span class="p">,</span>
    <span class="n">precision</span><span class="p">:</span> <span class="n">PrecisionLike</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">preferred_element_type</span><span class="p">:</span> <span class="n">DTypeLike</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">_use_xeinsum</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">_dot_general</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="n">lax</span><span class="o">.</span><span class="n">dot_general</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Array</span><span class="p">:</span> <span class="o">...</span>

<span class="nd">@overload</span>
<span class="k">def</span> <span class="nf">einsum</span><span class="p">(</span>
    <span class="n">arr</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">,</span>
    <span class="n">axes</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">Any</span><span class="p">],</span> <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="n">operands</span><span class="p">:</span> <span class="n">ArrayLike</span> <span class="o">|</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">Any</span><span class="p">],</span>
    <span class="n">out</span><span class="p">:</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">optimize</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;optimal&quot;</span><span class="p">,</span>
    <span class="n">precision</span><span class="p">:</span> <span class="n">PrecisionLike</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">preferred_element_type</span><span class="p">:</span> <span class="n">DTypeLike</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">_use_xeinsum</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">_dot_general</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="n">lax</span><span class="o">.</span><span class="n">dot_general</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Array</span><span class="p">:</span> <span class="o">...</span>

<span class="nd">@util</span><span class="o">.</span><span class="n">_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">,</span> <span class="n">lax_description</span><span class="o">=</span><span class="n">_EINSUM_DOC</span><span class="p">,</span> <span class="n">skip_params</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;out&#39;</span><span class="p">])</span>
<span class="k">def</span> <span class="nf">einsum</span><span class="p">(</span>
    <span class="n">subscripts</span><span class="p">,</span> <span class="o">/</span><span class="p">,</span>
    <span class="o">*</span><span class="n">operands</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">optimize</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;optimal&quot;</span><span class="p">,</span>
    <span class="n">precision</span><span class="p">:</span> <span class="n">PrecisionLike</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">preferred_element_type</span><span class="p">:</span> <span class="n">DTypeLike</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">_use_xeinsum</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">_dot_general</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">Array</span><span class="p">]</span> <span class="o">=</span> <span class="n">lax</span><span class="o">.</span><span class="n">dot_general</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Array</span><span class="p">:</span>
  <span class="n">operands</span> <span class="o">=</span> <span class="p">(</span><span class="n">subscripts</span><span class="p">,</span> <span class="o">*</span><span class="n">operands</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">out</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
    <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;The &#39;out&#39; argument to jnp.einsum is not supported.&quot;</span><span class="p">)</span>

  <span class="n">spec</span> <span class="o">=</span> <span class="n">operands</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">operands</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">str</span><span class="p">)</span> <span class="k">else</span> <span class="kc">None</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">_use_xeinsum</span> <span class="ow">or</span> <span class="n">spec</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="s1">&#39;{&#39;</span> <span class="ow">in</span> <span class="n">spec</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">jax</span><span class="o">.</span><span class="n">named_call</span><span class="p">(</span><span class="n">lax</span><span class="o">.</span><span class="n">xeinsum</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">spec</span><span class="p">)(</span><span class="o">*</span><span class="n">operands</span><span class="p">)</span>

  <span class="n">optimize</span> <span class="o">=</span> <span class="s1">&#39;optimal&#39;</span> <span class="k">if</span> <span class="n">optimize</span> <span class="ow">is</span> <span class="kc">True</span> <span class="k">else</span> <span class="n">optimize</span>
  <span class="c1"># using einsum_call=True here is an internal api for opt_einsum</span>

  <span class="c1"># Allow handling of shape polymorphism</span>
  <span class="n">non_constant_dim_types</span> <span class="o">=</span> <span class="p">{</span>
      <span class="nb">type</span><span class="p">(</span><span class="n">d</span><span class="p">)</span> <span class="k">for</span> <span class="n">op</span> <span class="ow">in</span> <span class="n">operands</span> <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span>
      <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">op</span><span class="p">)</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">core</span><span class="o">.</span><span class="n">is_constant_dim</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
  <span class="p">}</span>
  <span class="k">if</span> <span class="ow">not</span> <span class="n">non_constant_dim_types</span><span class="p">:</span>
    <span class="n">contract_path</span> <span class="o">=</span> <span class="n">opt_einsum</span><span class="o">.</span><span class="n">contract_path</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="n">ty</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="nb">iter</span><span class="p">(</span><span class="n">non_constant_dim_types</span><span class="p">))</span>
    <span class="n">contract_path</span> <span class="o">=</span> <span class="n">_poly_einsum_handlers</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">ty</span><span class="p">,</span> <span class="n">_default_poly_einsum_handler</span><span class="p">)</span>
  <span class="n">operands</span><span class="p">,</span> <span class="n">contractions</span> <span class="o">=</span> <span class="n">contract_path</span><span class="p">(</span>
        <span class="o">*</span><span class="n">operands</span><span class="p">,</span> <span class="n">einsum_call</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">use_blas</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">optimize</span><span class="o">=</span><span class="n">optimize</span><span class="p">)</span>

  <span class="n">contractions</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">((</span><span class="n">a</span><span class="p">,</span> <span class="nb">frozenset</span><span class="p">(</span><span class="n">b</span><span class="p">),</span> <span class="n">c</span><span class="p">)</span> <span class="k">for</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="o">*</span><span class="n">_</span> <span class="ow">in</span> <span class="n">contractions</span><span class="p">)</span>

  <span class="n">_einsum_computation</span> <span class="o">=</span> <span class="n">jax</span><span class="o">.</span><span class="n">named_call</span><span class="p">(</span>
      <span class="n">_einsum</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">spec</span><span class="p">)</span> <span class="k">if</span> <span class="n">spec</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">_einsum</span>
  <span class="k">return</span> <span class="n">_einsum_computation</span><span class="p">(</span><span class="n">operands</span><span class="p">,</span> <span class="n">contractions</span><span class="p">,</span> <span class="n">precision</span><span class="p">,</span>  <span class="c1"># type: ignore[operator]</span>
                             <span class="n">preferred_element_type</span><span class="p">,</span> <span class="n">_dot_general</span><span class="p">)</span>


<span class="c1"># Enable other modules to override einsum_contact_path.</span>
<span class="c1"># Indexed by the type of the non constant dimension</span>
<span class="n">_poly_einsum_handlers</span> <span class="o">=</span> <span class="p">{}</span>  <span class="c1"># type: ignore</span>

<span class="k">def</span> <span class="nf">_default_poly_einsum_handler</span><span class="p">(</span><span class="o">*</span><span class="n">operands</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
  <span class="n">dummy</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">namedtuple</span><span class="p">(</span><span class="s1">&#39;dummy&#39;</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;shape&#39;</span><span class="p">,</span> <span class="s1">&#39;dtype&#39;</span><span class="p">])</span>
  <span class="n">dummies</span> <span class="o">=</span> <span class="p">[</span><span class="n">dummy</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">d</span> <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">d</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">int</span> <span class="k">else</span> <span class="mi">8</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">),</span> <span class="n">x</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
             <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="s1">&#39;dtype&#39;</span><span class="p">)</span> <span class="k">else</span> <span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">operands</span><span class="p">]</span>
  <span class="n">mapping</span> <span class="o">=</span> <span class="p">{</span><span class="nb">id</span><span class="p">(</span><span class="n">d</span><span class="p">):</span> <span class="n">i</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">d</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">dummies</span><span class="p">)}</span>
  <span class="n">out_dummies</span><span class="p">,</span> <span class="n">contractions</span> <span class="o">=</span> <span class="n">opt_einsum</span><span class="o">.</span><span class="n">contract_path</span><span class="p">(</span><span class="o">*</span><span class="n">dummies</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
  <span class="n">contract_operands</span> <span class="o">=</span> <span class="p">[</span><span class="n">operands</span><span class="p">[</span><span class="n">mapping</span><span class="p">[</span><span class="nb">id</span><span class="p">(</span><span class="n">d</span><span class="p">)]]</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">out_dummies</span><span class="p">]</span>
  <span class="k">return</span> <span class="n">contract_operands</span><span class="p">,</span> <span class="n">contractions</span>

<span class="nd">@util</span><span class="o">.</span><span class="n">_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">einsum_path</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">einsum_path</span><span class="p">(</span><span class="n">subscripts</span><span class="p">,</span> <span class="o">*</span><span class="n">operands</span><span class="p">,</span> <span class="n">optimize</span><span class="o">=</span><span class="s1">&#39;greedy&#39;</span><span class="p">):</span>
  <span class="c1"># using einsum_call=True here is an internal api for opt_einsum</span>
  <span class="k">return</span> <span class="n">opt_einsum</span><span class="o">.</span><span class="n">contract_path</span><span class="p">(</span><span class="n">subscripts</span><span class="p">,</span> <span class="o">*</span><span class="n">operands</span><span class="p">,</span> <span class="n">optimize</span><span class="o">=</span><span class="n">optimize</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">_removechars</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">chars</span><span class="p">):</span>
  <span class="k">return</span> <span class="n">s</span><span class="o">.</span><span class="n">translate</span><span class="p">(</span><span class="nb">str</span><span class="o">.</span><span class="n">maketrans</span><span class="p">(</span><span class="nb">dict</span><span class="o">.</span><span class="n">fromkeys</span><span class="p">(</span><span class="n">chars</span><span class="p">)))</span>


<span class="nd">@partial</span><span class="p">(</span><span class="n">jit</span><span class="p">,</span> <span class="n">static_argnums</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span> <span class="n">inline</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">_einsum</span><span class="p">(</span>
    <span class="n">operands</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">,</span>
    <span class="n">contractions</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="o">...</span><span class="p">],</span> <span class="nb">frozenset</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="nb">str</span><span class="p">]],</span>
    <span class="n">precision</span><span class="p">,</span>
    <span class="n">preferred_element_type</span><span class="p">,</span>
    <span class="n">_dot_general</span><span class="o">=</span><span class="n">lax</span><span class="o">.</span><span class="n">dot_general</span><span class="p">,</span>
<span class="p">):</span>
  <span class="n">dtypes</span><span class="o">.</span><span class="n">check_user_dtype_supported</span><span class="p">(</span><span class="n">preferred_element_type</span><span class="p">,</span> <span class="s2">&quot;einsum&quot;</span><span class="p">)</span>
  <span class="n">operands</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">asarray</span><span class="p">,</span> <span class="n">operands</span><span class="p">))</span>
  <span class="k">if</span> <span class="n">preferred_element_type</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
    <span class="n">preferred_element_type</span><span class="p">,</span> <span class="n">output_weak_type</span> <span class="o">=</span> <span class="n">dtypes</span><span class="o">.</span><span class="n">result_type</span><span class="p">(</span><span class="o">*</span><span class="n">operands</span><span class="p">,</span> <span class="n">return_weak_type_flag</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="n">output_weak_type</span> <span class="o">=</span> <span class="kc">False</span>

  <span class="k">def</span> <span class="nf">sum</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">axes</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">dtypes</span><span class="o">.</span><span class="n">result_type</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">preferred_element_type</span><span class="p">)</span> <span class="o">!=</span> <span class="n">x</span><span class="o">.</span><span class="n">dtype</span><span class="p">:</span>
      <span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">preferred_element_type</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">lax</span><span class="o">.</span><span class="n">reduce</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">x</span><span class="o">.</span><span class="n">dtype</span><span class="p">),</span>
                      <span class="n">lax</span><span class="o">.</span><span class="n">add</span> <span class="k">if</span> <span class="n">x</span><span class="o">.</span><span class="n">dtype</span> <span class="o">!=</span> <span class="n">bool_</span> <span class="k">else</span> <span class="n">lax</span><span class="o">.</span><span class="n">bitwise_or</span><span class="p">,</span> <span class="n">axes</span><span class="p">)</span>

  <span class="k">def</span> <span class="nf">sum_uniques</span><span class="p">(</span><span class="n">operand</span><span class="p">,</span> <span class="n">names</span><span class="p">,</span> <span class="n">uniques</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">uniques</span><span class="p">:</span>
      <span class="n">axes</span> <span class="o">=</span> <span class="p">[</span><span class="n">names</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">name</span><span class="p">)</span> <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">uniques</span><span class="p">]</span>
      <span class="n">operand</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">operand</span><span class="p">,</span> <span class="n">axes</span><span class="p">)</span>
      <span class="n">names</span> <span class="o">=</span> <span class="n">_removechars</span><span class="p">(</span><span class="n">names</span><span class="p">,</span> <span class="n">uniques</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">operand</span><span class="p">,</span> <span class="n">names</span>

  <span class="k">def</span> <span class="nf">sum_repeats</span><span class="p">(</span><span class="n">operand</span><span class="p">,</span> <span class="n">names</span><span class="p">,</span> <span class="n">counts</span><span class="p">,</span> <span class="n">keep_names</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">count</span> <span class="ow">in</span> <span class="n">counts</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
      <span class="k">if</span> <span class="n">count</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">axes</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">names</span><span class="p">)</span> <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="n">name</span><span class="p">]</span>
        <span class="n">eye</span> <span class="o">=</span> <span class="n">lax_internal</span><span class="o">.</span><span class="n">_delta</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="s1">&#39;bool&#39;</span><span class="p">),</span> <span class="n">operand</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">axes</span><span class="p">)</span>
        <span class="n">operand</span> <span class="o">=</span> <span class="n">lax</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="n">eye</span><span class="p">,</span> <span class="n">operand</span><span class="p">,</span> <span class="n">zeros_like</span><span class="p">(</span><span class="n">operand</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">keep_names</span><span class="p">:</span>
          <span class="n">operand</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">operand</span><span class="p">,</span> <span class="n">axes</span><span class="p">)</span>
          <span class="n">names</span> <span class="o">=</span> <span class="n">names</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
          <span class="n">operand</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">operand</span><span class="p">,</span> <span class="n">axes</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
          <span class="n">names</span> <span class="o">=</span> <span class="n">names</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">count</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">operand</span><span class="p">,</span> <span class="n">names</span>

  <span class="k">def</span> <span class="nf">filter_singleton_dims</span><span class="p">(</span><span class="n">operand</span><span class="p">,</span> <span class="n">names</span><span class="p">,</span> <span class="n">other_shape</span><span class="p">,</span> <span class="n">other_names</span><span class="p">):</span>
    <span class="n">eq</span> <span class="o">=</span> <span class="n">core</span><span class="o">.</span><span class="n">definitely_equal</span>
    <span class="n">keep</span> <span class="o">=</span> <span class="p">[</span><span class="ow">not</span> <span class="n">eq</span><span class="p">(</span><span class="n">operand</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="mi">1</span><span class="p">)</span> <span class="ow">or</span> <span class="n">j</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span> <span class="ow">or</span> <span class="n">eq</span><span class="p">(</span><span class="n">other_shape</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="mi">1</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">other_names</span><span class="o">.</span><span class="n">find</span><span class="p">,</span> <span class="n">names</span><span class="p">))]</span>
    <span class="n">sqez_axes</span><span class="p">,</span> <span class="n">keep_axes</span> <span class="o">=</span> <span class="n">partition_list</span><span class="p">(</span><span class="n">keep</span><span class="p">,</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">operand</span><span class="o">.</span><span class="n">ndim</span><span class="p">)))</span>
    <span class="k">return</span> <span class="n">lax</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">operand</span><span class="p">,</span> <span class="n">sqez_axes</span><span class="p">),</span> <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">names</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">keep_axes</span><span class="p">)</span>

  <span class="k">for</span> <span class="n">operand_indices</span><span class="p">,</span> <span class="n">contracted_names_set</span><span class="p">,</span> <span class="n">einstr</span> <span class="ow">in</span> <span class="n">contractions</span><span class="p">:</span>
    <span class="n">contracted_names</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">contracted_names_set</span><span class="p">)</span>
    <span class="n">input_str</span><span class="p">,</span> <span class="n">result_names</span> <span class="o">=</span> <span class="n">einstr</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;-&gt;&#39;</span><span class="p">)</span>
    <span class="n">input_names</span> <span class="o">=</span> <span class="n">input_str</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;,&#39;</span><span class="p">)</span>

    <span class="c1"># switch on the number of operands to be processed in this loop iteration.</span>
    <span class="c1"># every case here sets &#39;operand&#39; and &#39;names&#39;.</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">operand_indices</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
      <span class="n">operand</span> <span class="o">=</span> <span class="n">operands</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">operand_indices</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
      <span class="n">names</span><span class="p">,</span> <span class="o">=</span> <span class="n">input_names</span>
      <span class="n">counts</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">Counter</span><span class="p">(</span><span class="n">names</span><span class="p">)</span>

      <span class="c1"># sum out unique contracted indices with a single reduce-sum</span>
      <span class="n">uniques</span> <span class="o">=</span> <span class="p">[</span><span class="n">name</span> <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">contracted_names</span> <span class="k">if</span> <span class="n">counts</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">]</span>
      <span class="n">operand</span><span class="p">,</span> <span class="n">names</span> <span class="o">=</span> <span class="n">sum_uniques</span><span class="p">(</span><span class="n">operand</span><span class="p">,</span> <span class="n">names</span><span class="p">,</span> <span class="n">uniques</span><span class="p">)</span>

      <span class="c1"># for every repeated index, do a contraction against an identity matrix</span>
      <span class="n">operand</span><span class="p">,</span> <span class="n">names</span> <span class="o">=</span> <span class="n">sum_repeats</span><span class="p">(</span><span class="n">operand</span><span class="p">,</span> <span class="n">names</span><span class="p">,</span> <span class="n">counts</span><span class="p">,</span> <span class="n">result_names</span><span class="p">)</span>

    <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">operand_indices</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
      <span class="n">lhs</span><span class="p">,</span> <span class="n">rhs</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="n">operands</span><span class="o">.</span><span class="n">pop</span><span class="p">,</span> <span class="n">operand_indices</span><span class="p">)</span>
      <span class="n">lhs_names</span><span class="p">,</span> <span class="n">rhs_names</span> <span class="o">=</span> <span class="n">input_names</span>

      <span class="c1"># handle cases where one side of a contracting or batch dimension is 1</span>
      <span class="c1"># but its counterpart is not.</span>
      <span class="n">lhs</span><span class="p">,</span> <span class="n">lhs_names</span> <span class="o">=</span> <span class="n">filter_singleton_dims</span><span class="p">(</span><span class="n">lhs</span><span class="p">,</span> <span class="n">lhs_names</span><span class="p">,</span> <span class="n">shape</span><span class="p">(</span><span class="n">rhs</span><span class="p">),</span>
                                             <span class="n">rhs_names</span><span class="p">)</span>
      <span class="n">rhs</span><span class="p">,</span> <span class="n">rhs_names</span> <span class="o">=</span> <span class="n">filter_singleton_dims</span><span class="p">(</span><span class="n">rhs</span><span class="p">,</span> <span class="n">rhs_names</span><span class="p">,</span> <span class="n">shape</span><span class="p">(</span><span class="n">lhs</span><span class="p">),</span>
                                             <span class="n">lhs_names</span><span class="p">)</span>

      <span class="n">lhs_counts</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">Counter</span><span class="p">(</span><span class="n">lhs_names</span><span class="p">)</span>
      <span class="n">rhs_counts</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">Counter</span><span class="p">(</span><span class="n">rhs_names</span><span class="p">)</span>

      <span class="c1"># sum out unique contracted indices in lhs and rhs</span>
      <span class="n">lhs_uniques</span> <span class="o">=</span> <span class="p">[</span><span class="n">name</span> <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">contracted_names</span>
                     <span class="k">if</span> <span class="n">lhs_counts</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">rhs_counts</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">]</span>
      <span class="n">lhs</span><span class="p">,</span> <span class="n">lhs_names</span> <span class="o">=</span> <span class="n">sum_uniques</span><span class="p">(</span><span class="n">lhs</span><span class="p">,</span> <span class="n">lhs_names</span><span class="p">,</span> <span class="n">lhs_uniques</span><span class="p">)</span>

      <span class="n">rhs_uniques</span> <span class="o">=</span> <span class="p">[</span><span class="n">name</span> <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">contracted_names</span>
                     <span class="k">if</span> <span class="n">rhs_counts</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">lhs_counts</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">]</span>
      <span class="n">rhs</span><span class="p">,</span> <span class="n">rhs_names</span> <span class="o">=</span> <span class="n">sum_uniques</span><span class="p">(</span><span class="n">rhs</span><span class="p">,</span> <span class="n">rhs_names</span><span class="p">,</span> <span class="n">rhs_uniques</span><span class="p">)</span>

      <span class="c1"># for every repeated index, contract against an identity matrix</span>
      <span class="n">lhs</span><span class="p">,</span> <span class="n">lhs_names</span> <span class="o">=</span> <span class="n">sum_repeats</span><span class="p">(</span><span class="n">lhs</span><span class="p">,</span> <span class="n">lhs_names</span><span class="p">,</span> <span class="n">lhs_counts</span><span class="p">,</span>
                                   <span class="n">result_names</span> <span class="o">+</span> <span class="n">rhs_names</span><span class="p">)</span>
      <span class="n">rhs</span><span class="p">,</span> <span class="n">rhs_names</span> <span class="o">=</span> <span class="n">sum_repeats</span><span class="p">(</span><span class="n">rhs</span><span class="p">,</span> <span class="n">rhs_names</span><span class="p">,</span> <span class="n">rhs_counts</span><span class="p">,</span>
                                   <span class="n">result_names</span> <span class="o">+</span> <span class="n">lhs_names</span><span class="p">)</span>

      <span class="n">lhs_or_rhs_names</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">lhs_names</span><span class="p">)</span> <span class="o">|</span> <span class="nb">set</span><span class="p">(</span><span class="n">rhs_names</span><span class="p">)</span>
      <span class="n">contracted_names</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">contracted_names</span> <span class="k">if</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">lhs_or_rhs_names</span><span class="p">]</span>
      <span class="n">lhs_and_rhs_names</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">lhs_names</span><span class="p">)</span> <span class="o">&amp;</span> <span class="nb">set</span><span class="p">(</span><span class="n">rhs_names</span><span class="p">)</span>
      <span class="n">batch_names</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">result_names</span> <span class="k">if</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">lhs_and_rhs_names</span><span class="p">]</span>

      <span class="n">lhs_batch</span><span class="p">,</span> <span class="n">rhs_batch</span> <span class="o">=</span> <span class="n">unzip2</span><span class="p">((</span><span class="n">lhs_names</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="n">n</span><span class="p">),</span> <span class="n">rhs_names</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="n">n</span><span class="p">))</span>
                                    <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">batch_names</span><span class="p">)</span>

      <span class="c1"># NOTE(mattjj): this can fail non-deterministically in python3, maybe</span>
      <span class="c1"># due to opt_einsum</span>
      <span class="k">assert</span> <span class="n">jax</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">jax_dynamic_shapes</span> <span class="ow">or</span> <span class="nb">all</span><span class="p">(</span>
        <span class="n">name</span> <span class="ow">in</span> <span class="n">lhs_names</span> <span class="ow">and</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">rhs_names</span> <span class="ow">and</span>
        <span class="n">lhs</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">lhs_names</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">name</span><span class="p">)]</span> <span class="o">==</span> <span class="n">rhs</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">rhs_names</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">name</span><span class="p">)]</span>
        <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">contracted_names</span><span class="p">),</span> <span class="p">(</span>
          <span class="s2">&quot;Incompatible reduction dimensions: &quot;</span>
          <span class="sa">f</span><span class="s2">&quot;lhs.shape=</span><span class="si">{</span><span class="n">lhs</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2"> lhs_names=</span><span class="si">{</span><span class="n">lhs_names</span><span class="si">}</span><span class="s2"> &quot;</span>
          <span class="sa">f</span><span class="s2">&quot;rhs.shape=</span><span class="si">{</span><span class="n">rhs</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2"> rhs_names=</span><span class="si">{</span><span class="n">rhs_names</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

      <span class="c1"># contract using dot_general</span>
      <span class="n">batch_names_str</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">batch_names</span><span class="p">)</span>
      <span class="n">lhs_cont</span><span class="p">,</span> <span class="n">rhs_cont</span> <span class="o">=</span> <span class="n">unzip2</span><span class="p">((</span><span class="n">lhs_names</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">n</span><span class="p">),</span> <span class="n">rhs_names</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">n</span><span class="p">))</span>
                                  <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">contracted_names</span><span class="p">)</span>
      <span class="n">deleted_names</span> <span class="o">=</span> <span class="n">batch_names_str</span> <span class="o">+</span> <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">contracted_names</span><span class="p">)</span>
      <span class="n">remaining_lhs_names</span> <span class="o">=</span> <span class="n">_removechars</span><span class="p">(</span><span class="n">lhs_names</span><span class="p">,</span> <span class="n">deleted_names</span><span class="p">)</span>
      <span class="n">remaining_rhs_names</span> <span class="o">=</span> <span class="n">_removechars</span><span class="p">(</span><span class="n">rhs_names</span><span class="p">,</span> <span class="n">deleted_names</span><span class="p">)</span>
      <span class="c1"># Try both orders of lhs and rhs, in the hope that one of them means we</span>
      <span class="c1"># don&#39;t need an explicit transpose. opt_einsum likes to contract from</span>
      <span class="c1"># right to left, so we expect (rhs,lhs) to have the best chance of not</span>
      <span class="c1"># needing a transpose.</span>
      <span class="n">names</span> <span class="o">=</span> <span class="n">batch_names_str</span> <span class="o">+</span> <span class="n">remaining_rhs_names</span> <span class="o">+</span> <span class="n">remaining_lhs_names</span>
      <span class="k">if</span> <span class="n">names</span> <span class="o">==</span> <span class="n">result_names</span><span class="p">:</span>
        <span class="n">dimension_numbers</span> <span class="o">=</span> <span class="p">((</span><span class="n">rhs_cont</span><span class="p">,</span> <span class="n">lhs_cont</span><span class="p">),</span> <span class="p">(</span><span class="n">rhs_batch</span><span class="p">,</span> <span class="n">lhs_batch</span><span class="p">))</span>
        <span class="n">operand</span> <span class="o">=</span> <span class="n">_dot_general</span><span class="p">(</span><span class="n">rhs</span><span class="p">,</span> <span class="n">lhs</span><span class="p">,</span> <span class="n">dimension_numbers</span><span class="p">,</span> <span class="n">precision</span><span class="p">,</span>
                               <span class="n">preferred_element_type</span><span class="o">=</span><span class="n">preferred_element_type</span><span class="p">)</span>
      <span class="k">else</span><span class="p">:</span>
        <span class="n">names</span> <span class="o">=</span> <span class="n">batch_names_str</span> <span class="o">+</span> <span class="n">remaining_lhs_names</span> <span class="o">+</span> <span class="n">remaining_rhs_names</span>
        <span class="n">dimension_numbers</span> <span class="o">=</span> <span class="p">((</span><span class="n">lhs_cont</span><span class="p">,</span> <span class="n">rhs_cont</span><span class="p">),</span> <span class="p">(</span><span class="n">lhs_batch</span><span class="p">,</span> <span class="n">rhs_batch</span><span class="p">))</span>
        <span class="n">operand</span> <span class="o">=</span> <span class="n">_dot_general</span><span class="p">(</span><span class="n">lhs</span><span class="p">,</span> <span class="n">rhs</span><span class="p">,</span> <span class="n">dimension_numbers</span><span class="p">,</span> <span class="n">precision</span><span class="p">,</span>
                               <span class="n">preferred_element_type</span><span class="o">=</span><span class="n">preferred_element_type</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="k">raise</span> <span class="ne">NotImplementedError</span>  <span class="c1"># if this is actually reachable, open an issue!</span>

    <span class="c1"># the resulting &#39;operand&#39; with axis labels &#39;names&#39; should be a permutation</span>
    <span class="c1"># of the desired result</span>
    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">names</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">result_names</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">names</span><span class="p">))</span>
    <span class="k">assert</span> <span class="nb">set</span><span class="p">(</span><span class="n">names</span><span class="p">)</span> <span class="o">==</span> <span class="nb">set</span><span class="p">(</span><span class="n">result_names</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">names</span> <span class="o">!=</span> <span class="n">result_names</span><span class="p">:</span>
      <span class="n">perm</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">names</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">name</span><span class="p">)</span> <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">result_names</span><span class="p">)</span>
      <span class="n">operand</span> <span class="o">=</span> <span class="n">lax</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">operand</span><span class="p">,</span> <span class="n">perm</span><span class="p">)</span>
    <span class="n">operands</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">operand</span><span class="p">)</span>  <span class="c1"># used in next iteration</span>

  <span class="k">return</span> <span class="n">lax_internal</span><span class="o">.</span><span class="n">_convert_element_type</span><span class="p">(</span><span class="n">operands</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">preferred_element_type</span><span class="p">,</span> <span class="n">output_weak_type</span><span class="p">)</span>


<span class="nd">@util</span><span class="o">.</span><span class="n">_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">inner</span><span class="p">,</span> <span class="n">lax_description</span><span class="o">=</span><span class="n">_PRECISION_DOC</span><span class="p">)</span>
<span class="nd">@partial</span><span class="p">(</span><span class="n">jit</span><span class="p">,</span> <span class="n">static_argnames</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;precision&#39;</span><span class="p">,</span> <span class="s1">&#39;preferred_element_type&#39;</span><span class="p">),</span> <span class="n">inline</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">inner</span><span class="p">(</span>
    <span class="n">a</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">precision</span><span class="p">:</span> <span class="n">PrecisionLike</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">preferred_element_type</span><span class="p">:</span> <span class="n">DType</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Array</span><span class="p">:</span>
  <span class="k">if</span> <span class="n">ndim</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">ndim</span><span class="p">(</span><span class="n">b</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">asarray</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">preferred_element_type</span><span class="p">)</span>
    <span class="n">b</span> <span class="o">=</span> <span class="n">asarray</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">preferred_element_type</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">a</span> <span class="o">*</span> <span class="n">b</span>
  <span class="k">return</span> <span class="n">tensordot</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="n">precision</span><span class="o">=</span><span class="n">precision</span><span class="p">,</span>
                   <span class="n">preferred_element_type</span><span class="o">=</span><span class="n">preferred_element_type</span><span class="p">)</span>


<span class="nd">@util</span><span class="o">.</span><span class="n">_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">outer</span><span class="p">,</span> <span class="n">skip_params</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;out&#39;</span><span class="p">])</span>
<span class="nd">@partial</span><span class="p">(</span><span class="n">jit</span><span class="p">,</span> <span class="n">inline</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">outer</span><span class="p">(</span><span class="n">a</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">,</span> <span class="n">out</span><span class="p">:</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Array</span><span class="p">:</span>
  <span class="k">if</span> <span class="n">out</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
    <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;The &#39;out&#39; argument to jnp.outer is not supported.&quot;</span><span class="p">)</span>
  <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">util</span><span class="o">.</span><span class="n">promote_dtypes</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">ravel</span><span class="p">(</span><span class="n">a</span><span class="p">)[:,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="n">ravel</span><span class="p">(</span><span class="n">b</span><span class="p">)[</span><span class="kc">None</span><span class="p">,</span> <span class="p">:]</span>

<div class="viewcode-block" id="cross">
<a class="viewcode-back" href="../../../../source/magpi.html#magpi.calc.cross">[docs]</a>
<span class="nd">@util</span><span class="o">.</span><span class="n">_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">cross</span><span class="p">)</span>
<span class="nd">@partial</span><span class="p">(</span><span class="n">jit</span><span class="p">,</span> <span class="n">static_argnames</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;axisa&#39;</span><span class="p">,</span> <span class="s1">&#39;axisb&#39;</span><span class="p">,</span> <span class="s1">&#39;axisc&#39;</span><span class="p">,</span> <span class="s1">&#39;axis&#39;</span><span class="p">))</span>
<span class="k">def</span> <span class="nf">cross</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">axisa</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">axisb</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">axisc</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>
          <span class="n">axis</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
  <span class="k">if</span> <span class="n">axis</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
    <span class="n">axisa</span> <span class="o">=</span> <span class="n">axis</span>
    <span class="n">axisb</span> <span class="o">=</span> <span class="n">axis</span>
    <span class="n">axisc</span> <span class="o">=</span> <span class="n">axis</span>
  <span class="n">a</span> <span class="o">=</span> <span class="n">moveaxis</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axisa</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
  <span class="n">b</span> <span class="o">=</span> <span class="n">moveaxis</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">axisb</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>

  <span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span> <span class="ow">or</span> <span class="n">b</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">):</span>
    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Dimension must be either 2 or 3 for cross product&quot;</span><span class="p">)</span>

  <span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">2</span> <span class="ow">and</span> <span class="n">b</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">a</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">b</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">a</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">b</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>

  <span class="n">a0</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
  <span class="n">a1</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
  <span class="n">a2</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span> <span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">3</span> <span class="k">else</span> <span class="n">zeros_like</span><span class="p">(</span><span class="n">a0</span><span class="p">)</span>
  <span class="n">b0</span> <span class="o">=</span> <span class="n">b</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
  <span class="n">b1</span> <span class="o">=</span> <span class="n">b</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
  <span class="n">b2</span> <span class="o">=</span> <span class="n">b</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span> <span class="k">if</span> <span class="n">b</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">3</span> <span class="k">else</span> <span class="n">zeros_like</span><span class="p">(</span><span class="n">b0</span><span class="p">)</span>
  <span class="n">c</span> <span class="o">=</span> <span class="n">array</span><span class="p">([</span><span class="n">a1</span> <span class="o">*</span> <span class="n">b2</span> <span class="o">-</span> <span class="n">a2</span> <span class="o">*</span> <span class="n">b1</span><span class="p">,</span> <span class="n">a2</span> <span class="o">*</span> <span class="n">b0</span> <span class="o">-</span> <span class="n">a0</span> <span class="o">*</span> <span class="n">b2</span><span class="p">,</span> <span class="n">a0</span> <span class="o">*</span> <span class="n">b1</span> <span class="o">-</span> <span class="n">a1</span> <span class="o">*</span> <span class="n">b0</span><span class="p">])</span>
  <span class="k">return</span> <span class="n">moveaxis</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">axisc</span><span class="p">)</span></div>



<span class="nd">@util</span><span class="o">.</span><span class="n">_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">kron</span><span class="p">)</span>
<span class="nd">@jit</span>
<span class="k">def</span> <span class="nf">kron</span><span class="p">(</span><span class="n">a</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Array</span><span class="p">:</span>
  <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">util</span><span class="o">.</span><span class="n">promote_dtypes</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">ndim</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">ndim</span><span class="p">(</span><span class="n">b</span><span class="p">):</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">expand_dims</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="nb">range</span><span class="p">(</span><span class="n">ndim</span><span class="p">(</span><span class="n">b</span><span class="p">)</span> <span class="o">-</span> <span class="n">ndim</span><span class="p">(</span><span class="n">a</span><span class="p">)))</span>
  <span class="k">elif</span> <span class="n">ndim</span><span class="p">(</span><span class="n">b</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">ndim</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
    <span class="n">b</span> <span class="o">=</span> <span class="n">expand_dims</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="nb">range</span><span class="p">(</span><span class="n">ndim</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">-</span> <span class="n">ndim</span><span class="p">(</span><span class="n">b</span><span class="p">)))</span>
  <span class="n">a_reshaped</span> <span class="o">=</span> <span class="n">expand_dims</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">ndim</span><span class="p">(</span><span class="n">a</span><span class="p">),</span> <span class="mi">2</span><span class="p">))</span>
  <span class="n">b_reshaped</span> <span class="o">=</span> <span class="n">expand_dims</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">ndim</span><span class="p">(</span><span class="n">b</span><span class="p">),</span> <span class="mi">2</span><span class="p">))</span>
  <span class="n">out_shape</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span><span class="n">shape</span><span class="p">(</span><span class="n">a</span><span class="p">),</span> <span class="n">shape</span><span class="p">(</span><span class="n">b</span><span class="p">)))</span>
  <span class="k">return</span> <span class="n">reshape</span><span class="p">(</span><span class="n">lax</span><span class="o">.</span><span class="n">mul</span><span class="p">(</span><span class="n">a_reshaped</span><span class="p">,</span> <span class="n">b_reshaped</span><span class="p">),</span> <span class="n">out_shape</span><span class="p">)</span>


<span class="nd">@util</span><span class="o">.</span><span class="n">_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">vander</span><span class="p">)</span>
<span class="nd">@partial</span><span class="p">(</span><span class="n">jit</span><span class="p">,</span> <span class="n">static_argnames</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;N&#39;</span><span class="p">,</span> <span class="s1">&#39;increasing&#39;</span><span class="p">))</span>
<span class="k">def</span> <span class="nf">vander</span><span class="p">(</span>
    <span class="n">x</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">,</span> <span class="n">N</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">increasing</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Array</span><span class="p">:</span>
  <span class="n">util</span><span class="o">.</span><span class="n">check_arraylike</span><span class="p">(</span><span class="s2">&quot;vander&quot;</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
  <span class="n">x</span> <span class="o">=</span> <span class="n">asarray</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">x</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;x must be a one-dimensional array&quot;</span><span class="p">)</span>
  <span class="n">N</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">if</span> <span class="n">N</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">core</span><span class="o">.</span><span class="n">concrete_or_error</span><span class="p">(</span>
    <span class="n">operator</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="s2">&quot;&#39;N&#39; argument of jnp.vander()&quot;</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">N</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;N must be nonnegative&quot;</span><span class="p">)</span>

  <span class="n">iota</span> <span class="o">=</span> <span class="n">lax</span><span class="o">.</span><span class="n">iota</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">N</span><span class="p">)</span>
  <span class="k">if</span> <span class="ow">not</span> <span class="n">increasing</span><span class="p">:</span>
    <span class="n">iota</span> <span class="o">=</span> <span class="n">lax</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="n">_lax_const</span><span class="p">(</span><span class="n">iota</span><span class="p">,</span> <span class="n">N</span> <span class="o">-</span> <span class="mi">1</span><span class="p">),</span> <span class="n">iota</span><span class="p">)</span>

  <span class="k">return</span> <span class="n">ufuncs</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="kc">None</span><span class="p">],</span> <span class="n">expand_dims</span><span class="p">(</span><span class="n">iota</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">ndim</span><span class="p">))))</span>


<span class="c1">### Misc</span>

<span class="n">_ARGWHERE_DOC</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span><span class="se">\</span>
<span class="s2">Because the size of the output of ``argwhere`` is data-dependent, the function is not</span>
<span class="s2">typically compatible with JIT. The JAX version adds the optional ``size`` argument, which</span>
<span class="s2">specifies the size of the leading dimension of the output - it must be specified statically</span>
<span class="s2">for ``jnp.argwhere`` to be compiled with non-static operands. If ``size`` is specified,</span>
<span class="s2">the indices of the first ``size`` True elements will be returned; if there are fewer</span>
<span class="s2">nonzero elements than `size` indicates, the index arrays will be zero-padded.</span>
<span class="s2">&quot;&quot;&quot;</span>


<span class="nd">@util</span><span class="o">.</span><span class="n">_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">argwhere</span><span class="p">,</span>
  <span class="n">lax_description</span><span class="o">=</span><span class="n">_dedent</span><span class="p">(</span><span class="s2">&quot;&quot;&quot;</span>
<span class="s2">    Because the size of the output of ``argwhere`` is data-dependent, the function is not</span>
<span class="s2">    typically compatible with JIT. The JAX version adds the optional ``size`` argument which</span>
<span class="s2">    must be specified statically for ``jnp.argwhere`` to be used within some of JAX&#39;s</span>
<span class="s2">    transformations.&quot;&quot;&quot;</span><span class="p">),</span>
  <span class="n">extra_params</span><span class="o">=</span><span class="n">_dedent</span><span class="p">(</span><span class="s2">&quot;&quot;&quot;</span>
<span class="s2">    size : int, optional</span>
<span class="s2">        If specified, the indices of the first ``size`` True elements will be returned. If there</span>
<span class="s2">        are fewer results than ``size`` indicates, the return value will be padded with ``fill_value``.</span>
<span class="s2">    fill_value : array_like, optional</span>
<span class="s2">        When ``size`` is specified and there are fewer than the indicated number of elements, the</span>
<span class="s2">        remaining elements will be filled with ``fill_value``, which defaults to zero.&quot;&quot;&quot;</span><span class="p">))</span>
<span class="k">def</span> <span class="nf">argwhere</span><span class="p">(</span>
    <span class="n">a</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">size</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">fill_value</span><span class="p">:</span> <span class="n">ArrayLike</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Array</span><span class="p">:</span>
  <span class="n">result</span> <span class="o">=</span> <span class="n">transpose</span><span class="p">(</span><span class="n">vstack</span><span class="p">(</span><span class="n">nonzero</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="n">size</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="n">fill_value</span><span class="p">)))</span>
  <span class="k">if</span> <span class="n">ndim</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">result</span><span class="p">[:</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">result</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">0</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">result</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">result</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">ndim</span><span class="p">(</span><span class="n">a</span><span class="p">))</span>


<span class="nd">@util</span><span class="o">.</span><span class="n">_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">,</span> <span class="n">skip_params</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;out&#39;</span><span class="p">])</span>
<span class="k">def</span> <span class="nf">argmax</span><span class="p">(</span><span class="n">a</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">,</span> <span class="n">axis</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">out</span><span class="p">:</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
           <span class="n">keepdims</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Array</span><span class="p">:</span>
  <span class="n">util</span><span class="o">.</span><span class="n">check_arraylike</span><span class="p">(</span><span class="s2">&quot;argmax&quot;</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">out</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
    <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;The &#39;out&#39; argument to jnp.argmax is not supported.&quot;</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">_argmax</span><span class="p">(</span><span class="n">asarray</span><span class="p">(</span><span class="n">a</span><span class="p">),</span> <span class="kc">None</span> <span class="k">if</span> <span class="n">axis</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">operator</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">axis</span><span class="p">),</span>
                 <span class="n">keepdims</span><span class="o">=</span><span class="nb">bool</span><span class="p">(</span><span class="n">keepdims</span><span class="p">))</span>

<span class="nd">@partial</span><span class="p">(</span><span class="n">jit</span><span class="p">,</span> <span class="n">static_argnames</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;axis&#39;</span><span class="p">,</span> <span class="s1">&#39;keepdims&#39;</span><span class="p">),</span> <span class="n">inline</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">_argmax</span><span class="p">(</span><span class="n">a</span><span class="p">:</span> <span class="n">Array</span><span class="p">,</span> <span class="n">axis</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">keepdims</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Array</span><span class="p">:</span>
  <span class="k">if</span> <span class="n">axis</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
    <span class="n">dims</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">ndim</span><span class="p">(</span><span class="n">a</span><span class="p">)))</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">ravel</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="n">axis</span> <span class="o">=</span> <span class="mi">0</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="n">dims</span> <span class="o">=</span> <span class="p">[</span><span class="n">axis</span><span class="p">]</span>
  <span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;attempt to get argmax of an empty sequence&quot;</span><span class="p">)</span>
  <span class="n">result</span> <span class="o">=</span> <span class="n">lax</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">_canonicalize_axis</span><span class="p">(</span><span class="n">axis</span><span class="p">,</span> <span class="n">a</span><span class="o">.</span><span class="n">ndim</span><span class="p">),</span> <span class="n">dtypes</span><span class="o">.</span><span class="n">canonicalize_dtype</span><span class="p">(</span><span class="n">int_</span><span class="p">))</span>
  <span class="k">return</span> <span class="n">expand_dims</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">dims</span><span class="p">)</span> <span class="k">if</span> <span class="n">keepdims</span> <span class="k">else</span> <span class="n">result</span>

<span class="nd">@util</span><span class="o">.</span><span class="n">_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">,</span> <span class="n">skip_params</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;out&#39;</span><span class="p">])</span>
<span class="k">def</span> <span class="nf">argmin</span><span class="p">(</span><span class="n">a</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">,</span> <span class="n">axis</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">out</span><span class="p">:</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
           <span class="n">keepdims</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Array</span><span class="p">:</span>
  <span class="n">util</span><span class="o">.</span><span class="n">check_arraylike</span><span class="p">(</span><span class="s2">&quot;argmin&quot;</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">out</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
    <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;The &#39;out&#39; argument to jnp.argmin is not supported.&quot;</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">_argmin</span><span class="p">(</span><span class="n">asarray</span><span class="p">(</span><span class="n">a</span><span class="p">),</span> <span class="kc">None</span> <span class="k">if</span> <span class="n">axis</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">operator</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">axis</span><span class="p">),</span>
                 <span class="n">keepdims</span><span class="o">=</span><span class="nb">bool</span><span class="p">(</span><span class="n">keepdims</span><span class="p">))</span>

<span class="nd">@partial</span><span class="p">(</span><span class="n">jit</span><span class="p">,</span> <span class="n">static_argnames</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;axis&#39;</span><span class="p">,</span> <span class="s1">&#39;keepdims&#39;</span><span class="p">),</span> <span class="n">inline</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">_argmin</span><span class="p">(</span><span class="n">a</span><span class="p">:</span> <span class="n">Array</span><span class="p">,</span> <span class="n">axis</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">keepdims</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Array</span><span class="p">:</span>
  <span class="k">if</span> <span class="n">axis</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
    <span class="n">dims</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">ndim</span><span class="p">(</span><span class="n">a</span><span class="p">)))</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">ravel</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="n">axis</span> <span class="o">=</span> <span class="mi">0</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="n">dims</span> <span class="o">=</span> <span class="p">[</span><span class="n">axis</span><span class="p">]</span>
  <span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;attempt to get argmin of an empty sequence&quot;</span><span class="p">)</span>
  <span class="n">result</span> <span class="o">=</span> <span class="n">lax</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">_canonicalize_axis</span><span class="p">(</span><span class="n">axis</span><span class="p">,</span> <span class="n">a</span><span class="o">.</span><span class="n">ndim</span><span class="p">),</span> <span class="n">dtypes</span><span class="o">.</span><span class="n">canonicalize_dtype</span><span class="p">(</span><span class="n">int_</span><span class="p">))</span>
  <span class="k">return</span> <span class="n">expand_dims</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">dims</span><span class="p">)</span> <span class="k">if</span> <span class="n">keepdims</span> <span class="k">else</span> <span class="n">result</span>


<span class="n">_NANARG_DOC</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span><span class="se">\</span>
<span class="s2">Warning: jax.numpy.arg</span><span class="si">{}</span><span class="s2"> returns -1 for all-NaN slices and does not raise</span>
<span class="s2">an error.</span>
<span class="s2">&quot;&quot;&quot;</span>


<span class="nd">@util</span><span class="o">.</span><span class="n">_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nanargmax</span><span class="p">,</span> <span class="n">lax_description</span><span class="o">=</span><span class="n">_NANARG_DOC</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="s2">&quot;max&quot;</span><span class="p">),</span> <span class="n">skip_params</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;out&#39;</span><span class="p">])</span>
<span class="k">def</span> <span class="nf">nanargmax</span><span class="p">(</span>
    <span class="n">a</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">,</span>
    <span class="n">axis</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">keepdims</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Array</span><span class="p">:</span>
  <span class="k">if</span> <span class="n">out</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
    <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;The &#39;out&#39; argument to jnp.nanargmax is not supported.&quot;</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">_nanargmax</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="kc">None</span> <span class="k">if</span> <span class="n">axis</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">operator</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">axis</span><span class="p">),</span> <span class="n">keepdims</span><span class="o">=</span><span class="nb">bool</span><span class="p">(</span><span class="n">keepdims</span><span class="p">))</span>


<span class="nd">@partial</span><span class="p">(</span><span class="n">jit</span><span class="p">,</span> <span class="n">static_argnames</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;axis&#39;</span><span class="p">,</span> <span class="s1">&#39;keepdims&#39;</span><span class="p">))</span>
<span class="k">def</span> <span class="nf">_nanargmax</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">keepdims</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
  <span class="n">util</span><span class="o">.</span><span class="n">check_arraylike</span><span class="p">(</span><span class="s2">&quot;nanargmax&quot;</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
  <span class="k">if</span> <span class="ow">not</span> <span class="n">issubdtype</span><span class="p">(</span><span class="n">_dtype</span><span class="p">(</span><span class="n">a</span><span class="p">),</span> <span class="n">inexact</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">argmax</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="n">keepdims</span><span class="p">)</span>
  <span class="n">nan_mask</span> <span class="o">=</span> <span class="n">ufuncs</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
  <span class="n">a</span> <span class="o">=</span> <span class="n">where</span><span class="p">(</span><span class="n">nan_mask</span><span class="p">,</span> <span class="o">-</span><span class="n">inf</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
  <span class="n">res</span> <span class="o">=</span> <span class="n">argmax</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="n">keepdims</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">where</span><span class="p">(</span><span class="n">reductions</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">nan_mask</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="n">keepdims</span><span class="p">),</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">res</span><span class="p">)</span>


<span class="nd">@util</span><span class="o">.</span><span class="n">_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nanargmin</span><span class="p">,</span> <span class="n">lax_description</span><span class="o">=</span><span class="n">_NANARG_DOC</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="s2">&quot;min&quot;</span><span class="p">),</span>  <span class="n">skip_params</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;out&#39;</span><span class="p">])</span>
<span class="k">def</span> <span class="nf">nanargmin</span><span class="p">(</span>
    <span class="n">a</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">,</span>
    <span class="n">axis</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">keepdims</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Array</span><span class="p">:</span>
  <span class="k">if</span> <span class="n">out</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
    <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;The &#39;out&#39; argument to jnp.nanargmin is not supported.&quot;</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">_nanargmin</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="kc">None</span> <span class="k">if</span> <span class="n">axis</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">operator</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">axis</span><span class="p">),</span> <span class="n">keepdims</span><span class="o">=</span><span class="nb">bool</span><span class="p">(</span><span class="n">keepdims</span><span class="p">))</span>


<span class="nd">@partial</span><span class="p">(</span><span class="n">jit</span><span class="p">,</span> <span class="n">static_argnames</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;axis&#39;</span><span class="p">,</span> <span class="s1">&#39;keepdims&#39;</span><span class="p">))</span>
<span class="k">def</span> <span class="nf">_nanargmin</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">keepdims</span> <span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
  <span class="n">util</span><span class="o">.</span><span class="n">check_arraylike</span><span class="p">(</span><span class="s2">&quot;nanargmin&quot;</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
  <span class="k">if</span> <span class="ow">not</span> <span class="n">issubdtype</span><span class="p">(</span><span class="n">_dtype</span><span class="p">(</span><span class="n">a</span><span class="p">),</span> <span class="n">inexact</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">argmin</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="n">keepdims</span><span class="p">)</span>
  <span class="n">nan_mask</span> <span class="o">=</span> <span class="n">ufuncs</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
  <span class="n">a</span> <span class="o">=</span> <span class="n">where</span><span class="p">(</span><span class="n">nan_mask</span><span class="p">,</span> <span class="n">inf</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
  <span class="n">res</span> <span class="o">=</span> <span class="n">argmin</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="n">keepdims</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">where</span><span class="p">(</span><span class="n">reductions</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">nan_mask</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="n">keepdims</span><span class="p">),</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">res</span><span class="p">)</span>


<span class="nd">@util</span><span class="o">.</span><span class="n">_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">)</span>
<span class="nd">@partial</span><span class="p">(</span><span class="n">jit</span><span class="p">,</span> <span class="n">static_argnames</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;axis&#39;</span><span class="p">,</span> <span class="s1">&#39;kind&#39;</span><span class="p">,</span> <span class="s1">&#39;order&#39;</span><span class="p">))</span>
<span class="k">def</span> <span class="nf">sort</span><span class="p">(</span>
    <span class="n">a</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">,</span>
    <span class="n">axis</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>
    <span class="n">kind</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;quicksort&quot;</span><span class="p">,</span>
    <span class="n">order</span><span class="p">:</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Array</span><span class="p">:</span>
  <span class="n">util</span><span class="o">.</span><span class="n">check_arraylike</span><span class="p">(</span><span class="s2">&quot;sort&quot;</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">kind</span> <span class="o">!=</span> <span class="s1">&#39;quicksort&#39;</span><span class="p">:</span>
    <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;&#39;kind&#39; argument to sort is ignored.&quot;</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">order</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;&#39;order&#39; argument to sort is not supported.&quot;</span><span class="p">)</span>

  <span class="k">if</span> <span class="n">axis</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">lax</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">ravel</span><span class="p">(</span><span class="n">a</span><span class="p">),</span> <span class="n">dimension</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">lax</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">asarray</span><span class="p">(</span><span class="n">a</span><span class="p">),</span> <span class="n">dimension</span><span class="o">=</span><span class="n">_canonicalize_axis</span><span class="p">(</span><span class="n">axis</span><span class="p">,</span> <span class="n">ndim</span><span class="p">(</span><span class="n">a</span><span class="p">)))</span>


<span class="nd">@util</span><span class="o">.</span><span class="n">_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sort_complex</span><span class="p">)</span>
<span class="nd">@jit</span>
<span class="k">def</span> <span class="nf">sort_complex</span><span class="p">(</span><span class="n">a</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Array</span><span class="p">:</span>
  <span class="n">util</span><span class="o">.</span><span class="n">check_arraylike</span><span class="p">(</span><span class="s2">&quot;sort_complex&quot;</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
  <span class="n">a</span> <span class="o">=</span> <span class="n">lax</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">asarray</span><span class="p">(</span><span class="n">a</span><span class="p">),</span> <span class="n">dimension</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">lax</span><span class="o">.</span><span class="n">convert_element_type</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">dtypes</span><span class="o">.</span><span class="n">to_complex_dtype</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">dtype</span><span class="p">))</span>

<span class="nd">@util</span><span class="o">.</span><span class="n">_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">lexsort</span><span class="p">)</span>
<span class="nd">@partial</span><span class="p">(</span><span class="n">jit</span><span class="p">,</span> <span class="n">static_argnames</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;axis&#39;</span><span class="p">,))</span>
<span class="k">def</span> <span class="nf">lexsort</span><span class="p">(</span><span class="n">keys</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">ArrayLike</span><span class="p">],</span> <span class="n">axis</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Array</span><span class="p">:</span>
  <span class="n">keys_arrays</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">asarray</span><span class="p">(</span><span class="n">k</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">keys</span><span class="p">)</span>
  <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">keys_arrays</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;need sequence of keys with len &gt; 0 in lexsort&quot;</span><span class="p">)</span>
  <span class="k">if</span> <span class="nb">len</span><span class="p">({</span><span class="n">shape</span><span class="p">(</span><span class="n">key</span><span class="p">)</span> <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">keys_arrays</span><span class="p">})</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;all keys need to be the same shape&quot;</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">ndim</span><span class="p">(</span><span class="n">keys_arrays</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">array</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtypes</span><span class="o">.</span><span class="n">canonicalize_dtype</span><span class="p">(</span><span class="n">int_</span><span class="p">))</span>
  <span class="n">axis</span> <span class="o">=</span> <span class="n">_canonicalize_axis</span><span class="p">(</span><span class="n">axis</span><span class="p">,</span> <span class="n">ndim</span><span class="p">(</span><span class="n">keys_arrays</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
  <span class="n">use_64bit_index</span> <span class="o">=</span> <span class="n">keys_arrays</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">31</span><span class="p">)</span>
  <span class="n">iota</span> <span class="o">=</span> <span class="n">lax</span><span class="o">.</span><span class="n">broadcasted_iota</span><span class="p">(</span><span class="n">int64</span> <span class="k">if</span> <span class="n">use_64bit_index</span> <span class="k">else</span> <span class="n">int_</span><span class="p">,</span> <span class="n">shape</span><span class="p">(</span><span class="n">keys_arrays</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">axis</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">lax</span><span class="o">.</span><span class="n">sort</span><span class="p">((</span><span class="o">*</span><span class="n">keys_arrays</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">iota</span><span class="p">),</span> <span class="n">dimension</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">num_keys</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">keys</span><span class="p">))[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>


<span class="n">_ARGSORT_DOC</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span>
<span class="s2">Only :code:`kind=&#39;stable&#39;` is supported. Other :code:`kind` values will produce</span>
<span class="s2">a warning and be treated as if they were :code:`&#39;stable&#39;`.</span>
<span class="s2">&quot;&quot;&quot;</span>


<span class="nd">@util</span><span class="o">.</span><span class="n">_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">,</span> <span class="n">lax_description</span><span class="o">=</span><span class="n">_ARGSORT_DOC</span><span class="p">)</span>
<span class="nd">@partial</span><span class="p">(</span><span class="n">jit</span><span class="p">,</span> <span class="n">static_argnames</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;axis&#39;</span><span class="p">,</span> <span class="s1">&#39;kind&#39;</span><span class="p">,</span> <span class="s1">&#39;order&#39;</span><span class="p">))</span>
<span class="k">def</span> <span class="nf">argsort</span><span class="p">(</span>
    <span class="n">a</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">,</span>
    <span class="n">axis</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>
    <span class="n">kind</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;stable&quot;</span><span class="p">,</span>
    <span class="n">order</span><span class="p">:</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Array</span><span class="p">:</span>
  <span class="n">util</span><span class="o">.</span><span class="n">check_arraylike</span><span class="p">(</span><span class="s2">&quot;argsort&quot;</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
  <span class="n">arr</span> <span class="o">=</span> <span class="n">asarray</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">kind</span> <span class="o">!=</span> <span class="s1">&#39;stable&#39;</span><span class="p">:</span>
    <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;&#39;kind&#39; argument to argsort is ignored; only &#39;stable&#39; sorts &quot;</span>
                  <span class="s2">&quot;are supported.&quot;</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">order</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;&#39;order&#39; argument to argsort is not supported.&quot;</span><span class="p">)</span>

  <span class="k">if</span> <span class="n">axis</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">argsort</span><span class="p">(</span><span class="n">arr</span><span class="o">.</span><span class="n">ravel</span><span class="p">(),</span> <span class="mi">0</span><span class="p">)</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="n">axis_num</span> <span class="o">=</span> <span class="n">_canonicalize_axis</span><span class="p">(</span><span class="n">axis</span><span class="p">,</span> <span class="n">arr</span><span class="o">.</span><span class="n">ndim</span><span class="p">)</span>
    <span class="n">use_64bit_index</span> <span class="o">=</span> <span class="ow">not</span> <span class="n">core</span><span class="o">.</span><span class="n">is_constant_dim</span><span class="p">(</span><span class="n">arr</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis_num</span><span class="p">])</span> <span class="ow">or</span> <span class="n">arr</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis_num</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">31</span><span class="p">)</span>
    <span class="n">iota</span> <span class="o">=</span> <span class="n">lax</span><span class="o">.</span><span class="n">broadcasted_iota</span><span class="p">(</span><span class="n">int64</span> <span class="k">if</span> <span class="n">use_64bit_index</span> <span class="k">else</span> <span class="n">int_</span><span class="p">,</span> <span class="n">arr</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">axis_num</span><span class="p">)</span>
    <span class="n">_</span><span class="p">,</span> <span class="n">perm</span> <span class="o">=</span> <span class="n">lax</span><span class="o">.</span><span class="n">sort_key_val</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">iota</span><span class="p">,</span> <span class="n">dimension</span><span class="o">=</span><span class="n">axis_num</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">perm</span>


<span class="nd">@util</span><span class="o">.</span><span class="n">_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">partition</span><span class="p">,</span> <span class="n">lax_description</span><span class="o">=</span><span class="s2">&quot;&quot;&quot;</span>
<span class="s2">The JAX version requires the ``kth`` argument to be a static integer rather than</span>
<span class="s2">a general array. This is implemented via two calls to :func:`jax.lax.top_k`. If</span>
<span class="s2">you&#39;re only accessing the top or bottom k values of the output, it may be more</span>
<span class="s2">efficient to call :func:`jax.lax.top_k` directly.</span>

<span class="s2">The JAX version differs from the NumPy version in the treatment of NaN entries;</span>
<span class="s2">NaNs which have the negative bit set are sorted to the beginning of the array.</span>
<span class="s2">&quot;&quot;&quot;</span><span class="p">)</span>
<span class="nd">@partial</span><span class="p">(</span><span class="n">jit</span><span class="p">,</span> <span class="n">static_argnames</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;kth&#39;</span><span class="p">,</span> <span class="s1">&#39;axis&#39;</span><span class="p">])</span>
<span class="k">def</span> <span class="nf">partition</span><span class="p">(</span><span class="n">a</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">,</span> <span class="n">kth</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">axis</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Array</span><span class="p">:</span>
  <span class="c1"># TODO(jakevdp): handle NaN values like numpy.</span>
  <span class="n">util</span><span class="o">.</span><span class="n">check_arraylike</span><span class="p">(</span><span class="s2">&quot;partition&quot;</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
  <span class="n">arr</span> <span class="o">=</span> <span class="n">asarray</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">issubdtype</span><span class="p">(</span><span class="n">arr</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">complexfloating</span><span class="p">):</span>
    <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;jnp.partition for complex dtype is not implemented.&quot;</span><span class="p">)</span>
  <span class="n">axis</span> <span class="o">=</span> <span class="n">_canonicalize_axis</span><span class="p">(</span><span class="n">axis</span><span class="p">,</span> <span class="n">arr</span><span class="o">.</span><span class="n">ndim</span><span class="p">)</span>
  <span class="n">kth</span> <span class="o">=</span> <span class="n">_canonicalize_axis</span><span class="p">(</span><span class="n">kth</span><span class="p">,</span> <span class="n">arr</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="p">])</span>

  <span class="n">arr</span> <span class="o">=</span> <span class="n">swapaxes</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
  <span class="n">bottom</span> <span class="o">=</span> <span class="o">-</span><span class="n">lax</span><span class="o">.</span><span class="n">top_k</span><span class="p">(</span><span class="o">-</span><span class="n">arr</span><span class="p">,</span> <span class="n">kth</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
  <span class="n">top</span> <span class="o">=</span> <span class="n">lax</span><span class="o">.</span><span class="n">top_k</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">arr</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">kth</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
  <span class="n">out</span> <span class="o">=</span> <span class="n">lax</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">bottom</span><span class="p">,</span> <span class="n">top</span><span class="p">],</span> <span class="n">dimension</span><span class="o">=</span><span class="n">arr</span><span class="o">.</span><span class="n">ndim</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">swapaxes</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">axis</span><span class="p">)</span>


<span class="nd">@util</span><span class="o">.</span><span class="n">_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">argpartition</span><span class="p">,</span> <span class="n">lax_description</span><span class="o">=</span><span class="s2">&quot;&quot;&quot;</span>
<span class="s2">The JAX version requires the ``kth`` argument to be a static integer rather than</span>
<span class="s2">a general array. This is implemented via two calls to :func:`jax.lax.top_k`. If</span>
<span class="s2">you&#39;re only accessing the top or bottom k values of the output, it may be more</span>
<span class="s2">efficient to call :func:`jax.lax.top_k` directly.</span>

<span class="s2">The JAX version differs from the NumPy version in the treatment of NaN entries;</span>
<span class="s2">NaNs which have the negative bit set are sorted to the beginning of the array.</span>
<span class="s2">&quot;&quot;&quot;</span><span class="p">)</span>
<span class="nd">@partial</span><span class="p">(</span><span class="n">jit</span><span class="p">,</span> <span class="n">static_argnames</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;kth&#39;</span><span class="p">,</span> <span class="s1">&#39;axis&#39;</span><span class="p">])</span>
<span class="k">def</span> <span class="nf">argpartition</span><span class="p">(</span><span class="n">a</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">,</span> <span class="n">kth</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">axis</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Array</span><span class="p">:</span>
  <span class="c1"># TODO(jakevdp): handle NaN values like numpy.</span>
  <span class="n">util</span><span class="o">.</span><span class="n">check_arraylike</span><span class="p">(</span><span class="s2">&quot;partition&quot;</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
  <span class="n">arr</span> <span class="o">=</span> <span class="n">asarray</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">issubdtype</span><span class="p">(</span><span class="n">arr</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">complexfloating</span><span class="p">):</span>
    <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;jnp.argpartition for complex dtype is not implemented.&quot;</span><span class="p">)</span>
  <span class="n">axis</span> <span class="o">=</span> <span class="n">_canonicalize_axis</span><span class="p">(</span><span class="n">axis</span><span class="p">,</span> <span class="n">arr</span><span class="o">.</span><span class="n">ndim</span><span class="p">)</span>
  <span class="n">kth</span> <span class="o">=</span> <span class="n">_canonicalize_axis</span><span class="p">(</span><span class="n">kth</span><span class="p">,</span> <span class="n">arr</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="p">])</span>

  <span class="n">arr</span> <span class="o">=</span> <span class="n">swapaxes</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
  <span class="n">bottom_ind</span> <span class="o">=</span> <span class="n">lax</span><span class="o">.</span><span class="n">top_k</span><span class="p">(</span><span class="o">-</span><span class="n">arr</span><span class="p">,</span> <span class="n">kth</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>

  <span class="c1"># To avoid issues with duplicate values, we compute the top indices via a proxy</span>
  <span class="n">set_to_zero</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">a</span><span class="p">,</span> <span class="n">i</span><span class="p">:</span> <span class="n">a</span><span class="o">.</span><span class="n">at</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
  <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">arr</span><span class="o">.</span><span class="n">ndim</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
    <span class="n">set_to_zero</span> <span class="o">=</span> <span class="n">jax</span><span class="o">.</span><span class="n">vmap</span><span class="p">(</span><span class="n">set_to_zero</span><span class="p">)</span>
  <span class="n">proxy</span> <span class="o">=</span> <span class="n">set_to_zero</span><span class="p">(</span><span class="n">ones</span><span class="p">(</span><span class="n">arr</span><span class="o">.</span><span class="n">shape</span><span class="p">),</span> <span class="n">bottom_ind</span><span class="p">)</span>
  <span class="n">top_ind</span> <span class="o">=</span> <span class="n">lax</span><span class="o">.</span><span class="n">top_k</span><span class="p">(</span><span class="n">proxy</span><span class="p">,</span> <span class="n">arr</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">kth</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>
  <span class="n">out</span> <span class="o">=</span> <span class="n">lax</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">bottom_ind</span><span class="p">,</span> <span class="n">top_ind</span><span class="p">],</span> <span class="n">dimension</span><span class="o">=</span><span class="n">arr</span><span class="o">.</span><span class="n">ndim</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">swapaxes</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">axis</span><span class="p">)</span>


<span class="nd">@partial</span><span class="p">(</span><span class="n">jit</span><span class="p">,</span> <span class="n">static_argnums</span><span class="o">=</span><span class="p">(</span><span class="mi">2</span><span class="p">,))</span>
<span class="k">def</span> <span class="nf">_roll_dynamic</span><span class="p">(</span><span class="n">a</span><span class="p">:</span> <span class="n">Array</span><span class="p">,</span> <span class="n">shift</span><span class="p">:</span> <span class="n">Array</span><span class="p">,</span> <span class="n">axis</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Array</span><span class="p">:</span>
  <span class="n">b_shape</span> <span class="o">=</span> <span class="n">lax</span><span class="o">.</span><span class="n">broadcast_shapes</span><span class="p">(</span><span class="n">shift</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">axis</span><span class="p">))</span>
  <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">b_shape</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
    <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;&#39;shift&#39; and &#39;axis&#39; arguments to roll must be scalars or 1D arrays&quot;</span>
    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

  <span class="k">for</span> <span class="n">x</span><span class="p">,</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">broadcast_to</span><span class="p">(</span><span class="n">shift</span><span class="p">,</span> <span class="n">b_shape</span><span class="p">),</span>
                  <span class="n">np</span><span class="o">.</span><span class="n">broadcast_to</span><span class="p">(</span><span class="n">axis</span><span class="p">,</span> <span class="n">b_shape</span><span class="p">)):</span>
    <span class="n">a_shape_i</span> <span class="o">=</span> <span class="n">array</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">ufuncs</span><span class="o">.</span><span class="n">remainder</span><span class="p">(</span><span class="n">lax</span><span class="o">.</span><span class="n">convert_element_type</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">),</span>
                         <span class="n">lax</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">a_shape_i</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">(</span><span class="mi">1</span><span class="p">)))</span>
    <span class="n">a_concat</span> <span class="o">=</span> <span class="n">lax</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">a</span><span class="p">,</span> <span class="n">a</span><span class="p">),</span> <span class="n">i</span><span class="p">)</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">lax</span><span class="o">.</span><span class="n">dynamic_slice_in_dim</span><span class="p">(</span><span class="n">a_concat</span><span class="p">,</span> <span class="n">a_shape_i</span> <span class="o">-</span> <span class="n">x</span><span class="p">,</span> <span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="n">i</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">a</span>

<span class="nd">@partial</span><span class="p">(</span><span class="n">jit</span><span class="p">,</span> <span class="n">static_argnums</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
<span class="k">def</span> <span class="nf">_roll_static</span><span class="p">(</span><span class="n">a</span><span class="p">:</span> <span class="n">Array</span><span class="p">,</span> <span class="n">shift</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">axis</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Array</span><span class="p">:</span>
  <span class="k">for</span> <span class="n">ax</span><span class="p">,</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">broadcast_arrays</span><span class="p">(</span><span class="n">axis</span><span class="p">,</span> <span class="n">shift</span><span class="p">)):</span>
    <span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">ax</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
      <span class="k">continue</span>
    <span class="n">i</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="n">s</span><span class="p">)</span> <span class="o">%</span> <span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">ax</span><span class="p">]</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">lax</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">lax</span><span class="o">.</span><span class="n">slice_in_dim</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">ax</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="n">ax</span><span class="p">),</span>
                         <span class="n">lax</span><span class="o">.</span><span class="n">slice_in_dim</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">ax</span><span class="p">)],</span>
                        <span class="n">dimension</span><span class="o">=</span><span class="n">ax</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">a</span>

<span class="nd">@util</span><span class="o">.</span><span class="n">_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">roll</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">roll</span><span class="p">(</span><span class="n">a</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">,</span> <span class="n">shift</span><span class="p">:</span> <span class="n">ArrayLike</span> <span class="o">|</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span>
         <span class="n">axis</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Array</span><span class="p">:</span>
  <span class="n">util</span><span class="o">.</span><span class="n">check_arraylike</span><span class="p">(</span><span class="s2">&quot;roll&quot;</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
  <span class="n">arr</span> <span class="o">=</span> <span class="n">asarray</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">axis</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">roll</span><span class="p">(</span><span class="n">arr</span><span class="o">.</span><span class="n">ravel</span><span class="p">(),</span> <span class="n">shift</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">arr</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
  <span class="n">axis</span> <span class="o">=</span> <span class="n">_ensure_index_tuple</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>
  <span class="n">axis</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">_canonicalize_axis</span><span class="p">(</span><span class="n">ax</span><span class="p">,</span> <span class="n">arr</span><span class="o">.</span><span class="n">ndim</span><span class="p">)</span> <span class="k">for</span> <span class="n">ax</span> <span class="ow">in</span> <span class="n">axis</span><span class="p">)</span>
  <span class="k">try</span><span class="p">:</span>
    <span class="n">shift</span> <span class="o">=</span> <span class="n">_ensure_index_tuple</span><span class="p">(</span><span class="n">shift</span><span class="p">)</span>
  <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">_roll_dynamic</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">asarray</span><span class="p">(</span><span class="n">shift</span><span class="p">),</span> <span class="n">axis</span><span class="p">)</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">_roll_static</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">shift</span><span class="p">,</span> <span class="n">axis</span><span class="p">)</span>


<span class="nd">@util</span><span class="o">.</span><span class="n">_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">rollaxis</span><span class="p">,</span> <span class="n">lax_description</span><span class="o">=</span><span class="n">_ARRAY_VIEW_DOC</span><span class="p">)</span>
<span class="nd">@partial</span><span class="p">(</span><span class="n">jit</span><span class="p">,</span> <span class="n">static_argnames</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;axis&#39;</span><span class="p">,</span> <span class="s1">&#39;start&#39;</span><span class="p">))</span>
<span class="k">def</span> <span class="nf">rollaxis</span><span class="p">(</span><span class="n">a</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">,</span> <span class="n">axis</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">start</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Array</span><span class="p">:</span>
  <span class="n">util</span><span class="o">.</span><span class="n">check_arraylike</span><span class="p">(</span><span class="s2">&quot;rollaxis&quot;</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
  <span class="n">start</span> <span class="o">=</span> <span class="n">core</span><span class="o">.</span><span class="n">concrete_or_error</span><span class="p">(</span><span class="n">operator</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="s2">&quot;&#39;start&#39; argument of jnp.rollaxis()&quot;</span><span class="p">)</span>
  <span class="n">a_ndim</span> <span class="o">=</span> <span class="n">ndim</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
  <span class="n">axis</span> <span class="o">=</span> <span class="n">_canonicalize_axis</span><span class="p">(</span><span class="n">axis</span><span class="p">,</span> <span class="n">a_ndim</span><span class="p">)</span>
  <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="o">-</span><span class="n">a_ndim</span> <span class="o">&lt;=</span> <span class="n">start</span> <span class="o">&lt;=</span> <span class="n">a_ndim</span><span class="p">):</span>
    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">start</span><span class="si">=}</span><span class="s2"> must satisfy </span><span class="si">{</span><span class="o">-</span><span class="n">a_ndim</span><span class="si">}</span><span class="s2">&lt;=start&lt;=</span><span class="si">{</span><span class="n">a_ndim</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">start</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
    <span class="n">start</span> <span class="o">+=</span> <span class="n">a_ndim</span>
  <span class="k">if</span> <span class="n">start</span> <span class="o">&gt;</span> <span class="n">axis</span><span class="p">:</span>
    <span class="n">start</span> <span class="o">-=</span> <span class="mi">1</span>
  <span class="k">return</span> <span class="n">moveaxis</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="n">start</span><span class="p">)</span>


<span class="nd">@util</span><span class="o">.</span><span class="n">_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">packbits</span><span class="p">)</span>
<span class="nd">@partial</span><span class="p">(</span><span class="n">jit</span><span class="p">,</span> <span class="n">static_argnames</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;axis&#39;</span><span class="p">,</span> <span class="s1">&#39;bitorder&#39;</span><span class="p">))</span>
<span class="k">def</span> <span class="nf">packbits</span><span class="p">(</span>
    <span class="n">a</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">,</span> <span class="n">axis</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">bitorder</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;big&quot;</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Array</span><span class="p">:</span>
  <span class="n">util</span><span class="o">.</span><span class="n">check_arraylike</span><span class="p">(</span><span class="s2">&quot;packbits&quot;</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
  <span class="n">arr</span> <span class="o">=</span> <span class="n">asarray</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
  <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">issubdtype</span><span class="p">(</span><span class="n">arr</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">integer</span><span class="p">)</span> <span class="ow">or</span> <span class="n">issubdtype</span><span class="p">(</span><span class="n">arr</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">bool_</span><span class="p">)):</span>
    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;Expected an input array of integer or boolean data type&#39;</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">bitorder</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;little&#39;</span><span class="p">,</span> <span class="s1">&#39;big&#39;</span><span class="p">]:</span>
    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;&#39;order&#39; must be either &#39;little&#39; or &#39;big&#39;&quot;</span><span class="p">)</span>
  <span class="n">arr</span> <span class="o">=</span> <span class="n">lax</span><span class="o">.</span><span class="n">gt</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">_lax_const</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;uint8&#39;</span><span class="p">)</span>
  <span class="n">bits</span> <span class="o">=</span> <span class="n">arange</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;uint8&#39;</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">bitorder</span> <span class="o">==</span> <span class="s1">&#39;big&#39;</span><span class="p">:</span>
    <span class="n">bits</span> <span class="o">=</span> <span class="n">bits</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
  <span class="k">if</span> <span class="n">axis</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
    <span class="n">arr</span> <span class="o">=</span> <span class="n">ravel</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span>
    <span class="n">axis</span> <span class="o">=</span> <span class="mi">0</span>
  <span class="n">arr</span> <span class="o">=</span> <span class="n">swapaxes</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>

  <span class="n">remainder</span> <span class="o">=</span> <span class="n">arr</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">%</span> <span class="mi">8</span>
  <span class="k">if</span> <span class="n">remainder</span><span class="p">:</span>
    <span class="n">arr</span> <span class="o">=</span> <span class="n">lax</span><span class="o">.</span><span class="n">pad</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span>
                  <span class="p">(</span><span class="n">arr</span><span class="o">.</span><span class="n">ndim</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="p">[(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)]</span> <span class="o">+</span> <span class="p">[(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">8</span> <span class="o">-</span> <span class="n">remainder</span><span class="p">,</span> <span class="mi">0</span><span class="p">)])</span>

  <span class="n">arr</span> <span class="o">=</span> <span class="n">arr</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">arr</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="n">arr</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">//</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">8</span><span class="p">))</span>
  <span class="n">bits</span> <span class="o">=</span> <span class="n">expand_dims</span><span class="p">(</span><span class="n">bits</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">arr</span><span class="o">.</span><span class="n">ndim</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)))</span>
  <span class="n">packed</span> <span class="o">=</span> <span class="p">(</span><span class="n">arr</span> <span class="o">&lt;&lt;</span> <span class="n">bits</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;uint8&#39;</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">swapaxes</span><span class="p">(</span><span class="n">packed</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>


<span class="nd">@util</span><span class="o">.</span><span class="n">_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">unpackbits</span><span class="p">)</span>
<span class="nd">@partial</span><span class="p">(</span><span class="n">jit</span><span class="p">,</span> <span class="n">static_argnames</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;axis&#39;</span><span class="p">,</span> <span class="s1">&#39;count&#39;</span><span class="p">,</span> <span class="s1">&#39;bitorder&#39;</span><span class="p">))</span>
<span class="k">def</span> <span class="nf">unpackbits</span><span class="p">(</span>
    <span class="n">a</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">,</span>
    <span class="n">axis</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">count</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">bitorder</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;big&quot;</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Array</span><span class="p">:</span>
  <span class="n">util</span><span class="o">.</span><span class="n">check_arraylike</span><span class="p">(</span><span class="s2">&quot;unpackbits&quot;</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
  <span class="n">arr</span> <span class="o">=</span> <span class="n">asarray</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">_dtype</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">!=</span> <span class="n">uint8</span><span class="p">:</span>
    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Expected an input array of unsigned byte data type&quot;</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">bitorder</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;little&#39;</span><span class="p">,</span> <span class="s1">&#39;big&#39;</span><span class="p">]:</span>
    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;&#39;order&#39; must be either &#39;little&#39; or &#39;big&#39;&quot;</span><span class="p">)</span>
  <span class="n">bits</span> <span class="o">=</span> <span class="n">asarray</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">arange</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;uint8&#39;</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">bitorder</span> <span class="o">==</span> <span class="s1">&#39;big&#39;</span><span class="p">:</span>
    <span class="n">bits</span> <span class="o">=</span> <span class="n">bits</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
  <span class="k">if</span> <span class="n">axis</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
    <span class="n">arr</span> <span class="o">=</span> <span class="n">ravel</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span>
    <span class="n">axis</span> <span class="o">=</span> <span class="mi">0</span>
  <span class="n">arr</span> <span class="o">=</span> <span class="n">swapaxes</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
  <span class="n">unpacked</span> <span class="o">=</span> <span class="p">((</span><span class="n">arr</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">&amp;</span> <span class="n">expand_dims</span><span class="p">(</span><span class="n">bits</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">arr</span><span class="o">.</span><span class="n">ndim</span><span class="p">))))</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;uint8&#39;</span><span class="p">)</span>
  <span class="n">unpacked</span> <span class="o">=</span> <span class="n">unpacked</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">unpacked</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,))</span>
  <span class="k">if</span> <span class="n">count</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
    <span class="k">if</span> <span class="n">count</span> <span class="o">&gt;</span> <span class="n">unpacked</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
      <span class="n">unpacked</span> <span class="o">=</span> <span class="n">pad</span><span class="p">(</span><span class="n">unpacked</span><span class="p">,</span> <span class="p">[(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)]</span> <span class="o">*</span> <span class="p">(</span><span class="n">unpacked</span><span class="o">.</span><span class="n">ndim</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="p">[(</span><span class="mi">0</span><span class="p">,</span> <span class="n">count</span> <span class="o">-</span> <span class="n">unpacked</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])])</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="n">unpacked</span> <span class="o">=</span> <span class="n">unpacked</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="p">:</span><span class="n">count</span><span class="p">]</span>
  <span class="k">return</span> <span class="n">swapaxes</span><span class="p">(</span><span class="n">unpacked</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>


<span class="nd">@util</span><span class="o">.</span><span class="n">_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">take</span><span class="p">,</span> <span class="n">skip_params</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;out&#39;</span><span class="p">],</span>
        <span class="n">lax_description</span><span class="o">=</span><span class="s2">&quot;&quot;&quot;</span>
<span class="s2">By default, JAX assumes that all indices are in-bounds. Alternative out-of-bound</span>
<span class="s2">index semantics can be specified via the ``mode`` parameter (see below).</span>
<span class="s2">&quot;&quot;&quot;</span><span class="p">,</span>
        <span class="n">extra_params</span><span class="o">=</span><span class="s2">&quot;&quot;&quot;</span>
<span class="s2">mode : string, default=&quot;fill&quot;</span>
<span class="s2">    Out-of-bounds indexing mode. The default mode=&quot;fill&quot; returns invalid values</span>
<span class="s2">    (e.g. NaN) for out-of bounds indices (see also ``fill_value`` below).</span>
<span class="s2">    For more discussion of mode options, see :attr:`jax.numpy.ndarray.at`.</span>
<span class="s2">fill_value : optional</span>
<span class="s2">    The fill value to return for out-of-bounds slices when mode is &#39;fill&#39;. Ignored</span>
<span class="s2">    otherwise. Defaults to NaN for inexact types, the largest negative value for</span>
<span class="s2">    signed types, the largest positive value for unsigned types, and True for booleans.</span>
<span class="s2">unique_indices : bool, default=False</span>
<span class="s2">    If True, the implementation will assume that the indices are unique,</span>
<span class="s2">    which can result in more efficient execution on some backends.</span>
<span class="s2">indices_are_sorted : bool, default=False</span>
<span class="s2">    If True, the implementation will assume that the indices are sorted in</span>
<span class="s2">    ascending order, which can lead to more efficient execution on some backends.</span>
<span class="s2">&quot;&quot;&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">take</span><span class="p">(</span>
    <span class="n">a</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">,</span>
    <span class="n">indices</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">,</span>
    <span class="n">axis</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">out</span><span class="p">:</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">mode</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">unique_indices</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">indices_are_sorted</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">fill_value</span><span class="p">:</span> <span class="n">ArrayLike</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Array</span><span class="p">:</span>
  <span class="k">return</span> <span class="n">_take</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">indices</span><span class="p">,</span> <span class="kc">None</span> <span class="k">if</span> <span class="n">axis</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">operator</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">axis</span><span class="p">),</span> <span class="n">out</span><span class="p">,</span>
               <span class="n">mode</span><span class="p">,</span> <span class="n">unique_indices</span><span class="o">=</span><span class="n">unique_indices</span><span class="p">,</span> <span class="n">indices_are_sorted</span><span class="o">=</span><span class="n">indices_are_sorted</span><span class="p">,</span>
               <span class="n">fill_value</span><span class="o">=</span><span class="n">fill_value</span><span class="p">)</span>


<span class="nd">@partial</span><span class="p">(</span><span class="n">jit</span><span class="p">,</span> <span class="n">static_argnames</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;axis&#39;</span><span class="p">,</span> <span class="s1">&#39;mode&#39;</span><span class="p">,</span> <span class="s1">&#39;unique_indices&#39;</span><span class="p">,</span> <span class="s1">&#39;indices_are_sorted&#39;</span><span class="p">,</span> <span class="s1">&#39;fill_value&#39;</span><span class="p">))</span>
<span class="k">def</span> <span class="nf">_take</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">indices</span><span class="p">,</span> <span class="n">axis</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
          <span class="n">unique_indices</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">indices_are_sorted</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
  <span class="k">if</span> <span class="n">out</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
    <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;The &#39;out&#39; argument to jnp.take is not supported.&quot;</span><span class="p">)</span>
  <span class="n">util</span><span class="o">.</span><span class="n">check_arraylike</span><span class="p">(</span><span class="s2">&quot;take&quot;</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">indices</span><span class="p">)</span>
  <span class="n">a</span> <span class="o">=</span> <span class="n">asarray</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
  <span class="n">indices</span> <span class="o">=</span> <span class="n">asarray</span><span class="p">(</span><span class="n">indices</span><span class="p">)</span>

  <span class="k">if</span> <span class="n">axis</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">ravel</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="n">axis_idx</span> <span class="o">=</span> <span class="mi">0</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="n">axis_idx</span> <span class="o">=</span> <span class="n">_canonicalize_axis</span><span class="p">(</span><span class="n">axis</span><span class="p">,</span> <span class="n">ndim</span><span class="p">(</span><span class="n">a</span><span class="p">))</span>

  <span class="k">if</span> <span class="n">mode</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">mode</span> <span class="o">==</span> <span class="s2">&quot;fill&quot;</span><span class="p">:</span>
    <span class="n">gather_mode</span> <span class="o">=</span> <span class="n">lax</span><span class="o">.</span><span class="n">GatherScatterMode</span><span class="o">.</span><span class="n">FILL_OR_DROP</span>
    <span class="c1"># lax.gather() does not support negative indices, so we wrap them here</span>
    <span class="n">indices</span> <span class="o">=</span> <span class="n">where</span><span class="p">(</span><span class="n">indices</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">,</span> <span class="n">indices</span> <span class="o">+</span> <span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis_idx</span><span class="p">],</span> <span class="n">indices</span><span class="p">)</span>
  <span class="k">elif</span> <span class="n">mode</span> <span class="o">==</span> <span class="s2">&quot;raise&quot;</span><span class="p">:</span>
    <span class="c1"># TODO(phawkins): we have no way to report out of bounds errors yet.</span>
    <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;The &#39;raise&#39; mode to jnp.take is not supported.&quot;</span><span class="p">)</span>
  <span class="k">elif</span> <span class="n">mode</span> <span class="o">==</span> <span class="s2">&quot;wrap&quot;</span><span class="p">:</span>
    <span class="n">indices</span> <span class="o">=</span> <span class="n">ufuncs</span><span class="o">.</span><span class="n">mod</span><span class="p">(</span><span class="n">indices</span><span class="p">,</span> <span class="n">_lax_const</span><span class="p">(</span><span class="n">indices</span><span class="p">,</span> <span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis_idx</span><span class="p">]))</span>
    <span class="n">gather_mode</span> <span class="o">=</span> <span class="n">lax</span><span class="o">.</span><span class="n">GatherScatterMode</span><span class="o">.</span><span class="n">PROMISE_IN_BOUNDS</span>
  <span class="k">elif</span> <span class="n">mode</span> <span class="o">==</span> <span class="s2">&quot;clip&quot;</span><span class="p">:</span>
    <span class="n">gather_mode</span> <span class="o">=</span> <span class="n">lax</span><span class="o">.</span><span class="n">GatherScatterMode</span><span class="o">.</span><span class="n">CLIP</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Invalid mode &#39;</span><span class="si">{</span><span class="n">mode</span><span class="si">}</span><span class="s2">&#39; for np.take&quot;</span><span class="p">)</span>

  <span class="n">index_dims</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">shape</span><span class="p">(</span><span class="n">indices</span><span class="p">))</span>
  <span class="n">slice_sizes</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">shape</span><span class="p">(</span><span class="n">a</span><span class="p">))</span>
  <span class="k">if</span> <span class="n">slice_sizes</span><span class="p">[</span><span class="n">axis_idx</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
    <span class="k">if</span> <span class="n">indices</span><span class="o">.</span><span class="n">size</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
      <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span><span class="s2">&quot;Cannot do a non-empty jnp.take() from an empty axis.&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">a</span>

  <span class="k">if</span> <span class="n">indices</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
    <span class="n">out_shape</span> <span class="o">=</span> <span class="p">(</span><span class="n">slice_sizes</span><span class="p">[:</span><span class="n">axis_idx</span><span class="p">]</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="n">indices</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">+</span>
                 <span class="n">slice_sizes</span><span class="p">[</span><span class="n">axis_idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:])</span>
    <span class="k">return</span> <span class="n">full_like</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="n">out_shape</span><span class="p">)</span>

  <span class="n">slice_sizes</span><span class="p">[</span><span class="n">axis_idx</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
  <span class="n">dnums</span> <span class="o">=</span> <span class="n">lax</span><span class="o">.</span><span class="n">GatherDimensionNumbers</span><span class="p">(</span>
    <span class="n">offset_dims</span><span class="o">=</span><span class="nb">tuple</span><span class="p">(</span>
      <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">axis_idx</span><span class="p">))</span> <span class="o">+</span>
      <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">axis_idx</span> <span class="o">+</span> <span class="n">index_dims</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">+</span> <span class="n">index_dims</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))),</span>
    <span class="n">collapsed_slice_dims</span><span class="o">=</span><span class="p">(</span><span class="n">axis_idx</span><span class="p">,),</span>
    <span class="n">start_index_map</span><span class="o">=</span><span class="p">(</span><span class="n">axis_idx</span><span class="p">,))</span>
  <span class="k">return</span> <span class="n">lax</span><span class="o">.</span><span class="n">gather</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">indices</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="kc">None</span><span class="p">],</span> <span class="n">dimension_numbers</span><span class="o">=</span><span class="n">dnums</span><span class="p">,</span>
                    <span class="n">slice_sizes</span><span class="o">=</span><span class="nb">tuple</span><span class="p">(</span><span class="n">slice_sizes</span><span class="p">),</span>
                    <span class="n">mode</span><span class="o">=</span><span class="n">gather_mode</span><span class="p">,</span> <span class="n">unique_indices</span><span class="o">=</span><span class="n">unique_indices</span><span class="p">,</span>
                    <span class="n">indices_are_sorted</span><span class="o">=</span><span class="n">indices_are_sorted</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="n">fill_value</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_normalize_index</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">axis_size</span><span class="p">):</span>
<span class="w">  </span><span class="sd">&quot;&quot;&quot;Normalizes an index value in the range [-N, N) to the range [0, N).&quot;&quot;&quot;</span>
  <span class="k">if</span> <span class="n">issubdtype</span><span class="p">(</span><span class="n">_dtype</span><span class="p">(</span><span class="n">index</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">unsignedinteger</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">index</span>
  <span class="k">if</span> <span class="n">core</span><span class="o">.</span><span class="n">is_constant_dim</span><span class="p">(</span><span class="n">axis_size</span><span class="p">):</span>
    <span class="n">axis_size_val</span> <span class="o">=</span> <span class="n">_lax_const</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">axis_size</span><span class="p">)</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="n">axis_size_val</span> <span class="o">=</span> <span class="n">lax</span><span class="o">.</span><span class="n">convert_element_type</span><span class="p">(</span><span class="n">core</span><span class="o">.</span><span class="n">dimension_as_value</span><span class="p">(</span><span class="n">axis_size</span><span class="p">),</span>
                                             <span class="n">_dtype</span><span class="p">(</span><span class="n">index</span><span class="p">))</span>
  <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">integer</span><span class="p">)):</span>
    <span class="k">return</span> <span class="n">lax</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">axis_size_val</span><span class="p">)</span> <span class="k">if</span> <span class="n">index</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="n">index</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">lax</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="n">index</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">,</span> <span class="n">lax</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">axis_size_val</span><span class="p">),</span> <span class="n">index</span><span class="p">)</span>


<span class="n">TAKE_ALONG_AXIS_DOC</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span>
<span class="s2">Unlike :func:`numpy.take_along_axis`, :func:`jax.numpy.take_along_axis` takes</span>
<span class="s2">an optional ``mode`` parameter controlling how out-of-bounds indices should be</span>
<span class="s2">handled. By default, out-of-bounds indices yield invalid values (e.g., ``NaN``).</span>
<span class="s2">See :attr:`jax.numpy.ndarray.at` for further discussion of out-of-bounds</span>
<span class="s2">indexing in JAX.</span>
<span class="s2">&quot;&quot;&quot;</span>


<span class="nd">@util</span><span class="o">.</span><span class="n">_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">take_along_axis</span><span class="p">,</span> <span class="n">update_doc</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">lax_description</span><span class="o">=</span><span class="n">TAKE_ALONG_AXIS_DOC</span><span class="p">)</span>
<span class="nd">@partial</span><span class="p">(</span><span class="n">jit</span><span class="p">,</span> <span class="n">static_argnames</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;axis&#39;</span><span class="p">,</span> <span class="s1">&#39;mode&#39;</span><span class="p">))</span>
<span class="k">def</span> <span class="nf">take_along_axis</span><span class="p">(</span>
    <span class="n">arr</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">,</span>
    <span class="n">indices</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">,</span>
    <span class="n">axis</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">mode</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="n">lax</span><span class="o">.</span><span class="n">GatherScatterMode</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Array</span><span class="p">:</span>
  <span class="n">util</span><span class="o">.</span><span class="n">check_arraylike</span><span class="p">(</span><span class="s2">&quot;take_along_axis&quot;</span><span class="p">,</span> <span class="n">arr</span><span class="p">,</span> <span class="n">indices</span><span class="p">)</span>
  <span class="n">a</span> <span class="o">=</span> <span class="n">asarray</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span>
  <span class="n">index_dtype</span> <span class="o">=</span> <span class="n">dtypes</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="n">indices</span><span class="p">)</span>
  <span class="n">idx_shape</span> <span class="o">=</span> <span class="n">shape</span><span class="p">(</span><span class="n">indices</span><span class="p">)</span>
  <span class="k">if</span> <span class="ow">not</span> <span class="n">dtypes</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="n">index_dtype</span><span class="p">,</span> <span class="n">integer</span><span class="p">):</span>
    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;take_along_axis indices must be of integer type, got &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="nb">str</span><span class="p">(</span><span class="n">index_dtype</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">axis</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
    <span class="k">if</span> <span class="n">ndim</span><span class="p">(</span><span class="n">indices</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
      <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;take_along_axis indices must be 1D if axis=None, got shape </span><span class="si">{}</span><span class="s2">&quot;</span>
      <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">idx_shape</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">take_along_axis</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">ravel</span><span class="p">(),</span> <span class="n">indices</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
  <span class="n">rank</span> <span class="o">=</span> <span class="n">ndim</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">rank</span> <span class="o">!=</span> <span class="n">ndim</span><span class="p">(</span><span class="n">indices</span><span class="p">):</span>
    <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;indices and arr must have the same number of dimensions; </span><span class="si">{}</span><span class="s2"> vs. </span><span class="si">{}</span><span class="s2">&quot;</span>
    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">ndim</span><span class="p">(</span><span class="n">indices</span><span class="p">),</span> <span class="n">a</span><span class="o">.</span><span class="n">ndim</span><span class="p">))</span>
  <span class="n">axis_int</span> <span class="o">=</span> <span class="n">_canonicalize_axis</span><span class="p">(</span><span class="n">axis</span><span class="p">,</span> <span class="n">rank</span><span class="p">)</span>

  <span class="k">def</span> <span class="nf">replace</span><span class="p">(</span><span class="n">tup</span><span class="p">,</span> <span class="n">val</span><span class="p">):</span>
    <span class="n">lst</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">tup</span><span class="p">)</span>
    <span class="n">lst</span><span class="p">[</span><span class="n">axis_int</span><span class="p">]</span> <span class="o">=</span> <span class="n">val</span>
    <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">lst</span><span class="p">)</span>

  <span class="n">use_64bit_index</span> <span class="o">=</span> <span class="nb">any</span><span class="p">([</span><span class="ow">not</span> <span class="n">core</span><span class="o">.</span><span class="n">is_constant_dim</span><span class="p">(</span><span class="n">d</span><span class="p">)</span> <span class="ow">or</span> <span class="n">d</span> <span class="o">&gt;=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">31</span><span class="p">)</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">])</span>
  <span class="n">index_dtype</span> <span class="o">=</span> <span class="n">dtype</span><span class="p">(</span><span class="n">int64</span> <span class="k">if</span> <span class="n">use_64bit_index</span> <span class="k">else</span> <span class="n">int32</span><span class="p">)</span>
  <span class="n">indices</span> <span class="o">=</span> <span class="n">lax</span><span class="o">.</span><span class="n">convert_element_type</span><span class="p">(</span><span class="n">indices</span><span class="p">,</span> <span class="n">index_dtype</span><span class="p">)</span>

  <span class="n">axis_size</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis_int</span><span class="p">]</span>
  <span class="n">arr_shape</span> <span class="o">=</span> <span class="n">replace</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
  <span class="n">out_shape</span> <span class="o">=</span> <span class="n">lax</span><span class="o">.</span><span class="n">broadcast_shapes</span><span class="p">(</span><span class="n">idx_shape</span><span class="p">,</span> <span class="n">arr_shape</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">axis_size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">zeros</span><span class="p">(</span><span class="n">out_shape</span><span class="p">,</span> <span class="n">a</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
  <span class="n">index_dims</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">idx</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">idx_shape</span><span class="p">)</span> <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="n">axis_int</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">core</span><span class="o">.</span><span class="n">definitely_equal</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="mi">1</span><span class="p">)]</span>

  <span class="n">gather_index_shape</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">out_shape</span><span class="p">)[</span><span class="n">index_dims</span><span class="p">])</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span><span class="p">,)</span>
  <span class="n">gather_indices</span> <span class="o">=</span> <span class="p">[]</span>
  <span class="n">slice_sizes</span> <span class="o">=</span> <span class="p">[]</span>
  <span class="n">offset_dims</span> <span class="o">=</span> <span class="p">[]</span>
  <span class="n">start_index_map</span> <span class="o">=</span> <span class="p">[]</span>
  <span class="n">collapsed_slice_dims</span> <span class="o">=</span> <span class="p">[]</span>
  <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span>
  <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">rank</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="n">axis_int</span><span class="p">:</span>
      <span class="n">indices</span> <span class="o">=</span> <span class="n">_normalize_index</span><span class="p">(</span><span class="n">indices</span><span class="p">,</span> <span class="n">axis_size</span><span class="p">)</span>
      <span class="n">gather_indices</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">lax</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">indices</span><span class="p">,</span> <span class="n">gather_index_shape</span><span class="p">))</span>
      <span class="n">slice_sizes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
      <span class="n">start_index_map</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
      <span class="n">collapsed_slice_dims</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
      <span class="n">j</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="k">elif</span> <span class="n">core</span><span class="o">.</span><span class="n">definitely_equal</span><span class="p">(</span><span class="n">idx_shape</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="mi">1</span><span class="p">):</span>
      <span class="c1"># If idx_shape[i] == 1, we can just take the entirety of the arr&#39;s axis</span>
      <span class="c1"># and avoid forming an iota index.</span>
      <span class="n">offset_dims</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
      <span class="n">slice_sizes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">arr_shape</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
    <span class="k">elif</span> <span class="n">core</span><span class="o">.</span><span class="n">definitely_equal</span><span class="p">(</span><span class="n">arr_shape</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="mi">1</span><span class="p">):</span>
      <span class="c1"># If the array dimension is 1 but the index dimension is not, we</span>
      <span class="c1"># broadcast the array dimension to the index dimension by repeatedly</span>
      <span class="c1"># gathering the first element.</span>
      <span class="n">gather_indices</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">zeros</span><span class="p">(</span><span class="n">gather_index_shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">index_dtype</span><span class="p">))</span>
      <span class="n">slice_sizes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
      <span class="n">start_index_map</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
      <span class="n">collapsed_slice_dims</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
      <span class="n">j</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="c1"># Otherwise, idx_shape[i] == arr_shape[i]. Use an iota index so</span>
      <span class="c1"># corresponding elements of array and index are gathered.</span>
      <span class="c1"># TODO(mattjj): next line needs updating for dynamic shapes</span>
      <span class="n">iota</span> <span class="o">=</span> <span class="n">lax</span><span class="o">.</span><span class="n">broadcasted_iota</span><span class="p">(</span><span class="n">index_dtype</span><span class="p">,</span> <span class="n">gather_index_shape</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span>
      <span class="n">gather_indices</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">iota</span><span class="p">)</span>
      <span class="n">slice_sizes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
      <span class="n">start_index_map</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
      <span class="n">collapsed_slice_dims</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
      <span class="n">j</span> <span class="o">+=</span> <span class="mi">1</span>

  <span class="n">gather_indices_arr</span> <span class="o">=</span> <span class="n">lax</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">gather_indices</span><span class="p">,</span> <span class="n">dimension</span><span class="o">=</span><span class="n">j</span><span class="p">)</span>
  <span class="n">dnums</span> <span class="o">=</span> <span class="n">lax</span><span class="o">.</span><span class="n">GatherDimensionNumbers</span><span class="p">(</span>
    <span class="n">offset_dims</span><span class="o">=</span><span class="nb">tuple</span><span class="p">(</span><span class="n">offset_dims</span><span class="p">),</span>
    <span class="n">collapsed_slice_dims</span><span class="o">=</span><span class="nb">tuple</span><span class="p">(</span><span class="n">collapsed_slice_dims</span><span class="p">),</span>
    <span class="n">start_index_map</span><span class="o">=</span><span class="nb">tuple</span><span class="p">(</span><span class="n">start_index_map</span><span class="p">))</span>
  <span class="k">return</span> <span class="n">lax</span><span class="o">.</span><span class="n">gather</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">gather_indices_arr</span><span class="p">,</span> <span class="n">dnums</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">slice_sizes</span><span class="p">),</span>
                    <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;fill&quot;</span> <span class="k">if</span> <span class="n">mode</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">mode</span><span class="p">)</span>


<span class="c1">### Indexing</span>

<span class="k">def</span> <span class="nf">_is_integer_index</span><span class="p">(</span><span class="n">idx</span><span class="p">:</span> <span class="n">Any</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
  <span class="k">return</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">integer</span><span class="p">))</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="p">(</span><span class="nb">bool</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">bool_</span><span class="p">))</span>

<span class="k">def</span> <span class="nf">_is_simple_reverse_slice</span><span class="p">(</span><span class="n">idx</span><span class="p">:</span> <span class="n">Any</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
  <span class="k">return</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="nb">slice</span><span class="p">)</span> <span class="ow">and</span>
          <span class="n">idx</span><span class="o">.</span><span class="n">start</span> <span class="ow">is</span> <span class="n">idx</span><span class="o">.</span><span class="n">stop</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span>
          <span class="nb">isinstance</span><span class="p">(</span><span class="n">idx</span><span class="o">.</span><span class="n">step</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span> <span class="ow">and</span> <span class="n">idx</span><span class="o">.</span><span class="n">step</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">_is_valid_integer_index_for_slice</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">mode</span><span class="p">):</span>
  <span class="k">if</span> <span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
    <span class="k">return</span> <span class="kc">False</span>
  <span class="k">if</span> <span class="n">_is_integer_index</span><span class="p">(</span><span class="n">idx</span><span class="p">):</span>
    <span class="k">return</span> <span class="o">-</span><span class="n">size</span> <span class="o">&lt;=</span> <span class="n">idx</span> <span class="o">&lt;</span> <span class="n">size</span>
  <span class="k">try</span><span class="p">:</span>
    <span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">idx</span><span class="p">),</span> <span class="n">_dtype</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span>
  <span class="k">except</span><span class="p">:</span>
    <span class="k">return</span> <span class="kc">False</span>
  <span class="k">if</span> <span class="n">shape</span> <span class="o">==</span> <span class="p">()</span> <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="n">dtype</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">integer</span><span class="p">):</span>
    <span class="c1"># For dynamic integer indices, dynamic_slice semantics require index clipping:</span>
    <span class="k">return</span> <span class="n">mode</span> <span class="ow">in</span> <span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="s1">&#39;promise_inbounds&#39;</span><span class="p">,</span> <span class="s1">&#39;clip&#39;</span><span class="p">]</span>
  <span class="k">return</span> <span class="kc">False</span>

<span class="k">def</span> <span class="nf">_is_contiguous_slice</span><span class="p">(</span><span class="n">idx</span><span class="p">):</span>
  <span class="k">return</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="nb">slice</span><span class="p">)</span> <span class="ow">and</span>
          <span class="p">(</span><span class="n">idx</span><span class="o">.</span><span class="n">start</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">_is_integer_index</span><span class="p">(</span><span class="n">idx</span><span class="o">.</span><span class="n">start</span><span class="p">))</span> <span class="ow">and</span>
          <span class="p">(</span><span class="n">idx</span><span class="o">.</span><span class="n">stop</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">_is_integer_index</span><span class="p">(</span><span class="n">idx</span><span class="o">.</span><span class="n">stop</span><span class="p">))</span> <span class="ow">and</span>
          <span class="p">(</span><span class="n">idx</span><span class="o">.</span><span class="n">step</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="p">(</span><span class="n">_is_integer_index</span><span class="p">(</span><span class="n">idx</span><span class="o">.</span><span class="n">step</span><span class="p">)</span> <span class="ow">and</span> <span class="n">idx</span><span class="o">.</span><span class="n">step</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)))</span>

<span class="k">def</span> <span class="nf">_attempt_rewriting_take_via_slice</span><span class="p">(</span><span class="n">arr</span><span class="p">:</span> <span class="n">Array</span><span class="p">,</span> <span class="n">idx</span><span class="p">:</span> <span class="n">Any</span><span class="p">,</span> <span class="n">mode</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Array</span> <span class="o">|</span> <span class="kc">None</span><span class="p">:</span>
  <span class="c1"># attempt to compute _rewriting_take via lax.slice(); return None if not possible.</span>
  <span class="n">idx</span> <span class="o">=</span> <span class="n">idx</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)</span> <span class="k">else</span> <span class="p">(</span><span class="n">idx</span><span class="p">,)</span>

  <span class="k">if</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">arr</span><span class="o">.</span><span class="n">shape</span><span class="p">):</span>
    <span class="k">return</span> <span class="kc">None</span>
  <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">arr</span><span class="o">.</span><span class="n">ndim</span><span class="p">:</span>
    <span class="k">return</span> <span class="kc">None</span>
  <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">i</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">idx</span><span class="p">):</span>
    <span class="k">return</span> <span class="kc">None</span>  <span class="c1"># TODO(jakevdp): handle newaxis case</span>

  <span class="n">simple_revs</span> <span class="o">=</span> <span class="p">{</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">ind</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span> <span class="k">if</span> <span class="n">_is_simple_reverse_slice</span><span class="p">(</span><span class="n">ind</span><span class="p">)}</span>
  <span class="n">int_indices</span> <span class="o">=</span> <span class="p">{</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">ind</span><span class="p">,</span> <span class="n">size</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="n">arr</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>
                 <span class="k">if</span> <span class="n">_is_valid_integer_index_for_slice</span><span class="p">(</span><span class="n">ind</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">mode</span><span class="p">)}</span>
  <span class="n">contiguous_slices</span> <span class="o">=</span> <span class="p">{</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">ind</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span> <span class="k">if</span> <span class="n">_is_contiguous_slice</span><span class="p">(</span><span class="n">ind</span><span class="p">)}</span>

  <span class="c1"># For sharded inputs, indexing (like x[0]) and partial slices (like x[:2]as</span>
  <span class="c1"># opposed to x[:]) lead to incorrect sharding semantics when computed via</span>
  <span class="c1"># dynamic_slice, so we fall back to gather.</span>
  <span class="c1"># TODO(yashkatariya): fix dynamic_slice with sharding</span>
  <span class="n">is_sharded</span> <span class="o">=</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">ArrayImpl</span><span class="p">)</span> <span class="ow">and</span>
                <span class="ow">not</span> <span class="n">dispatch</span><span class="o">.</span><span class="n">is_single_device_sharding</span><span class="p">(</span><span class="n">arr</span><span class="o">.</span><span class="n">sharding</span><span class="p">))</span>
  <span class="n">has_partial_slices</span> <span class="o">=</span> <span class="nb">any</span><span class="p">(</span><span class="n">idx</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">indices</span><span class="p">(</span><span class="n">arr</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">!=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">arr</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="mi">1</span><span class="p">)</span>
                           <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">contiguous_slices</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">is_sharded</span> <span class="ow">and</span> <span class="p">(</span><span class="n">int_indices</span> <span class="ow">or</span> <span class="n">has_partial_slices</span><span class="p">):</span>
    <span class="k">return</span> <span class="kc">None</span>

  <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">simple_revs</span><span class="p">)</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">int_indices</span><span class="p">)</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">contiguous_slices</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">idx</span><span class="p">):</span>
    <span class="k">return</span> <span class="kc">None</span>

  <span class="k">if</span> <span class="n">simple_revs</span><span class="p">:</span>
    <span class="n">arr</span> <span class="o">=</span> <span class="n">lax</span><span class="o">.</span><span class="n">rev</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">simple_revs</span><span class="p">))</span>
    <span class="n">idx</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span> <span class="k">if</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">simple_revs</span> <span class="k">else</span> <span class="n">ind</span>
                <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">ind</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">idx</span><span class="p">))</span>
    <span class="n">contiguous_slices</span> <span class="o">|=</span> <span class="n">simple_revs</span>

  <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">int_indices</span> <span class="ow">or</span> <span class="n">has_partial_slices</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">arr</span>

  <span class="n">idx</span> <span class="o">+=</span> <span class="p">(</span><span class="n">arr</span><span class="o">.</span><span class="n">ndim</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">idx</span><span class="p">))</span> <span class="o">*</span> <span class="p">(</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">),)</span>
  <span class="n">start_indices</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">ArrayLike</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
  <span class="n">slice_sizes</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>

  <span class="k">for</span> <span class="n">ind</span><span class="p">,</span> <span class="n">size</span> <span class="ow">in</span> <span class="n">safe_zip</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="n">arr</span><span class="o">.</span><span class="n">shape</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ind</span><span class="p">,</span> <span class="nb">slice</span><span class="p">):</span>
      <span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="n">step</span> <span class="o">=</span> <span class="n">ind</span><span class="o">.</span><span class="n">indices</span><span class="p">(</span><span class="n">size</span><span class="p">)</span>
      <span class="k">assert</span> <span class="n">step</span> <span class="o">==</span> <span class="mi">1</span>  <span class="c1"># checked above</span>
      <span class="n">start_indices</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">start</span><span class="p">)</span>
      <span class="n">slice_sizes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">stop</span> <span class="o">-</span> <span class="n">start</span><span class="p">))</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="n">_dtype</span><span class="p">(</span><span class="n">ind</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">integer</span><span class="p">)</span>  <span class="c1"># checked above</span>
      <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">ind</span><span class="p">)</span> <span class="o">==</span> <span class="p">()</span>  <span class="c1"># checked above</span>
      <span class="n">start_indices</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ind</span><span class="p">)</span>
      <span class="n">slice_sizes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
  <span class="c1"># Try to use static slicing when possible.</span>
  <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">integer</span><span class="p">))</span> <span class="ow">and</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">start_indices</span><span class="p">):</span>
    <span class="n">int_start_indices</span> <span class="o">=</span> <span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">start_indices</span><span class="p">]</span>  <span class="c1"># type: ignore</span>
    <span class="n">int_limit_indices</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="n">s</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">int_start_indices</span><span class="p">,</span> <span class="n">slice_sizes</span><span class="p">)]</span>
    <span class="n">arr</span> <span class="o">=</span> <span class="n">lax</span><span class="o">.</span><span class="n">slice</span><span class="p">(</span>
        <span class="n">arr</span><span class="p">,</span> <span class="n">start_indices</span><span class="o">=</span><span class="n">int_start_indices</span><span class="p">,</span> <span class="n">limit_indices</span><span class="o">=</span><span class="n">int_limit_indices</span><span class="p">)</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="c1"># We must be careful with dtypes because dynamic_slice requires all</span>
    <span class="c1"># start indices to have matching types.</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">start_indices</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
      <span class="n">start_indices</span> <span class="o">=</span> <span class="n">util</span><span class="o">.</span><span class="n">promote_dtypes</span><span class="p">(</span><span class="o">*</span><span class="n">start_indices</span><span class="p">)</span>
    <span class="n">arr</span> <span class="o">=</span> <span class="n">lax</span><span class="o">.</span><span class="n">dynamic_slice</span><span class="p">(</span>
        <span class="n">arr</span><span class="p">,</span> <span class="n">start_indices</span><span class="o">=</span><span class="n">start_indices</span><span class="p">,</span> <span class="n">slice_sizes</span><span class="o">=</span><span class="n">slice_sizes</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">int_indices</span><span class="p">:</span>
    <span class="n">arr</span> <span class="o">=</span> <span class="n">lax</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">int_indices</span><span class="p">))</span>
  <span class="k">return</span> <span class="n">arr</span>


<span class="k">def</span> <span class="nf">_rewriting_take</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">idx</span><span class="p">,</span> <span class="n">indices_are_sorted</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">unique_indices</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                    <span class="n">mode</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
  <span class="c1"># Computes arr[idx].</span>
  <span class="c1"># All supported cases of indexing can be implemented as an XLA gather,</span>
  <span class="c1"># followed by an optional reverse and broadcast_in_dim.</span>

  <span class="c1"># For simplicity of generated primitives, we call lax.dynamic_slice in the</span>
  <span class="c1"># simplest cases: i.e. non-dynamic arrays indexed with integers and slices.</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="o">:=</span> <span class="n">_attempt_rewriting_take_via_slice</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">idx</span><span class="p">,</span> <span class="n">mode</span><span class="p">))</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">result</span>

  <span class="c1"># TODO(mattjj,dougalm): expand dynamic shape indexing support</span>
  <span class="k">if</span> <span class="n">jax</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">jax_dynamic_shapes</span> <span class="ow">and</span> <span class="n">arr</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
    <span class="k">try</span><span class="p">:</span> <span class="n">aval</span> <span class="o">=</span> <span class="n">core</span><span class="o">.</span><span class="n">get_aval</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span>
    <span class="k">except</span><span class="p">:</span> <span class="k">pass</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="k">if</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">aval</span><span class="p">,</span> <span class="n">core</span><span class="o">.</span><span class="n">DShapedArray</span><span class="p">)</span> <span class="ow">and</span> <span class="n">aval</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">()</span> <span class="ow">and</span>
          <span class="n">dtypes</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="n">aval</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">integer</span><span class="p">)</span> <span class="ow">and</span>
          <span class="ow">not</span> <span class="n">dtypes</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="n">aval</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">dtypes</span><span class="o">.</span><span class="n">bool_</span><span class="p">)</span> <span class="ow">and</span>
          <span class="nb">isinstance</span><span class="p">(</span><span class="n">arr</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">int</span><span class="p">)):</span>
        <span class="k">return</span> <span class="n">lax</span><span class="o">.</span><span class="n">dynamic_index_in_dim</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">idx</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

  <span class="n">treedef</span><span class="p">,</span> <span class="n">static_idx</span><span class="p">,</span> <span class="n">dynamic_idx</span> <span class="o">=</span> <span class="n">_split_index_for_jit</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="n">arr</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">_gather</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">treedef</span><span class="p">,</span> <span class="n">static_idx</span><span class="p">,</span> <span class="n">dynamic_idx</span><span class="p">,</span> <span class="n">indices_are_sorted</span><span class="p">,</span>
                 <span class="n">unique_indices</span><span class="p">,</span> <span class="n">mode</span><span class="p">,</span> <span class="n">fill_value</span><span class="p">)</span>

<span class="c1"># TODO(phawkins): re-enable jit after fixing excessive recompilation for</span>
<span class="c1"># slice indexes (e.g., slice(0, 5, None), slice(10, 15, None), etc.).</span>
<span class="c1"># @partial(jit, static_argnums=(1, 2))</span>
<span class="k">def</span> <span class="nf">_gather</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">treedef</span><span class="p">,</span> <span class="n">static_idx</span><span class="p">,</span> <span class="n">dynamic_idx</span><span class="p">,</span> <span class="n">indices_are_sorted</span><span class="p">,</span>
            <span class="n">unique_indices</span><span class="p">,</span> <span class="n">mode</span><span class="p">,</span> <span class="n">fill_value</span><span class="p">):</span>
  <span class="n">idx</span> <span class="o">=</span> <span class="n">_merge_static_and_dynamic_indices</span><span class="p">(</span><span class="n">treedef</span><span class="p">,</span> <span class="n">static_idx</span><span class="p">,</span> <span class="n">dynamic_idx</span><span class="p">)</span>
  <span class="n">indexer</span> <span class="o">=</span> <span class="n">_index_to_gather</span><span class="p">(</span><span class="n">shape</span><span class="p">(</span><span class="n">arr</span><span class="p">),</span> <span class="n">idx</span><span class="p">)</span>  <span class="c1"># shared with _scatter_update</span>
  <span class="n">y</span> <span class="o">=</span> <span class="n">arr</span>

  <span class="k">if</span> <span class="n">fill_value</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
    <span class="n">core</span><span class="o">.</span><span class="n">concrete_or_error</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="n">fill_value</span><span class="p">,</span>
                           <span class="s2">&quot;fill_value argument to indexed get()&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">ndim</span><span class="p">(</span><span class="n">fill_value</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
      <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;fill_value argument to indexed get() must be a scalar&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">fill_value</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
      <span class="n">fill_value</span> <span class="o">=</span> <span class="n">fill_value</span><span class="o">.</span><span class="n">item</span><span class="p">()</span>

  <span class="c1"># Avoid calling gather if the slice shape is empty, both as a fast path and to</span>
  <span class="c1"># handle cases like zeros(0)[array([], int32)].</span>
  <span class="k">if</span> <span class="n">core</span><span class="o">.</span><span class="n">is_empty_shape</span><span class="p">(</span><span class="n">indexer</span><span class="o">.</span><span class="n">slice_shape</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">zeros_like</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="n">indexer</span><span class="o">.</span><span class="n">slice_shape</span><span class="p">)</span>

  <span class="c1"># We avoid generating a gather when indexer.gather_indices.size is empty.</span>
  <span class="k">if</span> <span class="ow">not</span> <span class="n">core</span><span class="o">.</span><span class="n">is_empty_shape</span><span class="p">(</span><span class="n">indexer</span><span class="o">.</span><span class="n">gather_indices</span><span class="o">.</span><span class="n">shape</span><span class="p">):</span>
    <span class="n">y</span> <span class="o">=</span> <span class="n">lax</span><span class="o">.</span><span class="n">gather</span><span class="p">(</span>
      <span class="n">y</span><span class="p">,</span> <span class="n">indexer</span><span class="o">.</span><span class="n">gather_indices</span><span class="p">,</span> <span class="n">indexer</span><span class="o">.</span><span class="n">dnums</span><span class="p">,</span> <span class="n">indexer</span><span class="o">.</span><span class="n">gather_slice_shape</span><span class="p">,</span>
      <span class="n">unique_indices</span><span class="o">=</span><span class="n">unique_indices</span> <span class="ow">or</span> <span class="n">indexer</span><span class="o">.</span><span class="n">unique_indices</span><span class="p">,</span>
      <span class="n">indices_are_sorted</span><span class="o">=</span><span class="n">indices_are_sorted</span> <span class="ow">or</span> <span class="n">indexer</span><span class="o">.</span><span class="n">indices_are_sorted</span><span class="p">,</span>
      <span class="n">mode</span><span class="o">=</span><span class="n">mode</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="n">fill_value</span><span class="p">)</span>

  <span class="c1"># Reverses axes with negative strides.</span>
  <span class="k">if</span> <span class="n">indexer</span><span class="o">.</span><span class="n">reversed_y_dims</span><span class="p">:</span>
    <span class="n">y</span> <span class="o">=</span> <span class="n">lax</span><span class="o">.</span><span class="n">rev</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">indexer</span><span class="o">.</span><span class="n">reversed_y_dims</span><span class="p">)</span>

  <span class="c1"># This adds np.newaxis/None dimensions.</span>
  <span class="k">return</span> <span class="n">expand_dims</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">indexer</span><span class="o">.</span><span class="n">newaxis_dims</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">_Indexer</span><span class="p">(</span><span class="n">NamedTuple</span><span class="p">):</span>
  <span class="c1"># The expected shape of the slice output.</span>
  <span class="n">slice_shape</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span>
  <span class="c1"># The slice shape to pass to lax.gather().</span>
  <span class="n">gather_slice_shape</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span>
  <span class="c1"># The gather indices to use.</span>
  <span class="n">gather_indices</span><span class="p">:</span> <span class="n">ArrayLike</span>
  <span class="c1"># A GatherDimensionNumbers object describing the gather to perform.</span>
  <span class="n">dnums</span><span class="p">:</span> <span class="n">lax</span><span class="o">.</span><span class="n">GatherDimensionNumbers</span>

  <span class="c1"># Are the gather_indices known to be non-overlapping and/or sorted?</span>
  <span class="c1"># (In practice, these translate to &quot;there no advanced indices&quot;, because</span>
  <span class="c1"># only advanced indices could lead to index repetition.)</span>
  <span class="n">unique_indices</span><span class="p">:</span> <span class="nb">bool</span>
  <span class="n">indices_are_sorted</span><span class="p">:</span> <span class="nb">bool</span>

  <span class="c1"># Slice dimensions that have negative strides, and so must be reversed after</span>
  <span class="c1"># the gather.</span>
  <span class="n">reversed_y_dims</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span>

  <span class="c1"># Keep track of any axes created by `newaxis`. These must be inserted for</span>
  <span class="c1"># gathers and eliminated for scatters.</span>
  <span class="n">newaxis_dims</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span>


<span class="k">def</span> <span class="nf">_split_index_for_jit</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="n">shape</span><span class="p">):</span>
<span class="w">  </span><span class="sd">&quot;&quot;&quot;Splits indices into necessarily-static and dynamic parts.</span>

<span class="sd">  Used to pass indices into `jit`-ted function.</span>
<span class="sd">  &quot;&quot;&quot;</span>
  <span class="c1"># Convert list indices to tuples in cases (deprecated by NumPy.)</span>
  <span class="n">idx</span> <span class="o">=</span> <span class="n">_eliminate_deprecated_list_indexing</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span>
  <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">idx</span><span class="p">):</span>
    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;JAX does not support string indexing; got </span><span class="si">{</span><span class="n">idx</span><span class="si">=}</span><span class="s2">&quot;</span><span class="p">)</span>

  <span class="c1"># Expand any (concrete) boolean indices. We can then use advanced integer</span>
  <span class="c1"># indexing logic to handle them.</span>
  <span class="n">idx</span> <span class="o">=</span> <span class="n">_expand_bool_indices</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="n">shape</span><span class="p">)</span>

  <span class="n">leaves</span><span class="p">,</span> <span class="n">treedef</span> <span class="o">=</span> <span class="n">tree_flatten</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span>
  <span class="n">dynamic</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">leaves</span><span class="p">)</span>
  <span class="n">static</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">leaves</span><span class="p">)</span>
  <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">leaves</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">x</span> <span class="ow">is</span> <span class="bp">Ellipsis</span><span class="p">:</span>
      <span class="n">static</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">x</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="nb">slice</span><span class="p">):</span>
      <span class="c1"># slice objects aren&#39;t hashable.</span>
      <span class="n">static</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">start</span><span class="p">,</span> <span class="n">x</span><span class="o">.</span><span class="n">stop</span><span class="p">,</span> <span class="n">x</span><span class="o">.</span><span class="n">step</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="n">dynamic</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">x</span>
  <span class="k">return</span> <span class="n">treedef</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">static</span><span class="p">),</span> <span class="n">dynamic</span>

<span class="k">def</span> <span class="nf">_merge_static_and_dynamic_indices</span><span class="p">(</span><span class="n">treedef</span><span class="p">,</span> <span class="n">static_idx</span><span class="p">,</span> <span class="n">dynamic_idx</span><span class="p">):</span>
<span class="w">  </span><span class="sd">&quot;&quot;&quot;Recombines indices that were split by _split_index_for_jit.&quot;&quot;&quot;</span>
  <span class="n">idx</span> <span class="o">=</span> <span class="p">[]</span>
  <span class="k">for</span> <span class="n">s</span><span class="p">,</span> <span class="n">d</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">static_idx</span><span class="p">,</span> <span class="n">dynamic_idx</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">d</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
      <span class="n">idx</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
      <span class="n">idx</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">slice</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">s</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">s</span><span class="p">[</span><span class="mi">2</span><span class="p">]))</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="n">idx</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">treedef</span><span class="o">.</span><span class="n">unflatten</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">_int</span><span class="p">(</span><span class="n">aval</span><span class="p">):</span>
  <span class="k">return</span> <span class="ow">not</span> <span class="n">aval</span><span class="o">.</span><span class="n">shape</span> <span class="ow">and</span> <span class="n">issubdtype</span><span class="p">(</span><span class="n">aval</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">integer</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">_index_to_gather</span><span class="p">(</span><span class="n">x_shape</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">idx</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">Any</span><span class="p">],</span>
                     <span class="n">normalize_indices</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">_Indexer</span><span class="p">:</span>
  <span class="c1"># Remove ellipses and add trailing slice(None)s.</span>
  <span class="n">idx</span> <span class="o">=</span> <span class="n">_canonicalize_tuple_index</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">x_shape</span><span class="p">),</span> <span class="n">idx</span><span class="p">)</span>

  <span class="c1"># Check for advanced indexing:</span>
  <span class="c1"># https://docs.scipy.org/doc/numpy/reference/arrays.indexing.html#advanced-indexing</span>

  <span class="c1"># Do the advanced indexing axes appear contiguously? If not, NumPy semantics</span>
  <span class="c1"># move the advanced axes to the front.</span>
  <span class="n">advanced_axes_are_contiguous</span> <span class="o">=</span> <span class="kc">False</span>

  <span class="n">advanced_indexes</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">Array</span> <span class="o">|</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span>

  <span class="c1"># The positions of the advanced indexing axes in `idx`.</span>
  <span class="n">idx_advanced_axes</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>

  <span class="c1"># The positions of the advanced indexes in x&#39;s shape.</span>
  <span class="c1"># collapsed, after None axes have been removed. See below.</span>
  <span class="n">x_advanced_axes</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span>

  <span class="k">if</span> <span class="n">_is_advanced_int_indexer</span><span class="p">(</span><span class="n">idx</span><span class="p">):</span>
    <span class="n">idx_no_nones</span> <span class="o">=</span> <span class="p">[(</span><span class="n">i</span><span class="p">,</span> <span class="n">d</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">d</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span> <span class="k">if</span> <span class="n">d</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">]</span>
    <span class="n">advanced_pairs</span> <span class="o">=</span> <span class="p">(</span>
      <span class="p">(</span><span class="n">asarray</span><span class="p">(</span><span class="n">e</span><span class="p">),</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span> <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">e</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">idx_no_nones</span><span class="p">)</span>
      <span class="k">if</span> <span class="n">isscalar</span><span class="p">(</span><span class="n">e</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="p">(</span><span class="n">Sequence</span><span class="p">,</span> <span class="n">Array</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)))</span>
    <span class="k">if</span> <span class="n">normalize_indices</span><span class="p">:</span>
      <span class="n">advanced_pairs</span> <span class="o">=</span> <span class="p">((</span><span class="n">_normalize_index</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">x_shape</span><span class="p">[</span><span class="n">j</span><span class="p">]),</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span>
                        <span class="k">for</span> <span class="n">e</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">advanced_pairs</span><span class="p">)</span>
    <span class="n">advanced_indexes</span><span class="p">,</span> <span class="n">idx_advanced_axes</span><span class="p">,</span> <span class="n">x_advanced_axes</span> <span class="o">=</span> <span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="n">advanced_pairs</span><span class="p">)</span>
    <span class="n">advanced_axes_are_contiguous</span> <span class="o">=</span> <span class="nb">bool</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">idx_advanced_axes</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">))</span>

  <span class="n">x_axis</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># Current axis in x.</span>
  <span class="n">y_axis</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># Current axis in y, before collapsing. See below.</span>
  <span class="n">collapsed_y_axis</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># Current axis in y, after collapsing.</span>

  <span class="c1"># Scatter dimension numbers.</span>
  <span class="n">offset_dims</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
  <span class="n">collapsed_slice_dims</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
  <span class="n">start_index_map</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>

  <span class="n">use_64bit_index</span> <span class="o">=</span> <span class="nb">any</span><span class="p">([</span><span class="ow">not</span> <span class="n">core</span><span class="o">.</span><span class="n">is_constant_dim</span><span class="p">(</span><span class="n">d</span><span class="p">)</span> <span class="ow">or</span> <span class="n">d</span> <span class="o">&gt;=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">31</span><span class="p">)</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">x_shape</span><span class="p">])</span>
  <span class="n">index_dtype</span> <span class="o">=</span> <span class="n">int64</span> <span class="k">if</span> <span class="n">use_64bit_index</span> <span class="k">else</span> <span class="n">int32</span>

  <span class="c1"># Gather indices.</span>
  <span class="c1"># Pairs of (array, start_dim) values. These will be broadcast into</span>
  <span class="c1"># gather_indices_shape, with the array dimensions aligned to start_dim, and</span>
  <span class="c1"># then concatenated.</span>
  <span class="n">gather_indices</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="n">Array</span><span class="p">,</span> <span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="p">[]</span>
  <span class="n">gather_indices_shape</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>

  <span class="c1"># We perform three transformations to y before the scatter op, in order:</span>
  <span class="c1"># First, y is broadcast to slice_shape. In general `y` only need broadcast to</span>
  <span class="c1"># the right shape.</span>
  <span class="n">slice_shape</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>

  <span class="c1"># Next, y is squeezed to remove newaxis_dims. This removes np.newaxis/`None`</span>
  <span class="c1"># indices, which the scatter cannot remove itself.</span>
  <span class="n">newaxis_dims</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>

  <span class="c1"># Finally, we reverse reversed_y_dims to handle slices with negative strides.</span>
  <span class="n">reversed_y_dims</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>

  <span class="n">gather_slice_shape</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>

  <span class="k">for</span> <span class="n">idx_pos</span><span class="p">,</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">idx</span><span class="p">):</span>
    <span class="c1"># Handle the advanced indices here if:</span>
    <span class="c1"># * the advanced indices were not contiguous and we are the start.</span>
    <span class="c1"># * we are at the position of the first advanced index.</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">advanced_indexes</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span>
        <span class="p">(</span><span class="n">advanced_axes_are_contiguous</span> <span class="ow">and</span> <span class="n">idx_pos</span> <span class="o">==</span> <span class="n">idx_advanced_axes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">or</span>
         <span class="ow">not</span> <span class="n">advanced_axes_are_contiguous</span> <span class="ow">and</span> <span class="n">idx_pos</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)):</span>
      <span class="n">advanced_indexes</span> <span class="o">=</span> <span class="n">broadcast_arrays</span><span class="p">(</span><span class="o">*</span><span class="n">advanced_indexes</span><span class="p">)</span>
      <span class="n">shape</span> <span class="o">=</span> <span class="n">advanced_indexes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span>
      <span class="n">ndim</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span>

      <span class="n">start_dim</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">gather_indices_shape</span><span class="p">)</span>
      <span class="n">gather_indices</span> <span class="o">+=</span> <span class="p">((</span><span class="n">lax</span><span class="o">.</span><span class="n">convert_element_type</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">index_dtype</span><span class="p">),</span> <span class="n">start_dim</span><span class="p">)</span>
                         <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">advanced_indexes</span><span class="p">)</span>
      <span class="n">gather_indices_shape</span> <span class="o">+=</span> <span class="n">shape</span>

      <span class="n">start_index_map</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">x_advanced_axes</span><span class="p">)</span>
      <span class="n">collapsed_slice_dims</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">x_advanced_axes</span><span class="p">)</span>
      <span class="n">slice_shape</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span>
      <span class="n">y_axis</span> <span class="o">+=</span> <span class="n">ndim</span>
      <span class="n">collapsed_y_axis</span> <span class="o">+=</span> <span class="n">ndim</span>

    <span class="c1"># Per-index bookkeeping for advanced indexes.</span>
    <span class="k">if</span> <span class="n">idx_pos</span> <span class="ow">in</span> <span class="n">idx_advanced_axes</span><span class="p">:</span>
      <span class="n">x_axis</span> <span class="o">+=</span> <span class="mi">1</span>
      <span class="n">gather_slice_shape</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
      <span class="k">continue</span>

    <span class="k">try</span><span class="p">:</span>
      <span class="n">abstract_i</span> <span class="o">=</span> <span class="n">core</span><span class="o">.</span><span class="n">get_aval</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
      <span class="n">abstract_i</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="c1"># Handle basic int indexes.</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">abstract_i</span><span class="p">,</span> <span class="p">(</span><span class="n">ConcreteArray</span><span class="p">,</span> <span class="n">ShapedArray</span><span class="p">))</span> <span class="ow">and</span> <span class="n">_int</span><span class="p">(</span><span class="n">abstract_i</span><span class="p">):</span>
      <span class="k">if</span> <span class="n">core</span><span class="o">.</span><span class="n">definitely_equal</span><span class="p">(</span><span class="n">x_shape</span><span class="p">[</span><span class="n">x_axis</span><span class="p">],</span> <span class="mi">0</span><span class="p">):</span>
        <span class="c1"># XLA gives error when indexing into an axis of size 0</span>
        <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;index is out of bounds for axis </span><span class="si">{</span><span class="n">x_axis</span><span class="si">}</span><span class="s2"> with size 0&quot;</span><span class="p">)</span>
      <span class="n">i</span> <span class="o">=</span> <span class="n">_normalize_index</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">x_shape</span><span class="p">[</span><span class="n">x_axis</span><span class="p">])</span> <span class="k">if</span> <span class="n">normalize_indices</span> <span class="k">else</span> <span class="n">i</span>
      <span class="n">i</span> <span class="o">=</span> <span class="n">lax</span><span class="o">.</span><span class="n">convert_element_type</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">index_dtype</span><span class="p">)</span>
      <span class="n">gather_indices</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">i</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">gather_indices_shape</span><span class="p">)))</span>
      <span class="n">collapsed_slice_dims</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">x_axis</span><span class="p">)</span>
      <span class="n">gather_slice_shape</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
      <span class="n">start_index_map</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">x_axis</span><span class="p">)</span>
      <span class="n">x_axis</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="c1"># Handle np.newaxis (None)</span>
    <span class="k">elif</span> <span class="n">i</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
      <span class="n">slice_shape</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
      <span class="n">newaxis_dims</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">y_axis</span><span class="p">)</span>
      <span class="n">y_axis</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="nb">slice</span><span class="p">):</span>
      <span class="c1"># Normalize the slice to use None when possible</span>
      <span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="n">step</span> <span class="o">=</span> <span class="n">i</span><span class="o">.</span><span class="n">start</span><span class="p">,</span> <span class="n">i</span><span class="o">.</span><span class="n">stop</span><span class="p">,</span> <span class="n">i</span><span class="o">.</span><span class="n">step</span>
      <span class="k">try</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">step</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">core</span><span class="o">.</span><span class="n">definitely_equal</span><span class="p">(</span><span class="n">step</span><span class="p">,</span> <span class="mi">1</span><span class="p">):</span>
          <span class="n">step</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">step</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
          <span class="k">if</span> <span class="n">start</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">core</span><span class="o">.</span><span class="n">definitely_equal</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="mi">0</span><span class="p">):</span>
            <span class="n">start</span> <span class="o">=</span> <span class="kc">None</span>
          <span class="k">if</span> <span class="n">stop</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="p">(</span><span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">stop</span><span class="p">,</span> <span class="n">core</span><span class="o">.</span><span class="n">Tracer</span><span class="p">)</span> <span class="ow">and</span>
              <span class="n">stop</span> <span class="o">&gt;=</span> <span class="n">x_shape</span><span class="p">[</span><span class="n">x_axis</span><span class="p">]):</span>
            <span class="n">stop</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">elif</span> <span class="n">core</span><span class="o">.</span><span class="n">definitely_equal</span><span class="p">(</span><span class="n">step</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
          <span class="n">step</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
      <span class="k">except</span> <span class="p">(</span><span class="ne">TypeError</span><span class="p">,</span> <span class="n">core</span><span class="o">.</span><span class="n">InconclusiveDimensionOperation</span><span class="p">):</span>
        <span class="k">pass</span>

      <span class="c1"># Handle slice(None) and slice(None, None, -1)</span>
      <span class="k">if</span> <span class="n">start</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">stop</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="p">(</span>
          <span class="n">step</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">step</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span> <span class="ow">and</span> <span class="n">step</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">step</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
          <span class="n">reversed_y_dims</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">collapsed_y_axis</span><span class="p">)</span>
        <span class="n">slice_shape</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">x_shape</span><span class="p">[</span><span class="n">x_axis</span><span class="p">])</span>
        <span class="n">gather_slice_shape</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">x_shape</span><span class="p">[</span><span class="n">x_axis</span><span class="p">])</span>
        <span class="n">offset_dims</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">collapsed_y_axis</span><span class="p">)</span>
        <span class="n">collapsed_y_axis</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">y_axis</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">x_axis</span> <span class="o">+=</span> <span class="mi">1</span>
      <span class="c1"># Handle slice index (only static, otherwise an error is raised)</span>
      <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">(</span><span class="n">_is_slice_element_none_or_constant</span><span class="p">(</span><span class="n">elt</span><span class="p">)</span>
                   <span class="k">for</span> <span class="n">elt</span> <span class="ow">in</span> <span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="n">step</span><span class="p">)):</span>
          <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;Array slice indices must have static start/stop/step to be used &quot;</span>
                 <span class="s2">&quot;with NumPy indexing syntax. &quot;</span>
                 <span class="sa">f</span><span class="s2">&quot;Found slice(</span><span class="si">{</span><span class="n">start</span><span class="si">}</span><span class="s2">, </span><span class="si">{</span><span class="n">stop</span><span class="si">}</span><span class="s2">, </span><span class="si">{</span><span class="n">step</span><span class="si">}</span><span class="s2">). &quot;</span>
                 <span class="s2">&quot;To index a statically sized &quot;</span>
                 <span class="s2">&quot;array at a dynamic position, try lax.dynamic_slice/&quot;</span>
                 <span class="s2">&quot;dynamic_update_slice (JAX does not support dynamically sized &quot;</span>
                 <span class="s2">&quot;arrays within JIT compiled functions).&quot;</span><span class="p">)</span>
          <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">core</span><span class="o">.</span><span class="n">is_constant_dim</span><span class="p">(</span><span class="n">x_shape</span><span class="p">[</span><span class="n">x_axis</span><span class="p">]):</span>
          <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;Cannot use NumPy slice indexing on an array dimension whose &quot;</span>
                 <span class="sa">f</span><span class="s2">&quot;size is not statically known (</span><span class="si">{</span><span class="n">x_shape</span><span class="p">[</span><span class="n">x_axis</span><span class="p">]</span><span class="si">}</span><span class="s2">). &quot;</span>
                 <span class="s2">&quot;Try using lax.dynamic_slice/dynamic_update_slice&quot;</span><span class="p">)</span>
          <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
        <span class="n">start</span><span class="p">,</span> <span class="n">limit</span><span class="p">,</span> <span class="n">stride</span><span class="p">,</span> <span class="n">needs_rev</span> <span class="o">=</span> <span class="n">_static_idx</span><span class="p">(</span><span class="nb">slice</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="n">step</span><span class="p">),</span>
                                                      <span class="n">x_shape</span><span class="p">[</span><span class="n">x_axis</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">needs_rev</span><span class="p">:</span>
          <span class="n">reversed_y_dims</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">collapsed_y_axis</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">stride</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
          <span class="n">i</span> <span class="o">=</span> <span class="n">lax</span><span class="o">.</span><span class="n">convert_element_type</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">index_dtype</span><span class="p">)</span>
          <span class="n">gather_indices</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">i</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">gather_indices_shape</span><span class="p">)))</span>
          <span class="n">slice_shape</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">limit</span> <span class="o">-</span> <span class="n">start</span><span class="p">)</span>
          <span class="n">gather_slice_shape</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">limit</span> <span class="o">-</span> <span class="n">start</span><span class="p">)</span>
          <span class="n">offset_dims</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">collapsed_y_axis</span><span class="p">)</span>
          <span class="n">start_index_map</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">x_axis</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
          <span class="n">i</span> <span class="o">=</span> <span class="n">arange</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">limit</span><span class="p">,</span> <span class="n">stride</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">index_dtype</span><span class="p">)</span>
          <span class="n">size</span> <span class="o">=</span> <span class="n">i</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
          <span class="n">slice_shape</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">size</span><span class="p">)</span>
          <span class="n">gather_slice_shape</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
          <span class="n">gather_indices</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">i</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">gather_indices_shape</span><span class="p">)))</span>
          <span class="n">gather_indices_shape</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">size</span><span class="p">)</span>

          <span class="n">start_index_map</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">x_axis</span><span class="p">)</span>
          <span class="n">collapsed_slice_dims</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">x_axis</span><span class="p">)</span>

        <span class="n">collapsed_y_axis</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">y_axis</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">x_axis</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">abstract_i</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span>
          <span class="ow">not</span> <span class="p">(</span><span class="n">issubdtype</span><span class="p">(</span><span class="n">abstract_i</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">integer</span><span class="p">)</span> <span class="ow">or</span> <span class="n">issubdtype</span><span class="p">(</span><span class="n">abstract_i</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">bool_</span><span class="p">))):</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;Indexer must have integer or boolean type, got indexer &quot;</span>
               <span class="s2">&quot;with type </span><span class="si">{}</span><span class="s2"> at position </span><span class="si">{}</span><span class="s2">, indexer value </span><span class="si">{}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="n">msg</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">abstract_i</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">idx_pos</span><span class="p">,</span> <span class="n">i</span><span class="p">))</span>

      <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;Indexing mode not yet supported. Open a feature request!</span><span class="se">\n</span><span class="si">{}</span><span class="s2">&quot;</span>
      <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span><span class="n">msg</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">idx</span><span class="p">))</span>

  <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">gather_indices</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
    <span class="n">gather_indices_array</span><span class="p">:</span> <span class="n">ArrayLike</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">0</span><span class="p">,),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">index_dtype</span><span class="p">)</span>
  <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">gather_indices</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
    <span class="n">g</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">gather_indices</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">gather_indices_array</span> <span class="o">=</span> <span class="n">lax</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">ndim</span><span class="p">,))</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="n">last_dim</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">gather_indices_shape</span><span class="p">)</span>
    <span class="n">gather_indices_shape</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">gather_indices_array</span> <span class="o">=</span> <span class="n">lax</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span>
      <span class="n">lax</span><span class="o">.</span><span class="n">broadcast_in_dim</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">gather_indices_shape</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">i</span> <span class="o">+</span> <span class="n">g</span><span class="o">.</span><span class="n">ndim</span><span class="p">)))</span>
      <span class="k">for</span> <span class="n">g</span><span class="p">,</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">gather_indices</span><span class="p">],</span>
      <span class="n">last_dim</span><span class="p">)</span>

  <span class="n">dnums</span> <span class="o">=</span> <span class="n">lax</span><span class="o">.</span><span class="n">GatherDimensionNumbers</span><span class="p">(</span>
    <span class="n">offset_dims</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">offset_dims</span><span class="p">),</span>
    <span class="n">collapsed_slice_dims</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="n">collapsed_slice_dims</span><span class="p">)),</span>
    <span class="n">start_index_map</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">start_index_map</span><span class="p">)</span>
  <span class="p">)</span>
  <span class="k">return</span> <span class="n">_Indexer</span><span class="p">(</span>
    <span class="n">slice_shape</span><span class="o">=</span><span class="n">slice_shape</span><span class="p">,</span>
    <span class="n">newaxis_dims</span><span class="o">=</span><span class="nb">tuple</span><span class="p">(</span><span class="n">newaxis_dims</span><span class="p">),</span>
    <span class="n">gather_slice_shape</span><span class="o">=</span><span class="n">gather_slice_shape</span><span class="p">,</span>
    <span class="n">reversed_y_dims</span><span class="o">=</span><span class="n">reversed_y_dims</span><span class="p">,</span>
    <span class="n">dnums</span><span class="o">=</span><span class="n">dnums</span><span class="p">,</span>
    <span class="n">gather_indices</span><span class="o">=</span><span class="n">gather_indices_array</span><span class="p">,</span>
    <span class="n">unique_indices</span><span class="o">=</span><span class="n">advanced_indexes</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">indices_are_sorted</span><span class="o">=</span><span class="n">advanced_indexes</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">_should_unpack_list_index</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
<span class="w">  </span><span class="sd">&quot;&quot;&quot;Helper for _eliminate_deprecated_list_indexing.&quot;&quot;&quot;</span>
  <span class="k">return</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">Array</span><span class="p">))</span> <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">ndim</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span>
          <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="p">(</span><span class="n">Sequence</span><span class="p">,</span> <span class="nb">slice</span><span class="p">))</span>
          <span class="ow">or</span> <span class="n">x</span> <span class="ow">is</span> <span class="bp">Ellipsis</span> <span class="ow">or</span> <span class="n">x</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">_eliminate_deprecated_list_indexing</span><span class="p">(</span><span class="n">idx</span><span class="p">):</span>
  <span class="c1"># &quot;Basic slicing is initiated if the selection object is a non-array,</span>
  <span class="c1"># non-tuple sequence containing slice objects, [Ellipses, or newaxis</span>
  <span class="c1"># objects]&quot;. Detects this and raises a TypeError.</span>
  <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="p">(</span><span class="n">Array</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="nb">str</span><span class="p">)):</span>
      <span class="c1"># As of numpy 1.16, some non-tuple sequences of indices result in a warning, while</span>
      <span class="c1"># others are converted to arrays, based on a set of somewhat convoluted heuristics</span>
      <span class="c1"># (See https://github.com/numpy/numpy/blob/v1.19.2/numpy/core/src/multiarray/mapping.c#L179-L343)</span>
      <span class="c1"># In JAX, we raise an informative TypeError for *all* non-tuple sequences.</span>
      <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">_should_unpack_list_index</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">idx</span><span class="p">):</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;Using a non-tuple sequence for multidimensional indexing is not allowed; &quot;</span>
               <span class="s2">&quot;use `arr[tuple(seq)]` instead of `arr[seq]`. &quot;</span>
               <span class="s2">&quot;See https://github.com/google/jax/issues/4564 for more information.&quot;</span><span class="p">)</span>
      <span class="k">else</span><span class="p">:</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;Using a non-tuple sequence for multidimensional indexing is not allowed; &quot;</span>
               <span class="s2">&quot;use `arr[array(seq)]` instead of `arr[seq]`. &quot;</span>
               <span class="s2">&quot;See https://github.com/google/jax/issues/4564 for more information.&quot;</span><span class="p">)</span>
      <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="n">idx</span> <span class="o">=</span> <span class="p">(</span><span class="n">idx</span><span class="p">,)</span>
  <span class="k">return</span> <span class="n">idx</span>

<span class="k">def</span> <span class="nf">_is_boolean_index</span><span class="p">(</span><span class="n">i</span><span class="p">):</span>
  <span class="k">try</span><span class="p">:</span>
    <span class="n">abstract_i</span> <span class="o">=</span> <span class="n">core</span><span class="o">.</span><span class="n">get_aval</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
  <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
    <span class="n">abstract_i</span> <span class="o">=</span> <span class="kc">None</span>
  <span class="k">return</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">abstract_i</span><span class="p">,</span> <span class="n">ShapedArray</span><span class="p">)</span> <span class="ow">and</span> <span class="n">issubdtype</span><span class="p">(</span><span class="n">abstract_i</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">bool_</span><span class="p">)</span>
          <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span> <span class="ow">and</span> <span class="n">i</span> <span class="ow">and</span> <span class="nb">all</span><span class="p">(</span><span class="n">_is_scalar</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>
          <span class="ow">and</span> <span class="n">issubdtype</span><span class="p">(</span><span class="n">_dtype</span><span class="p">(</span><span class="n">e</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">bool_</span><span class="p">)</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">i</span><span class="p">))</span>

<span class="k">def</span> <span class="nf">_expand_bool_indices</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="n">shape</span><span class="p">):</span>
<span class="w">  </span><span class="sd">&quot;&quot;&quot;Converts concrete bool indexes into advanced integer indexes.&quot;&quot;&quot;</span>
  <span class="n">out</span> <span class="o">=</span> <span class="p">[]</span>
  <span class="n">total_dims</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span>
  <span class="n">num_ellipsis</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">e</span> <span class="ow">is</span> <span class="bp">Ellipsis</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">idx</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">num_ellipsis</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
    <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span><span class="s2">&quot;an index can only have a single ellipsis (&#39;...&#39;)&quot;</span><span class="p">)</span>
  <span class="k">elif</span> <span class="n">num_ellipsis</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
    <span class="n">total_dims</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">_ndim</span><span class="p">(</span><span class="n">e</span><span class="p">)</span> <span class="k">if</span> <span class="n">_is_boolean_index</span><span class="p">(</span><span class="n">e</span><span class="p">)</span> <span class="k">else</span> <span class="mi">1</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">idx</span>
                     <span class="k">if</span> <span class="n">e</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">e</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">Ellipsis</span><span class="p">)</span>
  <span class="n">ellipsis_offset</span> <span class="o">=</span> <span class="mi">0</span>
  <span class="k">for</span> <span class="n">dim_number</span><span class="p">,</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">idx</span><span class="p">):</span>
    <span class="k">try</span><span class="p">:</span>
      <span class="n">abstract_i</span> <span class="o">=</span> <span class="n">core</span><span class="o">.</span><span class="n">get_aval</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
      <span class="n">abstract_i</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">if</span> <span class="n">_is_boolean_index</span><span class="p">(</span><span class="n">i</span><span class="p">):</span>
      <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
        <span class="n">i</span> <span class="o">=</span> <span class="n">array</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
        <span class="n">abstract_i</span> <span class="o">=</span> <span class="n">core</span><span class="o">.</span><span class="n">get_aval</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>

      <span class="k">if</span> <span class="ow">not</span> <span class="nb">type</span><span class="p">(</span><span class="n">abstract_i</span><span class="p">)</span> <span class="ow">is</span> <span class="n">ConcreteArray</span><span class="p">:</span>
        <span class="c1"># TODO(mattjj): improve this error by tracking _why_ the indices are not concrete</span>
        <span class="k">raise</span> <span class="n">errors</span><span class="o">.</span><span class="n">NonConcreteBooleanIndexError</span><span class="p">(</span><span class="n">abstract_i</span><span class="p">)</span>
      <span class="k">elif</span> <span class="n">_ndim</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;JAX arrays do not support boolean scalar indices&quot;</span><span class="p">)</span>
      <span class="k">else</span><span class="p">:</span>
        <span class="n">i_shape</span> <span class="o">=</span> <span class="n">_shape</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
        <span class="n">start</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">out</span><span class="p">)</span> <span class="o">+</span> <span class="n">ellipsis_offset</span>
        <span class="n">expected_shape</span> <span class="o">=</span> <span class="n">shape</span><span class="p">[</span><span class="n">start</span><span class="p">:</span> <span class="n">start</span> <span class="o">+</span> <span class="n">_ndim</span><span class="p">(</span><span class="n">i</span><span class="p">)]</span>
        <span class="k">if</span> <span class="n">i_shape</span> <span class="o">!=</span> <span class="n">expected_shape</span><span class="p">:</span>
          <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span><span class="s2">&quot;boolean index did not match shape of indexed array in index &quot;</span>
                           <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">dim_number</span><span class="si">}</span><span class="s2">: got </span><span class="si">{</span><span class="n">i_shape</span><span class="si">}</span><span class="s2">, expected </span><span class="si">{</span><span class="n">expected_shape</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">out</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">i</span><span class="p">))</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="n">out</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">i</span> <span class="ow">is</span> <span class="bp">Ellipsis</span><span class="p">:</span>
      <span class="n">ellipsis_offset</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span> <span class="o">-</span> <span class="n">total_dims</span> <span class="o">-</span> <span class="mi">1</span>
  <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">out</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_is_slice_element_none_or_constant</span><span class="p">(</span><span class="n">elt</span><span class="p">):</span>
<span class="w">  </span><span class="sd">&quot;&quot;&quot;Return True if elt is a constant or None.&quot;&quot;&quot;</span>
  <span class="k">if</span> <span class="n">elt</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span> <span class="k">return</span> <span class="kc">True</span>
  <span class="k">try</span><span class="p">:</span>
    <span class="k">return</span> <span class="nb">type</span><span class="p">(</span><span class="n">core</span><span class="o">.</span><span class="n">get_aval</span><span class="p">(</span><span class="n">elt</span><span class="p">))</span> <span class="ow">is</span> <span class="n">ConcreteArray</span>
  <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
    <span class="k">return</span> <span class="kc">False</span>

<span class="c1"># TODO(mattjj): clean up this logic</span>
<span class="k">def</span> <span class="nf">_is_advanced_int_indexer</span><span class="p">(</span><span class="n">idx</span><span class="p">):</span>
<span class="w">  </span><span class="sd">&quot;&quot;&quot;Returns True if idx should trigger int array indexing, False otherwise.&quot;&quot;&quot;</span>
  <span class="c1"># https://docs.scipy.org/doc/numpy/reference/arrays.indexing.html#advanced-indexing</span>
  <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)</span>
  <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="n">e</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">e</span> <span class="ow">is</span> <span class="bp">Ellipsis</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="nb">slice</span><span class="p">)</span>
         <span class="ow">or</span> <span class="n">_is_scalar</span><span class="p">(</span><span class="n">e</span><span class="p">)</span> <span class="ow">and</span> <span class="n">issubdtype</span><span class="p">(</span><span class="n">_dtype</span><span class="p">(</span><span class="n">e</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">integer</span><span class="p">)</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">idx</span><span class="p">):</span>
    <span class="k">return</span> <span class="kc">False</span>
  <span class="k">return</span> <span class="nb">all</span><span class="p">(</span><span class="n">e</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">e</span> <span class="ow">is</span> <span class="bp">Ellipsis</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="nb">slice</span><span class="p">)</span>
             <span class="ow">or</span> <span class="n">_is_int_arraylike</span><span class="p">(</span><span class="n">e</span><span class="p">)</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">idx</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">_is_int_arraylike</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
<span class="w">  </span><span class="sd">&quot;&quot;&quot;Returns True if x is array-like with integer dtype, False otherwise.&quot;&quot;&quot;</span>
  <span class="k">return</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="nb">bool</span><span class="p">)</span>
          <span class="ow">or</span> <span class="n">issubdtype</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="s2">&quot;dtype&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">integer</span><span class="p">)</span>
          <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">))</span> <span class="ow">and</span> <span class="nb">all</span><span class="p">(</span><span class="n">_is_int_arraylike</span><span class="p">(</span><span class="n">e</span><span class="p">)</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">x</span><span class="p">))</span>

<span class="k">def</span> <span class="nf">_is_scalar</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
<span class="w">  </span><span class="sd">&quot;&quot;&quot;Checks if a Python or NumPy scalar.&quot;&quot;&quot;</span>
  <span class="k">return</span>  <span class="n">np</span><span class="o">.</span><span class="n">isscalar</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">Array</span><span class="p">))</span>
                             <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">ndim</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">_canonicalize_tuple_index</span><span class="p">(</span><span class="n">arr_ndim</span><span class="p">,</span> <span class="n">idx</span><span class="p">,</span> <span class="n">array_name</span><span class="o">=</span><span class="s1">&#39;array&#39;</span><span class="p">):</span>
<span class="w">  </span><span class="sd">&quot;&quot;&quot;Helper to remove Ellipsis and add in the implicit trailing slice(None).&quot;&quot;&quot;</span>
  <span class="n">len_without_none</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="mi">1</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">idx</span> <span class="k">if</span> <span class="n">e</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">e</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">Ellipsis</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">len_without_none</span> <span class="o">&gt;</span> <span class="n">arr_ndim</span><span class="p">:</span>
    <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span>
        <span class="sa">f</span><span class="s2">&quot;Too many indices for </span><span class="si">{</span><span class="n">array_name</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">len_without_none</span><span class="si">}</span><span class="s2"> &quot;</span>
        <span class="sa">f</span><span class="s2">&quot;non-None/Ellipsis indices for dim </span><span class="si">{</span><span class="n">arr_ndim</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>
  <span class="n">ellipses</span> <span class="o">=</span> <span class="p">(</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">elt</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span> <span class="k">if</span> <span class="n">elt</span> <span class="ow">is</span> <span class="bp">Ellipsis</span><span class="p">)</span>
  <span class="n">ellipsis_index</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">ellipses</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">ellipsis_index</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
    <span class="k">if</span> <span class="nb">next</span><span class="p">(</span><span class="n">ellipses</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
      <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span>
          <span class="sa">f</span><span class="s2">&quot;Multiple ellipses (...) not supported: </span><span class="si">{</span><span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">type</span><span class="p">,</span><span class="w"> </span><span class="n">idx</span><span class="p">))</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>
    <span class="n">colons</span> <span class="o">=</span> <span class="p">(</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">),)</span> <span class="o">*</span> <span class="p">(</span><span class="n">arr_ndim</span> <span class="o">-</span> <span class="n">len_without_none</span><span class="p">)</span>
    <span class="n">idx</span> <span class="o">=</span> <span class="n">idx</span><span class="p">[:</span><span class="n">ellipsis_index</span><span class="p">]</span> <span class="o">+</span> <span class="n">colons</span> <span class="o">+</span> <span class="n">idx</span><span class="p">[</span><span class="n">ellipsis_index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:]</span>
  <span class="k">elif</span> <span class="n">len_without_none</span> <span class="o">&lt;</span> <span class="n">arr_ndim</span><span class="p">:</span>
    <span class="n">colons</span> <span class="o">=</span> <span class="p">(</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">),)</span> <span class="o">*</span> <span class="p">(</span><span class="n">arr_ndim</span> <span class="o">-</span> <span class="n">len_without_none</span><span class="p">)</span>
    <span class="n">idx</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span> <span class="o">+</span> <span class="n">colons</span>
  <span class="k">return</span> <span class="n">idx</span>

<span class="k">def</span> <span class="nf">_static_idx</span><span class="p">(</span><span class="n">idx</span><span class="p">:</span> <span class="nb">slice</span><span class="p">,</span> <span class="n">size</span><span class="p">:</span> <span class="n">DimSize</span><span class="p">):</span>
<span class="w">  </span><span class="sd">&quot;&quot;&quot;Helper function to compute the static slice start/limit/stride values.&quot;&quot;&quot;</span>
  <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
    <span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="n">step</span> <span class="o">=</span> <span class="n">idx</span><span class="o">.</span><span class="n">indices</span><span class="p">(</span><span class="n">size</span><span class="p">)</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="n">size</span><span class="p">)</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">step</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">stop</span> <span class="o">&gt;=</span> <span class="n">start</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">step</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">start</span> <span class="o">&gt;=</span> <span class="n">stop</span><span class="p">):</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="kc">False</span>  <span class="c1"># sliced to size zero</span>

  <span class="k">if</span> <span class="n">step</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="n">step</span><span class="p">,</span> <span class="kc">False</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="n">k</span>  <span class="o">=</span> <span class="p">(</span><span class="n">start</span> <span class="o">-</span> <span class="n">stop</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="p">(</span><span class="o">-</span><span class="n">step</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">stop</span> <span class="o">+</span> <span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">start</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="n">step</span><span class="p">,</span> <span class="kc">True</span>


<span class="nd">@util</span><span class="o">.</span><span class="n">_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">blackman</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">blackman</span><span class="p">(</span><span class="n">M</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Array</span><span class="p">:</span>
  <span class="n">M</span> <span class="o">=</span> <span class="n">core</span><span class="o">.</span><span class="n">concrete_or_error</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="n">M</span><span class="p">,</span> <span class="s2">&quot;M argument of jnp.blackman&quot;</span><span class="p">)</span>
  <span class="n">dtype</span> <span class="o">=</span> <span class="n">dtypes</span><span class="o">.</span><span class="n">canonicalize_dtype</span><span class="p">(</span><span class="n">float_</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">M</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">ones</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">dtype</span><span class="p">)</span>
  <span class="n">n</span> <span class="o">=</span> <span class="n">lax</span><span class="o">.</span><span class="n">iota</span><span class="p">(</span><span class="n">dtype</span><span class="p">,</span> <span class="n">M</span><span class="p">)</span>
  <span class="k">return</span> <span class="mf">0.42</span> <span class="o">-</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">ufuncs</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">pi</span> <span class="o">*</span> <span class="n">n</span> <span class="o">/</span> <span class="p">(</span><span class="n">M</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span> <span class="o">+</span> <span class="mf">0.08</span> <span class="o">*</span> <span class="n">ufuncs</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="mi">4</span> <span class="o">*</span> <span class="n">pi</span> <span class="o">*</span> <span class="n">n</span> <span class="o">/</span> <span class="p">(</span><span class="n">M</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>


<span class="nd">@util</span><span class="o">.</span><span class="n">_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">bartlett</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">bartlett</span><span class="p">(</span><span class="n">M</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Array</span><span class="p">:</span>
  <span class="n">M</span> <span class="o">=</span> <span class="n">core</span><span class="o">.</span><span class="n">concrete_or_error</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="n">M</span><span class="p">,</span> <span class="s2">&quot;M argument of jnp.bartlett&quot;</span><span class="p">)</span>
  <span class="n">dtype</span> <span class="o">=</span> <span class="n">dtypes</span><span class="o">.</span><span class="n">canonicalize_dtype</span><span class="p">(</span><span class="n">float_</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">M</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">ones</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">dtype</span><span class="p">)</span>
  <span class="n">n</span> <span class="o">=</span> <span class="n">lax</span><span class="o">.</span><span class="n">iota</span><span class="p">(</span><span class="n">dtype</span><span class="p">,</span> <span class="n">M</span><span class="p">)</span>
  <span class="k">return</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">ufuncs</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">n</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">M</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">M</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>


<span class="nd">@util</span><span class="o">.</span><span class="n">_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">hamming</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">hamming</span><span class="p">(</span><span class="n">M</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Array</span><span class="p">:</span>
  <span class="n">M</span> <span class="o">=</span> <span class="n">core</span><span class="o">.</span><span class="n">concrete_or_error</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="n">M</span><span class="p">,</span> <span class="s2">&quot;M argument of jnp.hamming&quot;</span><span class="p">)</span>
  <span class="n">dtype</span> <span class="o">=</span> <span class="n">dtypes</span><span class="o">.</span><span class="n">canonicalize_dtype</span><span class="p">(</span><span class="n">float_</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">M</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">ones</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">dtype</span><span class="p">)</span>
  <span class="n">n</span> <span class="o">=</span> <span class="n">lax</span><span class="o">.</span><span class="n">iota</span><span class="p">(</span><span class="n">dtype</span><span class="p">,</span> <span class="n">M</span><span class="p">)</span>
  <span class="k">return</span> <span class="mf">0.54</span> <span class="o">-</span> <span class="mf">0.46</span> <span class="o">*</span> <span class="n">ufuncs</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">pi</span> <span class="o">*</span> <span class="n">n</span> <span class="o">/</span> <span class="p">(</span><span class="n">M</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>


<span class="nd">@util</span><span class="o">.</span><span class="n">_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">hanning</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">hanning</span><span class="p">(</span><span class="n">M</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Array</span><span class="p">:</span>
  <span class="n">M</span> <span class="o">=</span> <span class="n">core</span><span class="o">.</span><span class="n">concrete_or_error</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="n">M</span><span class="p">,</span> <span class="s2">&quot;M argument of jnp.hanning&quot;</span><span class="p">)</span>
  <span class="n">dtype</span> <span class="o">=</span> <span class="n">dtypes</span><span class="o">.</span><span class="n">canonicalize_dtype</span><span class="p">(</span><span class="n">float_</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">M</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">ones</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">dtype</span><span class="p">)</span>
  <span class="n">n</span> <span class="o">=</span> <span class="n">lax</span><span class="o">.</span><span class="n">iota</span><span class="p">(</span><span class="n">dtype</span><span class="p">,</span> <span class="n">M</span><span class="p">)</span>
  <span class="k">return</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">ufuncs</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">pi</span> <span class="o">*</span> <span class="n">n</span> <span class="o">/</span> <span class="p">(</span><span class="n">M</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)))</span>


<span class="nd">@util</span><span class="o">.</span><span class="n">_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">kaiser</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">kaiser</span><span class="p">(</span><span class="n">M</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">beta</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Array</span><span class="p">:</span>
  <span class="n">M</span> <span class="o">=</span> <span class="n">core</span><span class="o">.</span><span class="n">concrete_or_error</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="n">M</span><span class="p">,</span> <span class="s2">&quot;M argument of jnp.kaiser&quot;</span><span class="p">)</span>
  <span class="n">dtype</span> <span class="o">=</span> <span class="n">dtypes</span><span class="o">.</span><span class="n">canonicalize_dtype</span><span class="p">(</span><span class="n">float_</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">M</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">ones</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">dtype</span><span class="p">)</span>
  <span class="n">n</span> <span class="o">=</span> <span class="n">lax</span><span class="o">.</span><span class="n">iota</span><span class="p">(</span><span class="n">dtype</span><span class="p">,</span> <span class="n">M</span><span class="p">)</span>
  <span class="n">alpha</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="n">M</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">i0</span><span class="p">(</span><span class="n">beta</span> <span class="o">*</span> <span class="n">ufuncs</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="p">((</span><span class="n">n</span> <span class="o">-</span> <span class="n">alpha</span><span class="p">)</span> <span class="o">/</span> <span class="n">alpha</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span><span class="p">))</span> <span class="o">/</span> <span class="n">i0</span><span class="p">(</span><span class="n">beta</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_gcd_cond_fn</span><span class="p">(</span><span class="n">xs</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">Array</span><span class="p">,</span> <span class="n">Array</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Array</span><span class="p">:</span>
  <span class="n">x1</span><span class="p">,</span> <span class="n">x2</span> <span class="o">=</span> <span class="n">xs</span>
  <span class="k">return</span> <span class="n">reductions</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">x2</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">_gcd_body_fn</span><span class="p">(</span><span class="n">xs</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">Array</span><span class="p">,</span> <span class="n">Array</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">Array</span><span class="p">,</span> <span class="n">Array</span><span class="p">]:</span>
  <span class="n">x1</span><span class="p">,</span> <span class="n">x2</span> <span class="o">=</span> <span class="n">xs</span>
  <span class="n">x1</span><span class="p">,</span> <span class="n">x2</span> <span class="o">=</span> <span class="p">(</span><span class="n">where</span><span class="p">(</span><span class="n">x2</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="n">x1</span><span class="p">),</span>
            <span class="n">where</span><span class="p">(</span><span class="n">x2</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">lax</span><span class="o">.</span><span class="n">rem</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">),</span> <span class="n">_lax_const</span><span class="p">(</span><span class="n">x2</span><span class="p">,</span> <span class="mi">0</span><span class="p">)))</span>
  <span class="k">return</span> <span class="p">(</span><span class="n">where</span><span class="p">(</span><span class="n">x1</span> <span class="o">&lt;</span> <span class="n">x2</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="n">x1</span><span class="p">),</span> <span class="n">where</span><span class="p">(</span><span class="n">x1</span> <span class="o">&lt;</span> <span class="n">x2</span><span class="p">,</span> <span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">))</span>

<span class="nd">@util</span><span class="o">.</span><span class="n">_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">gcd</span><span class="p">,</span> <span class="n">module</span><span class="o">=</span><span class="s1">&#39;numpy&#39;</span><span class="p">)</span>
<span class="nd">@jit</span>
<span class="k">def</span> <span class="nf">gcd</span><span class="p">(</span><span class="n">x1</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">,</span> <span class="n">x2</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Array</span><span class="p">:</span>
  <span class="n">util</span><span class="o">.</span><span class="n">check_arraylike</span><span class="p">(</span><span class="s2">&quot;gcd&quot;</span><span class="p">,</span> <span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">)</span>
  <span class="n">x1</span><span class="p">,</span> <span class="n">x2</span> <span class="o">=</span> <span class="n">util</span><span class="o">.</span><span class="n">promote_dtypes</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">)</span>
  <span class="k">if</span> <span class="ow">not</span> <span class="n">issubdtype</span><span class="p">(</span><span class="n">_dtype</span><span class="p">(</span><span class="n">x1</span><span class="p">),</span> <span class="n">integer</span><span class="p">):</span>
    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Arguments to jax.numpy.gcd must be integers.&quot;</span><span class="p">)</span>
  <span class="n">x1</span><span class="p">,</span> <span class="n">x2</span> <span class="o">=</span> <span class="n">broadcast_arrays</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">)</span>
  <span class="n">gcd</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">lax</span><span class="o">.</span><span class="n">while_loop</span><span class="p">(</span><span class="n">_gcd_cond_fn</span><span class="p">,</span> <span class="n">_gcd_body_fn</span><span class="p">,</span> <span class="p">(</span><span class="n">ufuncs</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">x1</span><span class="p">),</span> <span class="n">ufuncs</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">x2</span><span class="p">)))</span>
  <span class="k">return</span> <span class="n">gcd</span>


<span class="nd">@util</span><span class="o">.</span><span class="n">_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">lcm</span><span class="p">,</span> <span class="n">module</span><span class="o">=</span><span class="s1">&#39;numpy&#39;</span><span class="p">)</span>
<span class="nd">@jit</span>
<span class="k">def</span> <span class="nf">lcm</span><span class="p">(</span><span class="n">x1</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">,</span> <span class="n">x2</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Array</span><span class="p">:</span>
  <span class="n">util</span><span class="o">.</span><span class="n">check_arraylike</span><span class="p">(</span><span class="s2">&quot;lcm&quot;</span><span class="p">,</span> <span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">)</span>
  <span class="n">x1</span><span class="p">,</span> <span class="n">x2</span> <span class="o">=</span> <span class="n">util</span><span class="o">.</span><span class="n">promote_dtypes</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">)</span>
  <span class="n">x1</span><span class="p">,</span> <span class="n">x2</span> <span class="o">=</span> <span class="n">ufuncs</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">x1</span><span class="p">),</span> <span class="n">ufuncs</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">x2</span><span class="p">)</span>
  <span class="k">if</span> <span class="ow">not</span> <span class="n">issubdtype</span><span class="p">(</span><span class="n">_dtype</span><span class="p">(</span><span class="n">x1</span><span class="p">),</span> <span class="n">integer</span><span class="p">):</span>
    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Arguments to jax.numpy.lcm must be integers.&quot;</span><span class="p">)</span>
  <span class="n">d</span> <span class="o">=</span> <span class="n">gcd</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">where</span><span class="p">(</span><span class="n">d</span> <span class="o">==</span> <span class="mi">0</span><span class="p">,</span> <span class="n">_lax_const</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
               <span class="n">ufuncs</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">ufuncs</span><span class="o">.</span><span class="n">floor_divide</span><span class="p">(</span><span class="n">x2</span><span class="p">,</span> <span class="n">d</span><span class="p">)))</span>


<span class="nd">@util</span><span class="o">.</span><span class="n">_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">extract</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">extract</span><span class="p">(</span><span class="n">condition</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">,</span> <span class="n">arr</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Array</span><span class="p">:</span>
  <span class="k">return</span> <span class="n">compress</span><span class="p">(</span><span class="n">ravel</span><span class="p">(</span><span class="n">condition</span><span class="p">),</span> <span class="n">ravel</span><span class="p">(</span><span class="n">arr</span><span class="p">))</span>


<span class="nd">@util</span><span class="o">.</span><span class="n">_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">compress</span><span class="p">,</span> <span class="n">skip_params</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;out&#39;</span><span class="p">])</span>
<span class="k">def</span> <span class="nf">compress</span><span class="p">(</span><span class="n">condition</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">,</span> <span class="n">a</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">,</span> <span class="n">axis</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
             <span class="n">out</span><span class="p">:</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Array</span><span class="p">:</span>
  <span class="n">util</span><span class="o">.</span><span class="n">check_arraylike</span><span class="p">(</span><span class="s2">&quot;compress&quot;</span><span class="p">,</span> <span class="n">condition</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
  <span class="n">condition_arr</span> <span class="o">=</span> <span class="n">asarray</span><span class="p">(</span><span class="n">condition</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">bool</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">out</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
    <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;The &#39;out&#39; argument to jnp.compress is not supported.&quot;</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">condition_arr</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;condition must be a 1D array&quot;</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">axis</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
    <span class="n">axis</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">arr</span> <span class="o">=</span> <span class="n">ravel</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="n">arr</span> <span class="o">=</span> <span class="n">moveaxis</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
  <span class="n">condition_arr</span><span class="p">,</span> <span class="n">extra</span> <span class="o">=</span> <span class="n">condition_arr</span><span class="p">[:</span><span class="n">arr</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span> <span class="n">condition_arr</span><span class="p">[</span><span class="n">arr</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]:]</span>
  <span class="k">if</span> <span class="n">reductions</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">extra</span><span class="p">):</span>
    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;condition contains entries that are out of bounds&quot;</span><span class="p">)</span>
  <span class="n">arr</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[:</span><span class="n">condition_arr</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
  <span class="k">return</span> <span class="n">moveaxis</span><span class="p">(</span><span class="n">arr</span><span class="p">[</span><span class="n">condition_arr</span><span class="p">],</span> <span class="mi">0</span><span class="p">,</span> <span class="n">axis</span><span class="p">)</span>


<span class="nd">@util</span><span class="o">.</span><span class="n">_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">cov</span><span class="p">)</span>
<span class="nd">@partial</span><span class="p">(</span><span class="n">jit</span><span class="p">,</span> <span class="n">static_argnames</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;rowvar&#39;</span><span class="p">,</span> <span class="s1">&#39;bias&#39;</span><span class="p">,</span> <span class="s1">&#39;ddof&#39;</span><span class="p">))</span>
<span class="k">def</span> <span class="nf">cov</span><span class="p">(</span><span class="n">m</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">ArrayLike</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">rowvar</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">bias</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">ddof</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">fweights</span><span class="p">:</span> <span class="n">ArrayLike</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">aweights</span><span class="p">:</span> <span class="n">ArrayLike</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Array</span><span class="p">:</span>
  <span class="k">if</span> <span class="n">y</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
    <span class="n">m</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">util</span><span class="o">.</span><span class="n">promote_args_inexact</span><span class="p">(</span><span class="s2">&quot;cov&quot;</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">y</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
      <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;y has more than 2 dimensions&quot;</span><span class="p">)</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="n">m</span><span class="p">,</span> <span class="o">=</span> <span class="n">util</span><span class="o">.</span><span class="n">promote_args_inexact</span><span class="p">(</span><span class="s2">&quot;cov&quot;</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span>

  <span class="k">if</span> <span class="n">m</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;m has more than 2 dimensions&quot;</span><span class="p">)</span>  <span class="c1"># same as numpy error</span>

  <span class="n">X</span> <span class="o">=</span> <span class="n">atleast_2d</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
  <span class="k">if</span> <span class="ow">not</span> <span class="n">rowvar</span> <span class="ow">and</span> <span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
    <span class="n">X</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">T</span>
  <span class="k">if</span> <span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">array</span><span class="p">([])</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

  <span class="k">if</span> <span class="n">y</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
    <span class="n">y_arr</span> <span class="o">=</span> <span class="n">atleast_2d</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">rowvar</span> <span class="ow">and</span> <span class="n">y_arr</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
      <span class="n">y_arr</span> <span class="o">=</span> <span class="n">y_arr</span><span class="o">.</span><span class="n">T</span>
    <span class="n">X</span> <span class="o">=</span> <span class="n">concatenate</span><span class="p">((</span><span class="n">X</span><span class="p">,</span> <span class="n">y_arr</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">ddof</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
    <span class="n">ddof</span> <span class="o">=</span> <span class="mi">1</span> <span class="k">if</span> <span class="n">bias</span> <span class="o">==</span> <span class="mi">0</span> <span class="k">else</span> <span class="mi">0</span>

  <span class="n">w</span><span class="p">:</span> <span class="n">Array</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span>
  <span class="k">if</span> <span class="n">fweights</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
    <span class="n">util</span><span class="o">.</span><span class="n">check_arraylike</span><span class="p">(</span><span class="s2">&quot;cov&quot;</span><span class="p">,</span> <span class="n">fweights</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">ndim</span><span class="p">(</span><span class="n">fweights</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
      <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;cannot handle multidimensional fweights&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">shape</span><span class="p">(</span><span class="n">fweights</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
      <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;incompatible numbers of samples and fweights&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">issubdtype</span><span class="p">(</span><span class="n">_dtype</span><span class="p">(</span><span class="n">fweights</span><span class="p">),</span> <span class="n">integer</span><span class="p">):</span>
      <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;fweights must be integer.&quot;</span><span class="p">)</span>
    <span class="c1"># Ensure positive fweights; note that numpy raises an error on negative fweights.</span>
    <span class="n">w</span> <span class="o">=</span> <span class="n">asarray</span><span class="p">(</span><span class="n">ufuncs</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">fweights</span><span class="p">))</span>
  <span class="k">if</span> <span class="n">aweights</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
    <span class="n">util</span><span class="o">.</span><span class="n">check_arraylike</span><span class="p">(</span><span class="s2">&quot;cov&quot;</span><span class="p">,</span> <span class="n">aweights</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">ndim</span><span class="p">(</span><span class="n">aweights</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
      <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;cannot handle multidimensional aweights&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">shape</span><span class="p">(</span><span class="n">aweights</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
      <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;incompatible numbers of samples and aweights&quot;</span><span class="p">)</span>
    <span class="c1"># Ensure positive aweights: note that numpy raises an error for negative aweights.</span>
    <span class="n">aweights</span> <span class="o">=</span> <span class="n">ufuncs</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">aweights</span><span class="p">)</span>
    <span class="n">w</span> <span class="o">=</span> <span class="n">asarray</span><span class="p">(</span><span class="n">aweights</span><span class="p">)</span> <span class="k">if</span> <span class="n">w</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">w</span> <span class="o">*</span> <span class="n">asarray</span><span class="p">(</span><span class="n">aweights</span><span class="p">)</span>

  <span class="n">avg</span><span class="p">,</span> <span class="n">w_sum</span> <span class="o">=</span> <span class="n">reductions</span><span class="o">.</span><span class="n">average</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">weights</span><span class="o">=</span><span class="n">w</span><span class="p">,</span> <span class="n">returned</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
  <span class="n">w_sum</span> <span class="o">=</span> <span class="n">w_sum</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

  <span class="k">if</span> <span class="n">w</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
    <span class="n">f</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">ddof</span>
  <span class="k">elif</span> <span class="n">ddof</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
    <span class="n">f</span> <span class="o">=</span> <span class="n">w_sum</span>
  <span class="k">elif</span> <span class="n">aweights</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
    <span class="n">f</span> <span class="o">=</span> <span class="n">w_sum</span> <span class="o">-</span> <span class="n">ddof</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="n">f</span> <span class="o">=</span> <span class="n">w_sum</span> <span class="o">-</span> <span class="n">ddof</span> <span class="o">*</span> <span class="n">reductions</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">w</span> <span class="o">*</span> <span class="n">aweights</span><span class="p">)</span> <span class="o">/</span> <span class="n">w_sum</span>

  <span class="n">X</span> <span class="o">=</span> <span class="n">X</span> <span class="o">-</span> <span class="n">avg</span><span class="p">[:,</span> <span class="kc">None</span><span class="p">]</span>
  <span class="n">X_T</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">T</span> <span class="k">if</span> <span class="n">w</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="p">(</span><span class="n">X</span> <span class="o">*</span> <span class="n">lax</span><span class="o">.</span><span class="n">broadcast_to_rank</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="n">X</span><span class="o">.</span><span class="n">ndim</span><span class="p">))</span><span class="o">.</span><span class="n">T</span>
  <span class="k">return</span> <span class="n">ufuncs</span><span class="o">.</span><span class="n">true_divide</span><span class="p">(</span><span class="n">dot</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">X_T</span><span class="o">.</span><span class="n">conj</span><span class="p">()),</span> <span class="n">f</span><span class="p">)</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>


<span class="nd">@util</span><span class="o">.</span><span class="n">_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">corrcoef</span><span class="p">)</span>
<span class="nd">@partial</span><span class="p">(</span><span class="n">jit</span><span class="p">,</span> <span class="n">static_argnames</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;rowvar&#39;</span><span class="p">,))</span>
<span class="k">def</span> <span class="nf">corrcoef</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">ArrayLike</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">rowvar</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Array</span><span class="p">:</span>
  <span class="n">util</span><span class="o">.</span><span class="n">check_arraylike</span><span class="p">(</span><span class="s2">&quot;corrcoef&quot;</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
  <span class="n">c</span> <span class="o">=</span> <span class="n">cov</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">rowvar</span><span class="p">)</span>
  <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">shape</span><span class="p">(</span><span class="n">c</span><span class="p">))</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
    <span class="c1"># scalar - this should yield nan for values (nan/nan, inf/inf, 0/0), 1 otherwise</span>
    <span class="k">return</span> <span class="n">ufuncs</span><span class="o">.</span><span class="n">divide</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span>
  <span class="n">d</span> <span class="o">=</span> <span class="n">diag</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
  <span class="n">stddev</span> <span class="o">=</span> <span class="n">ufuncs</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">ufuncs</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">d</span><span class="p">))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
  <span class="n">c</span> <span class="o">=</span> <span class="n">c</span> <span class="o">/</span> <span class="n">stddev</span><span class="p">[:,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">/</span> <span class="n">stddev</span><span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="p">:]</span>

  <span class="n">real_part</span> <span class="o">=</span> <span class="n">clip</span><span class="p">(</span><span class="n">ufuncs</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">c</span><span class="p">),</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">iscomplexobj</span><span class="p">(</span><span class="n">c</span><span class="p">):</span>
    <span class="n">complex_part</span> <span class="o">=</span> <span class="n">clip</span><span class="p">(</span><span class="n">ufuncs</span><span class="o">.</span><span class="n">imag</span><span class="p">(</span><span class="n">c</span><span class="p">),</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">c</span> <span class="o">=</span> <span class="n">lax</span><span class="o">.</span><span class="n">complex</span><span class="p">(</span><span class="n">real_part</span><span class="p">,</span> <span class="n">complex_part</span><span class="p">)</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="n">c</span> <span class="o">=</span> <span class="n">real_part</span>
  <span class="k">return</span> <span class="n">c</span>


<span class="nd">@partial</span><span class="p">(</span><span class="n">vectorize</span><span class="p">,</span> <span class="n">excluded</span><span class="o">=</span><span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">})</span>
<span class="k">def</span> <span class="nf">_searchsorted_via_scan</span><span class="p">(</span><span class="n">unrolled</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span> <span class="n">sorted_arr</span><span class="p">:</span> <span class="n">Array</span><span class="p">,</span> <span class="n">query</span><span class="p">:</span> <span class="n">Array</span><span class="p">,</span> <span class="n">side</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">dtype</span><span class="p">:</span> <span class="nb">type</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Array</span><span class="p">:</span>
  <span class="n">op</span> <span class="o">=</span> <span class="n">_sort_le_comparator</span> <span class="k">if</span> <span class="n">side</span> <span class="o">==</span> <span class="s1">&#39;left&#39;</span> <span class="k">else</span> <span class="n">_sort_lt_comparator</span>
  <span class="k">def</span> <span class="nf">body_fun</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">_</span><span class="p">):</span>
    <span class="n">low</span><span class="p">,</span> <span class="n">high</span> <span class="o">=</span> <span class="n">state</span>
    <span class="n">mid</span> <span class="o">=</span> <span class="p">(</span><span class="n">low</span> <span class="o">+</span> <span class="n">high</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span>
    <span class="n">go_left</span> <span class="o">=</span> <span class="n">op</span><span class="p">(</span><span class="n">query</span><span class="p">,</span> <span class="n">sorted_arr</span><span class="p">[</span><span class="n">mid</span><span class="p">])</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">where</span><span class="p">(</span><span class="n">go_left</span><span class="p">,</span> <span class="n">low</span><span class="p">,</span> <span class="n">mid</span><span class="p">),</span> <span class="n">where</span><span class="p">(</span><span class="n">go_left</span><span class="p">,</span> <span class="n">mid</span><span class="p">,</span> <span class="n">high</span><span class="p">)),</span> <span class="p">()</span>
  <span class="n">n_levels</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log2</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">sorted_arr</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)))</span>
  <span class="n">init</span> <span class="o">=</span> <span class="p">(</span><span class="n">dtype</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">dtype</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">sorted_arr</span><span class="p">)))</span>
  <span class="n">carry</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">lax</span><span class="o">.</span><span class="n">scan</span><span class="p">(</span><span class="n">body_fun</span><span class="p">,</span> <span class="n">init</span><span class="p">,</span> <span class="p">(),</span> <span class="n">length</span><span class="o">=</span><span class="n">n_levels</span><span class="p">,</span>
                      <span class="n">unroll</span><span class="o">=</span><span class="n">n_levels</span> <span class="k">if</span> <span class="n">unrolled</span> <span class="k">else</span> <span class="mi">1</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">carry</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>


<span class="k">def</span> <span class="nf">_searchsorted_via_sort</span><span class="p">(</span><span class="n">sorted_arr</span><span class="p">:</span> <span class="n">Array</span><span class="p">,</span> <span class="n">query</span><span class="p">:</span> <span class="n">Array</span><span class="p">,</span> <span class="n">side</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">dtype</span><span class="p">:</span> <span class="nb">type</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Array</span><span class="p">:</span>
  <span class="n">working_dtype</span> <span class="o">=</span> <span class="n">int32</span> <span class="k">if</span> <span class="n">sorted_arr</span><span class="o">.</span><span class="n">size</span> <span class="o">+</span> <span class="n">query</span><span class="o">.</span><span class="n">size</span> <span class="o">&lt;</span> <span class="n">np</span><span class="o">.</span><span class="n">iinfo</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span><span class="o">.</span><span class="n">max</span> <span class="k">else</span> <span class="n">int64</span>
  <span class="k">def</span> <span class="nf">_rank</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="n">idx</span> <span class="o">=</span> <span class="n">lax</span><span class="o">.</span><span class="n">iota</span><span class="p">(</span><span class="n">working_dtype</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">zeros_like</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span><span class="o">.</span><span class="n">at</span><span class="p">[</span><span class="n">argsort</span><span class="p">(</span><span class="n">x</span><span class="p">)]</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span>
  <span class="n">query_flat</span> <span class="o">=</span> <span class="n">query</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
  <span class="k">if</span> <span class="n">side</span> <span class="o">==</span> <span class="s1">&#39;left&#39;</span><span class="p">:</span>
    <span class="n">index</span> <span class="o">=</span> <span class="n">_rank</span><span class="p">(</span><span class="n">lax</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">query_flat</span><span class="p">,</span> <span class="n">sorted_arr</span><span class="p">],</span> <span class="mi">0</span><span class="p">))[:</span><span class="n">query</span><span class="o">.</span><span class="n">size</span><span class="p">]</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="n">index</span> <span class="o">=</span> <span class="n">_rank</span><span class="p">(</span><span class="n">lax</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">sorted_arr</span><span class="p">,</span> <span class="n">query_flat</span><span class="p">],</span> <span class="mi">0</span><span class="p">))[</span><span class="n">sorted_arr</span><span class="o">.</span><span class="n">size</span><span class="p">:]</span>
  <span class="k">return</span> <span class="n">lax</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">lax</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">_rank</span><span class="p">(</span><span class="n">query_flat</span><span class="p">)),</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">query</span><span class="p">))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_searchsorted_via_compare_all</span><span class="p">(</span><span class="n">sorted_arr</span><span class="p">:</span> <span class="n">Array</span><span class="p">,</span> <span class="n">query</span><span class="p">:</span> <span class="n">Array</span><span class="p">,</span> <span class="n">side</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">dtype</span><span class="p">:</span> <span class="nb">type</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Array</span><span class="p">:</span>
  <span class="n">op</span> <span class="o">=</span> <span class="n">_sort_lt_comparator</span> <span class="k">if</span> <span class="n">side</span> <span class="o">==</span> <span class="s1">&#39;left&#39;</span> <span class="k">else</span> <span class="n">_sort_le_comparator</span>
  <span class="n">comparisons</span> <span class="o">=</span> <span class="n">jax</span><span class="o">.</span><span class="n">vmap</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="n">in_axes</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="kc">None</span><span class="p">))(</span><span class="n">sorted_arr</span><span class="p">,</span> <span class="n">query</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">comparisons</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>


<span class="nd">@util</span><span class="o">.</span><span class="n">_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">searchsorted</span><span class="p">,</span> <span class="n">skip_params</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;sorter&#39;</span><span class="p">],</span>
  <span class="n">extra_params</span><span class="o">=</span><span class="n">_dedent</span><span class="p">(</span><span class="s2">&quot;&quot;&quot;</span>
<span class="s2">    method : str</span>
<span class="s2">        One of &#39;scan&#39; (default), &#39;scan_unrolled&#39;, &#39;sort&#39; or &#39;compare_all&#39;. Controls the method used by the</span>
<span class="s2">        implementation: &#39;scan&#39; tends to be more performant on CPU (particularly when ``a`` is</span>
<span class="s2">        very large), &#39;scan_unrolled&#39; is more performant on GPU at the expense of additional compile time,</span>
<span class="s2">        &#39;sort&#39; is often more performant on accelerator backends like GPU and TPU</span>
<span class="s2">        (particularly when ``v`` is very large), and &#39;compare_all&#39; can be most performant</span>
<span class="s2">        when ``a`` is very small.&quot;&quot;&quot;</span><span class="p">))</span>
<span class="nd">@partial</span><span class="p">(</span><span class="n">jit</span><span class="p">,</span> <span class="n">static_argnames</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;side&#39;</span><span class="p">,</span> <span class="s1">&#39;sorter&#39;</span><span class="p">,</span> <span class="s1">&#39;method&#39;</span><span class="p">))</span>
<span class="k">def</span> <span class="nf">searchsorted</span><span class="p">(</span><span class="n">a</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">,</span> <span class="n">v</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">,</span> <span class="n">side</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;left&#39;</span><span class="p">,</span>
                 <span class="n">sorter</span><span class="p">:</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">method</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;scan&#39;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Array</span><span class="p">:</span>
  <span class="n">util</span><span class="o">.</span><span class="n">check_arraylike</span><span class="p">(</span><span class="s2">&quot;searchsorted&quot;</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">side</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;left&#39;</span><span class="p">,</span> <span class="s1">&#39;right&#39;</span><span class="p">]:</span>
    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">side</span><span class="si">!r}</span><span class="s2"> is an invalid value for keyword &#39;side&#39;. &quot;</span>
                     <span class="s2">&quot;Expected one of [&#39;left&#39;, &#39;right&#39;].&quot;</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">method</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;scan&#39;</span><span class="p">,</span> <span class="s1">&#39;scan_unrolled&#39;</span><span class="p">,</span> <span class="s1">&#39;sort&#39;</span><span class="p">,</span> <span class="s1">&#39;compare_all&#39;</span><span class="p">]:</span>
    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
        <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">method</span><span class="si">!r}</span><span class="s2"> is an invalid value for keyword &#39;method&#39;. &quot;</span>
        <span class="s2">&quot;Expected one of [&#39;sort&#39;, &#39;scan&#39;, &#39;scan_unrolled&#39;, &#39;compare_all&#39;].&quot;</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">sorter</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
    <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;sorter is not implemented&quot;</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">ndim</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;a should be 1-dimensional&quot;</span><span class="p">)</span>
  <span class="n">a</span><span class="p">,</span> <span class="n">v</span> <span class="o">=</span> <span class="n">util</span><span class="o">.</span><span class="n">promote_dtypes</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
  <span class="n">dtype</span> <span class="o">=</span> <span class="n">int32</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">np</span><span class="o">.</span><span class="n">iinfo</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span><span class="o">.</span><span class="n">max</span> <span class="k">else</span> <span class="n">int64</span>
  <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">zeros_like</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>
  <span class="n">impl</span> <span class="o">=</span> <span class="p">{</span>
      <span class="s1">&#39;scan&#39;</span><span class="p">:</span> <span class="n">partial</span><span class="p">(</span><span class="n">_searchsorted_via_scan</span><span class="p">,</span> <span class="kc">False</span><span class="p">),</span>
      <span class="s1">&#39;scan_unrolled&#39;</span><span class="p">:</span> <span class="n">partial</span><span class="p">(</span><span class="n">_searchsorted_via_scan</span><span class="p">,</span> <span class="kc">True</span><span class="p">),</span>
      <span class="s1">&#39;sort&#39;</span><span class="p">:</span> <span class="n">_searchsorted_via_sort</span><span class="p">,</span>
      <span class="s1">&#39;compare_all&#39;</span><span class="p">:</span> <span class="n">_searchsorted_via_compare_all</span><span class="p">,</span>
  <span class="p">}[</span><span class="n">method</span><span class="p">]</span>
  <span class="k">return</span> <span class="n">impl</span><span class="p">(</span><span class="n">asarray</span><span class="p">(</span><span class="n">a</span><span class="p">),</span> <span class="n">asarray</span><span class="p">(</span><span class="n">v</span><span class="p">),</span> <span class="n">side</span><span class="p">,</span> <span class="n">dtype</span><span class="p">)</span>  <span class="c1"># type: ignore</span>

<span class="nd">@util</span><span class="o">.</span><span class="n">_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">digitize</span><span class="p">)</span>
<span class="nd">@partial</span><span class="p">(</span><span class="n">jit</span><span class="p">,</span> <span class="n">static_argnames</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;right&#39;</span><span class="p">,))</span>
<span class="k">def</span> <span class="nf">digitize</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">,</span> <span class="n">bins</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">,</span> <span class="n">right</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Array</span><span class="p">:</span>
  <span class="n">util</span><span class="o">.</span><span class="n">check_arraylike</span><span class="p">(</span><span class="s2">&quot;digitize&quot;</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">bins</span><span class="p">)</span>
  <span class="n">right</span> <span class="o">=</span> <span class="n">core</span><span class="o">.</span><span class="n">concrete_or_error</span><span class="p">(</span><span class="nb">bool</span><span class="p">,</span> <span class="n">right</span><span class="p">,</span> <span class="s2">&quot;right argument of jnp.digitize()&quot;</span><span class="p">)</span>
  <span class="n">bins_arr</span> <span class="o">=</span> <span class="n">asarray</span><span class="p">(</span><span class="n">bins</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">bins_arr</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;digitize: bins must be a 1-dimensional array; got </span><span class="si">{</span><span class="n">bins</span><span class="si">=}</span><span class="s2">&quot;</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">bins_arr</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">zeros</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtypes</span><span class="o">.</span><span class="n">canonicalize_dtype</span><span class="p">(</span><span class="n">int_</span><span class="p">))</span>
  <span class="n">side</span> <span class="o">=</span> <span class="s1">&#39;right&#39;</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">right</span> <span class="k">else</span> <span class="s1">&#39;left&#39;</span>
  <span class="k">return</span> <span class="n">where</span><span class="p">(</span>
    <span class="n">bins_arr</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">bins_arr</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
    <span class="n">searchsorted</span><span class="p">(</span><span class="n">bins_arr</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">side</span><span class="o">=</span><span class="n">side</span><span class="p">),</span>
    <span class="nb">len</span><span class="p">(</span><span class="n">bins_arr</span><span class="p">)</span> <span class="o">-</span> <span class="n">searchsorted</span><span class="p">(</span><span class="n">bins_arr</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">x</span><span class="p">,</span> <span class="n">side</span><span class="o">=</span><span class="n">side</span><span class="p">)</span>
  <span class="p">)</span>

<span class="n">_PIECEWISE_DOC</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span><span class="se">\</span>
<span class="s2">Unlike `np.piecewise`, :py:func:`jax.numpy.piecewise` requires functions in</span>
<span class="s2">`funclist` to be traceable by JAX, as it is implemented via :func:`jax.lax.switch`.</span>
<span class="s2">See the :func:`jax.lax.switch` documentation for more information.</span>
<span class="s2">&quot;&quot;&quot;</span>

<span class="nd">@util</span><span class="o">.</span><span class="n">_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">piecewise</span><span class="p">,</span> <span class="n">lax_description</span><span class="o">=</span><span class="n">_PIECEWISE_DOC</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">piecewise</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">,</span> <span class="n">condlist</span><span class="p">:</span> <span class="n">Array</span> <span class="o">|</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">ArrayLike</span><span class="p">],</span>
              <span class="n">funclist</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">ArrayLike</span> <span class="o">|</span> <span class="n">Callable</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">Array</span><span class="p">]],</span>
              <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Array</span><span class="p">:</span>
  <span class="n">util</span><span class="o">.</span><span class="n">check_arraylike</span><span class="p">(</span><span class="s2">&quot;piecewise&quot;</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
  <span class="n">nc</span><span class="p">,</span> <span class="n">nf</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">condlist</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">funclist</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">nf</span> <span class="o">==</span> <span class="n">nc</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:</span>
    <span class="n">funclist</span> <span class="o">=</span> <span class="n">funclist</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">:]</span> <span class="o">+</span> <span class="n">funclist</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
  <span class="k">elif</span> <span class="n">nf</span> <span class="o">==</span> <span class="n">nc</span><span class="p">:</span>
    <span class="n">funclist</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="n">funclist</span><span class="p">)</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;with </span><span class="si">{</span><span class="n">nc</span><span class="si">}</span><span class="s2"> condition(s), either </span><span class="si">{</span><span class="n">nc</span><span class="si">}</span><span class="s2"> or </span><span class="si">{</span><span class="n">nc</span><span class="o">+</span><span class="mi">1</span><span class="si">}</span><span class="s2"> functions are expected; got </span><span class="si">{</span><span class="n">nf</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
  <span class="n">consts</span> <span class="o">=</span> <span class="p">{</span><span class="n">i</span><span class="p">:</span> <span class="n">c</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">funclist</span><span class="p">)</span> <span class="k">if</span> <span class="ow">not</span> <span class="nb">callable</span><span class="p">(</span><span class="n">c</span><span class="p">)}</span>
  <span class="n">funcs</span> <span class="o">=</span> <span class="p">{</span><span class="n">i</span><span class="p">:</span> <span class="n">f</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">f</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">funclist</span><span class="p">)</span> <span class="k">if</span> <span class="nb">callable</span><span class="p">(</span><span class="n">f</span><span class="p">)}</span>
  <span class="k">return</span> <span class="n">_piecewise</span><span class="p">(</span><span class="n">asarray</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">asarray</span><span class="p">(</span><span class="n">condlist</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">bool_</span><span class="p">),</span> <span class="n">consts</span><span class="p">,</span>
                    <span class="nb">frozenset</span><span class="p">(</span><span class="n">funcs</span><span class="o">.</span><span class="n">items</span><span class="p">()),</span>  <span class="c1"># dict is not hashable.</span>
                    <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">)</span>

<span class="nd">@partial</span><span class="p">(</span><span class="n">jit</span><span class="p">,</span> <span class="n">static_argnames</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;funcs&#39;</span><span class="p">])</span>
<span class="k">def</span> <span class="nf">_piecewise</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">Array</span><span class="p">,</span> <span class="n">condlist</span><span class="p">:</span> <span class="n">Array</span><span class="p">,</span> <span class="n">consts</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">ArrayLike</span><span class="p">],</span>
               <span class="n">funcs</span><span class="p">:</span> <span class="nb">frozenset</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Callable</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">Array</span><span class="p">]]],</span>
               <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Array</span><span class="p">:</span>
  <span class="n">funcdict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">funcs</span><span class="p">)</span>
  <span class="n">funclist</span> <span class="o">=</span> <span class="p">[</span><span class="n">consts</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">funcdict</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">i</span><span class="p">))</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">condlist</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)]</span>
  <span class="n">indices</span> <span class="o">=</span> <span class="n">argmax</span><span class="p">(</span><span class="n">reductions</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">concatenate</span><span class="p">([</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">condlist</span><span class="p">[:</span><span class="mi">1</span><span class="p">]),</span> <span class="n">condlist</span><span class="p">],</span> <span class="mi">0</span><span class="p">),</span> <span class="mi">0</span><span class="p">),</span> <span class="mi">0</span><span class="p">)</span>
  <span class="n">dtype</span> <span class="o">=</span> <span class="n">_dtype</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
  <span class="k">def</span> <span class="nf">_call</span><span class="p">(</span><span class="n">f</span><span class="p">):</span>
    <span class="k">return</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span>
  <span class="k">def</span> <span class="nf">_const</span><span class="p">(</span><span class="n">v</span><span class="p">):</span>
    <span class="k">return</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">array</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>
  <span class="n">funclist</span> <span class="o">=</span> <span class="p">[</span><span class="n">_call</span><span class="p">(</span><span class="n">f</span><span class="p">)</span> <span class="k">if</span> <span class="nb">callable</span><span class="p">(</span><span class="n">f</span><span class="p">)</span> <span class="k">else</span> <span class="n">_const</span><span class="p">(</span><span class="n">f</span><span class="p">)</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">funclist</span><span class="p">]</span>
  <span class="k">return</span> <span class="n">vectorize</span><span class="p">(</span><span class="n">lax</span><span class="o">.</span><span class="n">switch</span><span class="p">,</span> <span class="n">excluded</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,))(</span><span class="n">indices</span><span class="p">,</span> <span class="n">funclist</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_tile_to_size</span><span class="p">(</span><span class="n">arr</span><span class="p">:</span> <span class="n">Array</span><span class="p">,</span> <span class="n">size</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Array</span><span class="p">:</span>
  <span class="k">assert</span> <span class="n">arr</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span>
  <span class="k">if</span> <span class="n">arr</span><span class="o">.</span><span class="n">size</span> <span class="o">&lt;</span> <span class="n">size</span><span class="p">:</span>
    <span class="n">arr</span> <span class="o">=</span> <span class="n">tile</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">size</span> <span class="o">/</span> <span class="n">arr</span><span class="o">.</span><span class="n">size</span><span class="p">)))</span>
  <span class="k">assert</span> <span class="n">arr</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;=</span> <span class="n">size</span>
  <span class="k">return</span> <span class="n">arr</span><span class="p">[:</span><span class="n">size</span><span class="p">]</span> <span class="k">if</span> <span class="n">arr</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="n">size</span> <span class="k">else</span> <span class="n">arr</span>


<span class="nd">@util</span><span class="o">.</span><span class="n">_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">place</span><span class="p">,</span> <span class="n">lax_description</span><span class="o">=</span><span class="s2">&quot;&quot;&quot;</span>
<span class="s2">The semantics of :func:`numpy.place` is to modify arrays in-place, which JAX</span>
<span class="s2">cannot do because JAX arrays are immutable. Thus :func:`jax.numpy.place` adds</span>
<span class="s2">the ``inplace`` parameter, which must be set to ``False`` by the user as a</span>
<span class="s2">reminder of this API difference.</span>
<span class="s2">&quot;&quot;&quot;</span><span class="p">,</span> <span class="n">extra_params</span><span class="o">=</span><span class="s2">&quot;&quot;&quot;</span>
<span class="s2">inplace : bool, default=True</span>
<span class="s2">    If left to its default value of True, JAX will raise an error. This is because</span>
<span class="s2">    the semantics of :func:`numpy.put` are to modify the array in-place, which is</span>
<span class="s2">    not possible in JAX due to the immutability of JAX arrays.</span>
<span class="s2">&quot;&quot;&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">place</span><span class="p">(</span><span class="n">arr</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">,</span> <span class="n">mask</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">,</span> <span class="n">vals</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span>
          <span class="n">inplace</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Array</span><span class="p">:</span>
  <span class="n">util</span><span class="o">.</span><span class="n">check_arraylike</span><span class="p">(</span><span class="s2">&quot;place&quot;</span><span class="p">,</span> <span class="n">arr</span><span class="p">,</span> <span class="n">mask</span><span class="p">,</span> <span class="n">vals</span><span class="p">)</span>
  <span class="n">data</span><span class="p">,</span> <span class="n">mask_arr</span><span class="p">,</span> <span class="n">vals_arr</span> <span class="o">=</span> <span class="n">asarray</span><span class="p">(</span><span class="n">arr</span><span class="p">),</span> <span class="n">asarray</span><span class="p">(</span><span class="n">mask</span><span class="p">),</span> <span class="n">ravel</span><span class="p">(</span><span class="n">vals</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">inplace</span><span class="p">:</span>
    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
      <span class="s2">&quot;jax.numpy.place cannot modify arrays in-place, because JAX arrays are immutable. &quot;</span>
      <span class="s2">&quot;Pass inplace=False to instead return an updated array.&quot;</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">data</span><span class="o">.</span><span class="n">size</span> <span class="o">!=</span> <span class="n">mask_arr</span><span class="o">.</span><span class="n">size</span><span class="p">:</span>
    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;place: arr and mask must be the same size&quot;</span><span class="p">)</span>
  <span class="k">if</span> <span class="ow">not</span> <span class="n">vals_arr</span><span class="o">.</span><span class="n">size</span><span class="p">:</span>
    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Cannot place values from an empty array&quot;</span><span class="p">)</span>
  <span class="k">if</span> <span class="ow">not</span> <span class="n">data</span><span class="o">.</span><span class="n">size</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">data</span>
  <span class="n">indices</span> <span class="o">=</span> <span class="n">where</span><span class="p">(</span><span class="n">mask_arr</span><span class="o">.</span><span class="n">ravel</span><span class="p">(),</span> <span class="n">size</span><span class="o">=</span><span class="n">mask_arr</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="n">mask_arr</span><span class="o">.</span><span class="n">size</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
  <span class="n">vals_arr</span> <span class="o">=</span> <span class="n">_tile_to_size</span><span class="p">(</span><span class="n">vals_arr</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">indices</span><span class="p">))</span>
  <span class="k">return</span> <span class="n">data</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span><span class="o">.</span><span class="n">at</span><span class="p">[</span><span class="n">indices</span><span class="p">]</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">vals_arr</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;drop&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>


<span class="nd">@util</span><span class="o">.</span><span class="n">_wraps</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">put</span><span class="p">,</span> <span class="n">lax_description</span><span class="o">=</span><span class="s2">&quot;&quot;&quot;</span>
<span class="s2">The semantics of :func:`numpy.put` is to modify arrays in-place, which JAX</span>
<span class="s2">cannot do because JAX arrays are immutable. Thus :func:`jax.numpy.put` adds</span>
<span class="s2">the ``inplace`` parameter, which must be set to ``False`` by the user as a</span>
<span class="s2">reminder of this API difference.</span>
<span class="s2">&quot;&quot;&quot;</span><span class="p">,</span> <span class="n">extra_params</span><span class="o">=</span><span class="s2">&quot;&quot;&quot;</span>
<span class="s2">inplace : bool, default=True</span>
<span class="s2">    If left to its default value of True, JAX will raise an error. This is because</span>
<span class="s2">    the semantics of :func:`numpy.put` are to modify the array in-place, which is</span>
<span class="s2">    not possible in JAX due to the immutability of JAX arrays.</span>
<span class="s2">&quot;&quot;&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">put</span><span class="p">(</span><span class="n">a</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">,</span> <span class="n">ind</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">,</span> <span class="n">v</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">,</span>
        <span class="n">mode</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">inplace</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Array</span><span class="p">:</span>
  <span class="n">util</span><span class="o">.</span><span class="n">check_arraylike</span><span class="p">(</span><span class="s2">&quot;put&quot;</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">ind</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
  <span class="n">arr</span><span class="p">,</span> <span class="n">ind_arr</span><span class="p">,</span> <span class="n">v_arr</span> <span class="o">=</span> <span class="n">asarray</span><span class="p">(</span><span class="n">a</span><span class="p">),</span> <span class="n">ravel</span><span class="p">(</span><span class="n">ind</span><span class="p">),</span> <span class="n">ravel</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
  <span class="k">if</span> <span class="ow">not</span> <span class="n">arr</span><span class="o">.</span><span class="n">size</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">ind_arr</span><span class="o">.</span><span class="n">size</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">v_arr</span><span class="o">.</span><span class="n">size</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">arr</span>
  <span class="n">v_arr</span> <span class="o">=</span> <span class="n">_tile_to_size</span><span class="p">(</span><span class="n">v_arr</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">ind_arr</span><span class="p">))</span>
  <span class="k">if</span> <span class="n">inplace</span><span class="p">:</span>
    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
      <span class="s2">&quot;jax.numpy.put cannot modify arrays in-place, because JAX arrays are immutable. &quot;</span>
      <span class="s2">&quot;Pass inplace=False to instead return an updated array.&quot;</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">mode</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
    <span class="n">scatter_mode</span> <span class="o">=</span> <span class="s2">&quot;drop&quot;</span>
  <span class="k">elif</span> <span class="n">mode</span> <span class="o">==</span> <span class="s2">&quot;clip&quot;</span><span class="p">:</span>
    <span class="n">ind_arr</span> <span class="o">=</span> <span class="n">clip</span><span class="p">(</span><span class="n">ind_arr</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">arr</span><span class="o">.</span><span class="n">size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">scatter_mode</span> <span class="o">=</span> <span class="s2">&quot;promise_in_bounds&quot;</span>
  <span class="k">elif</span> <span class="n">mode</span> <span class="o">==</span> <span class="s2">&quot;wrap&quot;</span><span class="p">:</span>
    <span class="n">ind_arr</span> <span class="o">=</span> <span class="n">ind_arr</span> <span class="o">%</span> <span class="n">arr</span><span class="o">.</span><span class="n">size</span>
    <span class="n">scatter_mode</span> <span class="o">=</span> <span class="s2">&quot;promise_in_bounds&quot;</span>
  <span class="k">elif</span> <span class="n">mode</span> <span class="o">==</span> <span class="s2">&quot;raise&quot;</span><span class="p">:</span>
    <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;The &#39;raise&#39; mode to jnp.put is not supported.&quot;</span><span class="p">)</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;mode should be one of &#39;wrap&#39; or &#39;clip&#39;; got </span><span class="si">{</span><span class="n">mode</span><span class="si">=}</span><span class="s2">&quot;</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">arr</span><span class="o">.</span><span class="n">at</span><span class="p">[</span><span class="n">unravel_index</span><span class="p">(</span><span class="n">ind_arr</span><span class="p">,</span> <span class="n">arr</span><span class="o">.</span><span class="n">shape</span><span class="p">)]</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">v_arr</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="n">scatter_mode</span><span class="p">)</span>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2022, Sebastian Schaffer.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>